{
    "questions": [
        {
            "type": "single-choice",
            "content": "软件生命周期由几个时期组成？",
            "options": [
                "2 个",
                "3 个",
                "4 个",
                "5 个"
            ],
            "correct_answer": [
                "3 个"
            ],
            "analysis": "生命周期分为软件定义、软件开发、软件维护三个时期。"
        },
        {
            "type": "fill-in-blank",
            "content": "软件生命周期的三个时期依次是（ ）、（ ）、（ ）。",
            "blanks": [
                "空1",
                "空2",
                "空3"
            ],
            "correct_answer": [
                "软件定义",
                "软件开发",
                "软件维护"
            ],
            "analysis": "三大时期覆盖从立项到退役的完整过程。"
        },
        {
            "type": "fill-in-blank",
            "content": "软件生存期八个阶段中最重要的前三个阶段是（ ）、（ ）、（ ）。",
            "blanks": [
                "空1",
                "空2",
                "空3"
            ],
            "correct_answer": [
                "问题定义",
                "可行性研究",
                "需求分析"
            ],
            "analysis": "这三步决定项目目标与可行性，并澄清用户需求。"
        },
        {
            "type": "fill-in-blank",
            "content": "需求分析包括四个基本步骤：先（ ），再（ ），然后（ ），最后（ ）。",
            "blanks": [
                "空1",
                "空2",
                "空3",
                "空4"
            ],
            "correct_answer": [
                "获取需求",
                "分析需求",
                "定义需求",
                "验证需求"
            ],
            "analysis": "对应英语术语为 Elicitation–Analysis–Specification–Validation。"
        },
        {
            "type": "single-choice",
            "content": "以下哪一对被归类为经典的软件工程方法？",
            "options": [
                "结构化方法与面向对象方法",
                "敏捷方法与螺旋方法",
                "快速原型与极限编程",
                "DevOps 与持续交付"
            ],
            "correct_answer": [
                "结构化方法与面向对象方法"
            ],
            "analysis": "结构化方法强调功能分解；面向对象强调抽象、封装、继承与多态。"
        },
        {
            "type": "short-answer",
            "content": "什么是“软件危机”？",
            "correct_answer": [
                "在软件开发与维护过程中出现的一系列成本高、进度拖延、质量难以保证的问题统称软件危机。"
            ],
            "analysis": "软件危机促生软件工程学科，用工程化手段改进质量与效率。"
        },
        {
            "type": "single-choice",
            "content": "瀑布模型的突出特点是（ ）。",
            "options": [
                "阶段边界清晰、文档驱动",
                "面向对象、阶段可重叠",
                "风险迭代驱动",
                "持续交付、小步快跑"
            ],
            "correct_answer": [
                "阶段边界清晰、文档驱动"
            ],
            "analysis": "瀑布模型强调顺序性，阶段输出文档作为下阶段输入。"
        },
        {
            "type": "single-choice",
            "content": "喷泉模型最适合描述哪类开发过程？",
            "options": [
                "面向对象软件开发",
                "嵌入式硬实时开发",
                "传统批处理系统",
                "数据库迁移项目"
            ],
            "correct_answer": [
                "面向对象软件开发"
            ],
            "analysis": "喷泉模型以对象为驱动、需求为动力，阶段可迭代重叠。"
        },
        {
            "type": "single-choice",
            "content": "螺旋模型相比其他模型最大的新增强调点是（ ）。",
            "options": [
                "风险分析",
                "严格阶段划分",
                "客户参与",
                "快速原型"
            ],
            "correct_answer": [
                "风险分析"
            ],
            "analysis": "每一圈迭代都围绕风险识别、评估、消减展开。"
        },
        {
            "type": "single-choice",
            "content": "数据流图 (DFD) 属于结构化分析框架中的哪一类建模？",
            "options": [
                "功能建模",
                "数据建模",
                "行为建模",
                "核心数据字典"
            ],
            "correct_answer": [
                "功能建模"
            ],
            "analysis": "DFD 用于刻画系统功能变换及数据流向。"
        },
        {
            "type": "fill-in-blank",
            "content": "结构化分析的四大建模内容依次是：功能建模（DFD）、数据建模（ER）、行为建模（ ），以及核心框架（ ）。",
            "blanks": [
                "空1",
                "空2"
            ],
            "correct_answer": [
                "状态转换图",
                "数据字典"
            ],
            "analysis": "状态图捕获对象行为，数据字典统一定义所有数据项。"
        },
        {
            "type": "short-answer",
            "content": "从设计角度，如何提高模块独立性？给出至少两条措施。",
            "correct_answer": [
                "例如：确保模块单一职责；信息隐藏；减少共享数据；通过接口解耦；合理分解或合并模块。"
            ],
            "analysis": "目标是高内聚低耦合，利于理解、测试、维护。"
        },
        {
            "type": "fill-in-blank",
            "content": "内聚描述模块内部元素结合的（ ），耦合描述模块之间的（ ）。",
            "blanks": [
                "空1",
                "空2"
            ],
            "correct_answer": [
                "紧密程度",
                "相互依赖程度"
            ],
            "analysis": "高内聚低耦合是模块化设计的黄金法则。"
        },
        {
            "type": "fill-in-blank",
            "content": "扇入表示调用该模块的下层模块数，扇出表示（ ）。",
            "blanks": [
                "空1"
            ],
            "correct_answer": [
                "该模块直接调用的下层模块数"
            ],
            "analysis": "扇入/扇出用于衡量模块的接口复杂度。"
        },
        {
            "type": "fill-in-blank",
            "content": "McCabe 环路复杂度公式 V(G) = （ ） - N + 2",
            "blanks": [
                "空1"
            ],
            "correct_answer": [
                "E"
            ],
            "analysis": "E 表边数，N 节点数；也可用判定节点数 P 写成 V(G)=P+1。"
        },
        {
            "type": "fill-in-blank",
            "content": "若一个函数包含 4 个判定节点，其 McCabe 复杂度 V(G) 为（ ）。",
            "blanks": [
                "空1"
            ],
            "correct_answer": [
                "5"
            ],
            "analysis": "使用公式 V(G)=P+1，P=4 则 V(G)=5，意味着至少 5 条独立测试路径。"
        },
        {
            "type": "single-choice",
            "content": "软件测试的主要目的是什么？",
            "options": [
                "发现并定位软件错误",
                "证明软件绝对正确",
                "提升编程速度",
                "生成项目文档"
            ],
            "correct_answer": [
                "发现并定位软件错误"
            ],
            "analysis": "测试侧重暴露缺陷，而不是形式化证明程序无误。"
        },
        {
            "type": "single-choice",
            "content": "等价类划分法属于哪一种测试方法？",
            "options": [
                "黑盒测试方法",
                "白盒测试方法",
                "静态代码分析技术",
                "性能测试技术"
            ],
            "correct_answer": [
                "黑盒测试方法"
            ],
            "analysis": "等价类划分通过划分输入域来设计用例，完全基于功能规格。"
        },
        {
            "type": "single-choice",
            "content": "在等价类划分法中，应从每个等价类中选取怎样的数据？",
            "options": [
                "少量具有代表性的数据",
                "所有可能的数据",
                "随机生成的大量数据",
                "只选取边界值数据"
            ],
            "correct_answer": [
                "少量具有代表性的数据"
            ],
            "analysis": "代表性数据足以覆盖该类的行为，可减少测试用例数量。"
        },
        {
            "type": "single-choice",
            "content": "以下哪项不属于面向对象测试的典型层次？",
            "options": [
                "面向对象单元测试",
                "面向对象集成测试",
                "面向对象系统测试",
                "机器指令级汇编测试"
            ],
            "correct_answer": [
                "机器指令级汇编测试"
            ],
            "analysis": "面向对象测试关注类、对象及其交互，而汇编级测试超出 OO 范畴。"
        },
        {
            "type": "single-choice",
            "content": "下列关于封装的描述哪一项是正确的？",
            "options": [
                "封装是将数据与操作数据的方法组合为整体",
                "封装是一种使子类继承父类属性的方法",
                "封装允许相同操作作用于多种对象并产生不同结果",
                "封装强调过程调用而非对象"
            ],
            "correct_answer": [
                "封装是将数据与操作数据的方法组合为整体"
            ],
            "analysis": "封装通过信息隐藏实现模块独立，与继承、多态含义不同。"
        },
        {
            "type": "single-choice",
            "content": "继承性的核心含义是（ ）。",
            "options": [
                "子类自动共享父类的数据和方法",
                "相同接口多种实现",
                "将实现细节对外隐藏",
                "函数重载机制"
            ],
            "correct_answer": [
                "子类自动共享父类的数据和方法"
            ],
            "analysis": "继承实现代码复用和层次结构，区别于多态与封装。"
        },
        {
            "type": "single-choice",
            "content": "多态性的本质是指（ ）。",
            "options": [
                "同一操作在不同对象上产生不同效果",
                "隐藏对象数据",
                "子类继承父类",
                "提高程序性能"
            ],
            "correct_answer": [
                "同一操作在不同对象上产生不同效果"
            ],
            "analysis": "多态允许统一接口、不同实现，提升灵活性与扩展性。"
        },
        {
            "type": "single-choice",
            "content": "用例图的主要作用是（ ）。",
            "options": [
                "从用户视角描述系统提供的功能",
                "展示类之间的静态关系",
                "刻画对象的动态状态迁移",
                "表示数据库表结构"
            ],
            "correct_answer": [
                "从用户视角描述系统提供的功能"
            ],
            "analysis": "用例图回答“系统应为外部参与者做什么”，关注功能边界。"
        },
        {
            "type": "single-choice",
            "content": "下列哪一种图用来描述类之间的静态关系？",
            "options": [
                "类图",
                "用例图",
                "活动图",
                "顺序图"
            ],
            "correct_answer": [
                "类图"
            ],
            "analysis": "类图定义属性、方法以及各种关系，是面向对象设计的骨架。"
        },
        {
            "type": "single-choice",
            "content": "面向对象分析常用的三个模型中，交互模型通常通过（ ）表示其时序行为。",
            "options": [
                "顺序图或活动图",
                "类图",
                "用例图",
                "组件图"
            ],
            "correct_answer": [
                "顺序图或活动图"
            ],
            "analysis": "交互模型刻画对象协作流程，可用顺序图、通信图、活动图等。"
        },
        {
            "type": "single-choice",
            "content": "面向对象设计的第一步通常是（ ）。",
            "options": [
                "定义环境模型",
                "划分子系统",
                "详细对象设计",
                "优化实现代码"
            ],
            "correct_answer": [
                "定义环境模型"
            ],
            "analysis": "环境模型明确外部实体及其交互，为后续架构划分奠定基础。"
        },
        {
            "type": "single-choice",
            "content": "系统体系结构设计的主要任务是（ ）。",
            "options": [
                "将系统划分为若干子系统",
                "给每个类补充属性与方法",
                "编写单元测试代码",
                "制定部署脚本"
            ],
            "correct_answer": [
                "将系统划分为若干子系统"
            ],
            "analysis": "体系结构设计关注宏观结构与模块边界。"
        },
        {
            "type": "single-choice",
            "content": "在模块度量中，扇入/扇出的测度主要用于评估模块的（ ）。",
            "options": [
                "接口复杂度和依赖程度",
                "算法时间复杂度",
                "数据存储大小",
                "代码注释比例"
            ],
            "correct_answer": [
                "接口复杂度和依赖程度"
            ],
            "analysis": "扇入高可能增加复用价值，扇出高则耦合度升高。"
        },
        {
            "type": "single-choice",
            "content": "某函数控制流图包含 10 条边、8 个节点，试问其 McCabe 复杂度是多少？",
            "options": [
                "2",
                "3",
                "4",
                "5"
            ],
            "correct_answer": [
                "4"
            ],
            "analysis": "使用 V(G)=E−N+2=10−8+2=4，意味着至少 4 条独立测试路径。"
        },
        {
            "type": "single-choice",
            "content": "若一个函数有 4 个判定节点，则其 McCabe 复杂度 V(G) 等于（ ）。",
            "options": [
                "4",
                "5",
                "6",
                "8"
            ],
            "correct_answer": [
                "5"
            ],
            "analysis": "用简化公式 V(G)=P+1（P 为判定节点数），故 V(G)=4+1=5。"
        },
        {
            "type": "single-choice",
            "content": "在四种软件维护类型中，实际工作中比例最高、最常见的是（ ）。",
            "options": [
                "改正性维护",
                "适应性维护",
                "完善性维护",
                "预防性维护"
            ],
            "correct_answer": [
                "完善性维护"
            ],
            "analysis": "统计显示完善性维护（为满足新增功能与性能要求）通常占 50% 以上。"
        },
        {
            "type": "single-choice",
            "content": "以下哪一种维护活动主要针对发现缺陷后对软件进行修复？",
            "options": [
                "改正性维护",
                "适应性维护",
                "完善性维护",
                "预防性维护"
            ],
            "correct_answer": [
                "改正性维护"
            ],
            "analysis": "改正性维护旨在识别和纠正错误或缺陷，恢复正确功能与性能。"
        },
        {
            "type": "single-choice",
            "content": "当操作系统升级导致原软件无法运行，需要进行哪一种维护？",
            "options": [
                "改正性维护",
                "适应性维护",
                "完善性维护",
                "预防性维护"
            ],
            "correct_answer": [
                "适应性维护"
            ],
            "analysis": "适应性维护是为了适配外部环境变化（硬件、OS、网络等）所做的修改。"
        },
        {
            "type": "single-choice",
            "content": "为了未来方便扩展而主动重构代码并补充单元测试，这属于（ ）维护。",
            "options": [
                "改正性维护",
                "适应性维护",
                "完善性维护",
                "预防性维护"
            ],
            "correct_answer": [
                "预防性维护"
            ],
            "analysis": "预防性维护面向未来可维护性/可靠性，非为当前缺陷或需求而改动。"
        },
        {
            "type": "single-choice",
            "content": "下列哪项不是决定软件可维护性的六个因素之一？",
            "options": [
                "可理解性",
                "可测试性",
                "可扩展性",
                "可移植性"
            ],
            "correct_answer": [
                "可扩展性"
            ],
            "analysis": "六因素为：可理解性、可测试性、可靠性、可修改性、可移植性、可重用性。"
        },
        {
            "type": "single-choice",
            "content": "软件可维护性的最关键影响因素通常被认为是（ ）。",
            "options": [
                "文档",
                "编程语言",
                "代码行数",
                "版本控制系统"
            ],
            "correct_answer": [
                "文档"
            ],
            "analysis": "完备、同步的文档直接决定维护人员理解和修改软件的效率与正确性。"
        },
        {
            "type": "single-choice",
            "content": "在再工程活动中，用于恢复现有程序设计信息的关键技术是（ ）。",
            "options": [
                "正向工程",
                "逆向工程",
                "配置管理",
                "持续集成"
            ],
            "correct_answer": [
                "逆向工程"
            ],
            "analysis": "逆向工程通过分析可执行代码/数据抽取架构和设计信息，为再工程奠基。"
        },
        {
            "type": "single-choice",
            "content": "甘特图在项目管理中最主要的作用是（ ）。",
            "options": [
                "显示各任务的起止时间与进度",
                "分析项目风险等级",
                "描述任务之间的逻辑依赖",
                "估算项目资源成本"
            ],
            "correct_answer": [
                "显示各任务的起止时间与进度"
            ],
            "analysis": "甘特图用条形图方式直观映射计划时间、实际进度。"
        },
        {
            "type": "single-choice",
            "content": "网络图在项目管理中的核心用途是（ ）。",
            "options": [
                "展示活动之间的逻辑关系和关键路径",
                "记录人员分工",
                "生成项目财务报表",
                "跟踪缺陷修复数量"
            ],
            "correct_answer": [
                "展示活动之间的逻辑关系和关键路径"
            ],
            "analysis": "网络图（如 PERT/CPM 图）通过节点/箭线揭示任务依赖与关键路径。"
        },
        {
            "type": "single-choice",
            "content": "下列六个选项中，哪一项确实属于决定软件可维护性的因素？",
            "options": [
                "可重用性",
                "可扩展性",
                "市场占有率",
                "团队规模"
            ],
            "correct_answer": [
                "可重用性"
            ],
            "analysis": "可重用性与可维护性正相关，其余选项不在六因素之列。"
        },
        {
            "type": "single-choice",
            "content": "以下哪一项属于典型的需求分析工具？",
            "options": [
                "数据流图 (DFD)",
                "JUnit 测试框架",
                "Git 版本控制",
                "Docker 容器"
            ],
            "correct_answer": [
                "数据流图 (DFD)"
            ],
            "analysis": "DFD、ER 图、UML 用例/类图等均属于需求分析阶段使用的图形化建模工具。"
        },
        {
            "type": "single-choice",
            "content": "面向对象需求分析工具通常不包含下列哪项？",
            "options": [
                "类库管理系统",
                "对象浏览器",
                "UML 图形建模工具",
                "链接编辑器"
            ],
            "correct_answer": [
                "链接编辑器"
            ],
            "analysis": "链接编辑器属于编译/构建工具，与需求分析无关。"
        },
        {
            "type": "single-choice",
            "content": "黑盒测试关注的是（ ）。",
            "options": [
                "程序的外部功能与输入输出",
                "源代码行覆盖率",
                "循环复杂度",
                "内部数据结构实现"
            ],
            "correct_answer": [
                "程序的外部功能与输入输出"
            ],
            "analysis": "黑盒测试不关心内部逻辑，侧重验证功能需求。"
        },
        {
            "type": "single-choice",
            "content": "以下哪一种属于黑盒测试常用方法？",
            "options": [
                "等价类划分",
                "条件判定覆盖",
                "路径覆盖",
                "语句覆盖"
            ],
            "correct_answer": [
                "等价类划分"
            ],
            "analysis": "等价类划分、边界值分析、因果图、错误推测等均为黑盒方法。"
        },
        {
            "type": "single-choice",
            "content": "白盒测试的主要目标是（ ）。",
            "options": [
                "覆盖程序内部逻辑路径并与预期状态比对",
                "检查用户界面易用性",
                "评估系统性能瓶颈",
                "比较不同算法的时间复杂度"
            ],
            "correct_answer": [
                "覆盖程序内部逻辑路径并与预期状态比对"
            ],
            "analysis": "白盒测试侧重源代码路径、条件、循环等内部结构。"
        },
        {
            "type": "single-choice",
            "content": "下列哪项属于白盒“逻辑覆盖”技术？",
            "options": [
                "语句覆盖",
                "等价类划分",
                "边界值分析",
                "释放内存检测"
            ],
            "correct_answer": [
                "语句覆盖"
            ],
            "analysis": "逻辑覆盖包括语句、判定、条件、路径等覆盖准则，属于动态白盒测试。"
        },
        {
            "type": "single-choice",
            "content": "在三层 C/S 结构中，处理业务规则的层是（ ）。",
            "options": [
                "表示层 (Client UI)",
                "应用逻辑层 (Application Server)",
                "数据管理层 (Database Server)",
                "网络交换层 (Switch)"
            ],
            "correct_answer": [
                "应用逻辑层 (Application Server)"
            ],
            "analysis": "业务逻辑集中于服务器侧中间层，减轻客户端负担。"
        },
        {
            "type": "single-choice",
            "content": "三层 C/S 架构相较于传统两层 C/S 架构的主要改进是（ ）。",
            "options": [
                "将业务逻辑从客户端移至独立的应用服务器",
                "将数据库移动到客户端",
                "取消用户界面层",
                "增加硬件冗余节点"
            ],
            "correct_answer": [
                "将业务逻辑从客户端移至独立的应用服务器"
            ],
            "analysis": "三层结构通过引入中间层解决两层模型在并发、扩展与安全方面的不足。"
        },
        {
            "type": "single-choice",
            "content": "在三层 C/S 架构中，下列职责通常由数据管理层承担？",
            "options": [
                "全局数据完整性规则和备份恢复",
                "渲染用户界面",
                "处理业务流程逻辑",
                "生成客户端报表打印"
            ],
            "correct_answer": [
                "全局数据完整性规则和备份恢复"
            ],
            "analysis": "数据管理层位于数据库服务器，负责安全、并发控制与备份。"
        }
    ],
    "sets": [
        {
            "id": "rjgc-x",
            "name": "x-软工期末知识点",
            "category": "软件工程",
            "tags": [
                "软件工程",
                "软件生命周期",
                "需求分析",
                "软件工程方法",
                "结构化分析",
                "面向对象",
                "测试技术",
                "维护与度量",
                "项目管理"
            ],
            "createTime": "2025-06-27 16:03:00",
            "updateTime": "2025-06-27 16:03:00",
            "description": "来自最后一课提到的考点的 AI 生成题库。"
        }
    ]
}