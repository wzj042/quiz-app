{
  "questions": [
    {
      "uniqueId": "MEM01",
      "content": "在虚拟内存管理中，地址变换机构将逻辑地址变换为物理地址，形成该逻辑地址的阶段是()。",
      "type": "single-choice",
      "options": [
        "编辑",
        "编译",
        "链接",
        "装载"
      ],
      "correct_answer": [
        "链接"
      ],
      "analysis": "编译后的程序需要经过链接才能装载，而链接后形成的目标程序中的地址也就是逻辑地址。以C语言为例:C程序经过预处理→编译→汇编→链接产生了可执行文件，其中链接的前一步是产生可重定位的二进制目标文件。C语言采用源文件独立编译的方法，如程序main.c，filel.c，file2.c，filel.h，file2.h在链接的前一步生成了main.o，filel.o，file2.o，这些目标模块的逻辑地址都从0开始，但只是相对于该模块的逻辑地址。链接器将这三个文件、bc和其库文件链接成一个可执行文件。\n链接阶段主要完成重定位，形成整个程序的完整逻辑地址空间。"
    },
    {
      "uniqueId": "MEM02",
      "content": "在使用交换技术时，若一个进程正在()，则不能交换出主存。",
      "type": "single-choice",
      "options": [
        "创建",
        "I/O操作",
        "处于临界段",
        "死锁"
      ],
      "correct_answer": [
        "I/O操作"
      ],
      "analysis": "进程正在进行/O操作时不能换出主存，否则其I/O数据区将被新换入的进程占用，导致错误。不过可以在操作系统中开辟/O缓冲区，将数据从外设输入或将数据输出到外设的I/O活动在系统缓冲区中进行，这时系统缓冲区与外设/O时，进程交换不受限制。"
    },
    {
      "uniqueId": "MEM03",
      "content": "在存储管理中，采用覆盖与交换技术的目的是()。",
      "type": "single-choice",
      "options": [
        "节省主存空间",
        "物理上扩充主存容量",
        "提高CPU效率",
        "实现主存共享"
      ],
      "correct_answer": [
        "节省主存空间"
      ],
      "analysis": "覆盖和交换的提出就是为了解决主存空间不足的问题，但不是在物理上扩充主存，只是将暂时不用的部分换出主存，以节省空间，从而在逻辑上扩充主存。"
    },
    {
      "uniqueId": "MEM04",
      "content": "某基于动态分区存储管理的计算机，其主存容量为55MB(初始为空)，采用最佳适配(Best Fit)算法，分配和释放的顺序为:分配15MB，分配30MB，释放15MB，分配8MB，分配6MB，此时主存中最大空闲分区的大小是()。",
      "type": "single-choice",
      "options": [
        "7MB",
        "9MB",
        "10MB",
        "15MB"
      ],
      "correct_answer": [
        "9MB"
      ],
      "analysis": "最佳适配算法是指每次为作业分配内存空间时，总是找到能满足空间大小需要的最小空闲分区给作业，可以产生最小的内存空闲分区。下图显示了这个过程的主存空间变化。\n\n<table border='1'><thead><tr><th>操作</th><th>内存状态</th><th>最大空闲分区</th></tr></thead><tbody><tr><td>初始</td><td>[55MB]</td><td>55MB</td></tr><tr><td>分配15MB</td><td>[15MB][40MB]</td><td>40MB</td></tr><tr><td>分配30MB</td><td>[15MB][30MB][10MB]</td><td>15MB</td></tr><tr><td>释放15MB</td><td>[30MB][15MB][10MB]</td><td>30MB</td></tr><tr><td>分配8MB</td><td>[30MB][8MB][7MB][10MB]</td><td>30MB</td></tr><tr><td>分配6MB</td><td>[30MB][8MB][2MB][6MB][10MB]</td><td>30MB</td></tr></tbody></table>\n图中，灰色部分为分配出去的空间，白色部分为空闲区。这样，容易发现，此时主存中最大空闲分区的大小为9MB。"
    },
    {
      "uniqueId": "MEM05",
      "content": "段页式存储管理中，地址映射表是()。",
      "type": "single-choice",
      "options": [
        "每个进程一张段表，两张页表",
        "每个进程的每个段一张段表，一张页表",
        "每个进程一张段表，每个段一张页表",
        "每个进程一张页表，每个段一张段表"
      ],
      "correct_answer": [
        "每个进程一张段表，每个段一张页表"
      ],
      "analysis": "段页式系统中，进程首先划分为段，每段再进一步划分为页。"
    },
    {
      "uniqueId": "MEM06",
      "content": "内存保护需要由()完成，以保证进程空间不被非法访问。",
      "type": "single-choice",
      "options": [
        "操作系统",
        "硬件机构",
        "操作系统和硬件机构合作",
        "操作系统或者硬件机构独立完成"
      ],
      "correct_answer": [
        "操作系统和硬件机构合作"
      ],
      "analysis": "内存保护是内存管理的一部分，是操作系统的任务，但是出于安全性和效率考虑，必须由硬件实现，所以需要操作系统和硬件机构的合作来完成。"
    },
    {
      "uniqueId": "MEM07",
      "content": "存储管理方案中，()可采用覆盖技术。",
      "type": "single-choice",
      "options": [
        "单一连续存储管理",
        "可变分区存储管理",
        "段式存储管理",
        "段页式存储管理"
      ],
      "correct_answer": [
        "单一连续存储管理"
      ],
      "analysis": "覆盖技术是早期在单一连续存储管理中使用的扩大存储容量的一种技术，它同样可用于固定分区分配的存储管理。"
    },
    {
      "uniqueId": "MEM08",
      "content": "在可变分区分配方案中，某一进程完成后，系统回收其主存空间并与相邻空闲区合并，为此需修改空闲区表，造成空闲区数减1的情况是()。",
      "type": "single-choice",
      "options": [
        "无上邻空闲区也无下邻空闲区",
        "有上邻空闲区但无下邻空闲区",
        "有下邻空闲区但无上邻空闲区",
        "有上邻空闲区也有下邻空闲区"
      ],
      "correct_answer": [
        "有上邻空闲区也有下邻空闲区"
      ],
      "analysis": "将上邻空闲区、下邻空闲区和回收区合并为一个空闲区，因此空闲区数反而减少了一个。而仅有上邻空闲区或下邻空闲区时，空闲区数并不减少。"
    },
    {
      "uniqueId": "MEM09",
      "content": "动态重定位是在作业的()中进行的。",
      "type": "single-choice",
      "options": [
        "编译过程",
        "装入过程",
        "链接过程",
        "执行过程"
      ],
      "correct_answer": [
        "执行过程"
      ],
      "analysis": "静态装入是指在编程阶段就把物理地址计算好;可重定位是指在装入时把逻辑地址转换成物理地址，但装入后不能改变。静态重定位是指在目标程序装入内存时，由装入程序对目标程序中的指令和数据的地址进行修改，即把程序的逻辑地址都改成实际的内存地址;动态重定位是指在作业运行过程中执行到一条访存指令时，再把逻辑地址转换为主存中的物理地址，实际中是通过硬件地址转换机制实现的。"
    },
    {
      "uniqueId": "MEM10",
      "content": "下面的存储管理方案中，()方式可以采用静态重定位。",
      "type": "single-choice",
      "options": [
        "固定分区",
        "动态分区",
        "页式",
        "段式"
      ],
      "correct_answer": [
        "固定分区"
      ],
      "analysis": "固定分区方式中，作业装入后位置不再改变，可以采用静态重定位。其余三种管理方案均可能在运行过程中改变程序位置，静态重定位不能满足其要求。"
    },
    {
      "uniqueId": "MEM11",
      "content": "在动态分区管理中，采用拼接技术的目的是()。",
      "type": "single-choice",
      "options": [
        "合并空闲区",
        "合并分配区",
        "增加主存容量",
        "便于地址转换"
      ],
      "correct_answer": [
        "合并空闲区"
      ],
      "analysis": "在动态分区管理中，回收空闲区时采用拼接技术对空闲区进行合并。"
    },
    {
      "uniqueId": "MEM12",
      "content": "不会产生内部碎片的存储管理是()。",
      "type": "single-choice",
      "options": [
        "分页式存储管理",
        "分段式存储管理",
        "固定分区式存储管理",
        "段页式存储管理"
      ],
      "correct_answer": [
        "分段式存储管理"
      ],
      "analysis": "分页式存储管理有内部碎片，分段式存储管理有外部碎片，固定分区存储管理方式有内部碎片，段页式存储管理方式有内部碎片。"
    },
    {
      "uniqueId": "MEM13",
      "content": "多进程在主存中彼此互不干扰的环境下运行，操作系统是通过()来实现的。",
      "type": "single-choice",
      "options": [
        "内存分配",
        "内存保护",
        "内存扩充",
        "地址映射"
      ],
      "correct_answer": [
        "内存保护"
      ],
      "analysis": "多进程的执行通过内存保护实现互不干扰，如页式管理中有页地址越界保护，段式管理中有段地址越界保护。"
    },
    {
      "uniqueId": "MEM14",
      "content": "动态分区管理中采用最佳适应分配算法时，把空闲区按()次序登记在空闲区表中。",
      "type": "single-choice",
      "options": [
        "长度递增",
        "长度递减",
        "地址递增",
        "地址递减"
      ],
      "correct_answer": [
        "长度递增"
      ],
      "analysis": "最佳适应算法要求从剩余的空闲分区中选出最小且满足存储要求的分区，空闲区应按长度递增登记在空闲区表中。"
    },
    {
      "uniqueId": "MEM15",
      "content": "最先(首次)适应算法的空闲分区()。",
      "type": "single-choice",
      "options": [
        "按大小递减顺序连在一起",
        "按大小递增顺序连在一起",
        "按地址由小到大排列",
        "按地址由大到小排列"
      ],
      "correct_answer": [
        "按地址由小到大排列"
      ],
      "analysis": "首次适应算法的空闲分区按地址递增的次序排列。"
    },
    {
      "uniqueId": "MEM16",
      "content": "采用分页或分段管理后，提供给用户的物理地址空间()。",
      "type": "single-choice",
      "options": [
        "分页支持更大的物理地址空间",
        "分段支持更大的物理地址空间",
        "不能确定",
        "一样大"
      ],
      "correct_answer": [
        "不能确定"
      ],
      "analysis": "页表和段表同样存储在内存中，系统提供给用户的物理地址空间为总空间大小减去页表或段表的长度。由于页表和段表的长度不能确定，所以提供给用户的物理地址空间大小也不能确定。"
    },
    {
      "uniqueId": "MEM17",
      "content": "分页系统中的页面是为()。",
      "type": "single-choice",
      "options": [
        "用户所感知的",
        "操作系统所感知的",
        "编译系统所感知的",
        "连接装配程序所感知的"
      ],
      "correct_answer": [
        "操作系统所感知的"
      ],
      "analysis": "内存分页管理是在硬件和操作系统层面实现的，对用户、编译系统、连接装配程序等上层是不可见的。"
    },
    {
      "uniqueId": "MEM18",
      "content": "页式存储管理中，页表的始地址存放在()中。",
      "type": "single-choice",
      "options": [
        "内存",
        "存储页表",
        "快表",
        "寄存器"
      ],
      "correct_answer": [
        "寄存器"
      ],
      "analysis": "页表的功能由一组专门的存储器实现，其始址放在页表基址寄存器(PTBR)中。这样才能满足在地址变换时能够较快地完成逻辑地址和物理地址之间的转换。"
    },
    {
      "uniqueId": "MEM19",
      "content": "对重定位存储管理方式，应()。",
      "type": "single-choice",
      "options": [
        "在整个系统中设置一个重定位寄存器",
        "为每道程序设置一个重定位寄存器",
        "为每道程序设置两个重定位寄存器",
        "为每道程序和数据都设置一个重定位寄存器"
      ],
      "correct_answer": [
        "在整个系统中设置一个重定位寄存器"
      ],
      "analysis": "为使地址转换不影响到指令的执行速度，必须有硬件地址变换结构的支持，即需在系统中增设一个重定位寄存器，用它来存放程序(数据)在内存中的始址。在执行程序或访问数据时，真正访问的内存地址由相对地址与重定位寄存器中的地址相加而成，这时将始址存入重定位寄存器，之后的地址访问即可通过硬件变换实现。因为系统处理器在同一时刻只能执行一条指令或访问数据，所以为每道程序(数据)设置一个寄存器没有必要(同时也不现实，因为寄存器是很昂贵的硬件，而且程序的道数是无法预估的)，而只需在切换程序执行时重置寄存器内容。"
    },
    {
      "uniqueId": "MEM20",
      "content": "采用段式存储管理时，一个程序如何分段是在()时决定的。",
      "type": "single-choice",
      "options": [
        "分配主存",
        "用户编程",
        "装作业",
        "程序执行"
      ],
      "correct_answer": [
        "用户编程"
      ],
      "analysis": "分段是指在用户编程时，将程序按照逻辑划分为几个逻辑段。"
    },
    {
      "uniqueId": "MEM21",
      "content": "下面的()方法有利于程序的动态链接。",
      "type": "single-choice",
      "options": [
        "分段存储管理",
        "分页存储管理",
        "可变式分区管理",
        "固定式分区管理"
      ],
      "correct_answer": [
        "分段存储管理"
      ],
      "analysis": "程序的动态链接与程序的逻辑结构相关，分段存储管理将程序按照逻辑段进行划分，因此有利于其动态链接。其他的内存管理方式与程序的逻辑结构无关。"
    },
    {
      "uniqueId": "MEM22",
      "content": "动态分区又称可变式分区，它是系统运行过程中()动态建立的。",
      "type": "single-choice",
      "options": [
        "在作业装入时",
        "在作业创建时",
        "在作业完成时",
        "在作业未装入时"
      ],
      "correct_answer": [
        "在作业装入时"
      ],
      "analysis": "动态分区时，在系统启动后，除操作系统占据一部分内存外，其余所有内存空间是一个大空闲区，称为自由空间。若作业申请内存，则从空闲区中划出一个与作业需求量相适应的分区分配给该作业，将作业创建为进程，在作业运行完毕后，再收回释放的分区。"
    },
    {
      "uniqueId": "MEM23",
      "content": "某计算机按字节编址，其动态分区内存管理采用最佳适应算法，每次分配和回收内存后都对空闲分区链重新排序。当前空闲分区信息如下表所示。\n\n<table border='1'><thead><tr><th>分区始址</th><th>分区大小</th></tr></thead><tbody><tr><td>20K</td><td>40KB</td></tr><tr><td>500K</td><td>80KB</td></tr><tr><td>1000K</td><td>100KB</td></tr><tr><td>200K</td><td>200KB</td></tr></tbody></table>\n回收始址为60K、大小为140KB的分区后，系统中空闲分区的数量、空闲分区链第一个分区的始址和大小分别是()。",
      "type": "single-choice",
      "options": [
        "3，20K，380KB",
        "3，500K，80KB",
        "4，20K，180KB",
        "4，500K，80KB"
      ],
      "correct_answer": [
        "3，500K，80KB"
      ],
      "analysis": "回收始址为60K、大小为140KB的分区时，它与表中第一个分区和第四个分区合并，成为始址为20K、大小为380KB的分区，剩余3个空闲分区。在回收内存后，算法会对空闲分区链按分区大小由小到大进行排序，表中的第二个分区排第一，所以选择B。"
    },
    {
      "uniqueId": "MEM24",
      "content": "下列关于虚拟存储器的论述中，正确的是()",
      "type": "single-choice",
      "options": [
        "作业在运行前，必须全部装入内存，且在运行过程中也一直驻留内存",
        "作业在运行前，不必全部装入内存，且在运行过程中也不必一直驻留内存",
        "作业在运行前，不必全部装入内存，但在运行过程中必须一直驻留内存",
        "作业在运行前，必须全部装入内存，但在运行过程中不必一直驻留内存"
      ],
      "correct_answer": [
        "作业在运行前，不必全部装入内存，且在运行过程中也不必一直驻留内存"
      ],
      "analysis": "在非虚拟存储器中，作业必须全部装入内存且在运行过程中也一直驻留内存;在虚拟存储器中，作业不必全部装入内存且在运行过程中也不用一直驻留内存，这是虚拟存储器和非虚拟存储器的主要区别之一。"
    },
    {
      "uniqueId": "MEM25",
      "content": "某个操作系统对内存的管理采用页式存储管理方法，所划分的页面大小()。",
      "type": "single-choice",
      "options": [
        "要根据内存大小确定",
        "必须相同",
        "要根据CPU的地址结构确定",
        "要依据外存和内存的大小确定"
      ],
      "correct_answer": [
        "必须相同"
      ],
      "analysis": "页式管理中很重要的一个问题是页面大小如何确定。确定页面大小有很多因素，如进程的平均大小、页表占用的长度等。而一旦确定，所有的页面就是等长的(一般取2的整数幂倍)，以便易于系统管理。"
    },
    {
      "uniqueId": "MEM26",
      "content": "引入段式存储管理方式，主要是为了更好地满足用户的一系列要求。下面选项中不属于这一系列要求的是()。",
      "type": "single-choice",
      "options": [
        "方便操作",
        "方便编程",
        "共享和保护",
        "动态链接和增长"
      ],
      "correct_answer": [
        "方便操作"
      ],
      "analysis": "引入段式存储管理方式，主要是为了满足用户的下列要求:方便编程、分段共享、分段保护、动态链接和动态增长。"
    },
    {
      "uniqueId": "MEM27",
      "content": "存储管理的目的是()",
      "type": "single-choice",
      "options": [
        "方便用户",
        "提高内存利用率",
        "方便用户和提高内存利用率",
        "增加内存实际容量"
      ],
      "correct_answer": [
        "方便用户和提高内存利用率"
      ],
      "analysis": "存储管理的目的有两个:一个是方便用户，二是提高内存利用率。"
    },
    {
      "uniqueId": "MEM28",
      "content": "对主存储器的访问，()。",
      "type": "single-choice",
      "options": [
        "以块(即页)或段为单位",
        "以字节或字为单位",
        "随存储器的管理方案不同而异",
        "以用户的逻辑记录为单位"
      ],
      "correct_answer": [
        "以字节或字为单位"
      ],
      "analysis": "这里是指主存的访问，不是主存的分配。对主存的访问是以字节或字为单位的。例如，在页式管理中，不仅要知道块号，而且要知道页内偏移。"
    },
    {
      "uniqueId": "MEM29",
      "content": "把作业空间中使用的逻辑地址变为内存中的物理地址称为()。",
      "type": "single-choice",
      "options": [
        "加载",
        "重定位",
        "物理化",
        "逻辑化"
      ],
      "correct_answer": [
        "重定位"
      ],
      "analysis": "在一般情况下，一个作业在装入时分配到的内存空间和它的地址空间是不一致的，因此，作业在CPU上运行时，其所要访问的指令、数据的物理地址和逻辑地址是不同的。显然，若在作业装入或执行时，不对有关的地址部分加以相应的修改，则会导致错误的结果。这种将作业的逻辑地址变为物理地址的过程称为地址重定位。"
    },
    {
      "uniqueId": "MEM30",
      "content": "以下存储管理方式中，不适合多道程序设计系统的是()。",
      "type": "single-choice",
      "options": [
        "单用户连续分配",
        "固定式分区分配",
        "可变式分区分配",
        "分页式存储管理方式"
      ],
      "correct_answer": [
        "单用户连续分配"
      ],
      "analysis": "单用户连续分配管理方式只适用于单用户、单任务的操作系统，不适用于多道程序设计。"
    },
    {
      "uniqueId": "MEM31",
      "content": "在分页存储管理中，主存的分配()。",
      "type": "single-choice",
      "options": [
        "以物理块为单位进行",
        "以作业的大小进行",
        "以物理段进行",
        "以逻辑记录大小进行"
      ],
      "correct_answer": [
        "以物理块为单位进行"
      ],
      "analysis": "在分页存储管理中，逻辑地址分配是按页为单位进行分配的，而主存的分配即物理地址分配是以内存块为单位分配的。"
    },
    {
      "uniqueId": "MEM32",
      "content": "在段页式分配中，CPU每次从内存中取一次数据需要()次访问内存。",
      "type": "single-choice",
      "options": [
        "1",
        "3",
        "2",
        "4"
      ],
      "correct_answer": [
        "3"
      ],
      "analysis": "在段页式分配中，取一次数据时先从内存查找段表，再访问内存查找相应的页表，最后拼成物理地址后访问内存，共需要3次内存访问。"
    },
    {
      "uniqueId": "MEM33",
      "content": "()存储管理方式提供一维地址结构。",
      "type": "single-choice",
      "options": [
        "分段",
        "分页",
        "分段和段页式",
        "以上答案都不正确"
      ],
      "correct_answer": [
        "分页"
      ],
      "analysis": "分页存储管理中，作业地址空间是一维的，即单一的线性地址空间，程序员只需要一个记忆符来表示地址。在分段存储分配管理中，段之间是独立的，而且段长不定长，而页长是固定的，因此作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。简言之，确定一个地址需要几个参数，作业地址空间就是几维的。"
    },
    {
      "uniqueId": "MEM34",
      "content": "操作系统采用分页存储管理方式，要求()。",
      "type": "single-choice",
      "options": [
        "每个进程拥有一张页表，且进程的页表驻留在内存中",
        "每个进程拥有一张页表，但只有执行进程的页表驻留在内存中",
        "所有进程共享一张页表，以节约有限的内存空间，但页表必须驻留在内存中",
        "所有进程共享一张页表，只有页表中当前使用的页面必须驻留在内存中，以最大限度地节省有限的内存空间"
      ],
      "correct_answer": [
        "每个进程拥有一张页表，且进程的页表驻留在内存中"
      ],
      "analysis": "分页存储管理中，作业地址空间是一维的，即单一的线性地址空间，程序员只需要一个记忆符来表示地址。在分段存储分配管理中，段之间是独立的，而且段长不定长，而页长是固定的，因此作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。简言之，确定一个地址需要几个参数，作业地址空间就是几维的。"
    },
    {
      "uniqueId": "MEM35",
      "content": "一个分段存储管理系统中，地址长度为32位，其中段号占8位，则最大段长是()。",
      "type": "single-choice",
      "options": [
        "2<sup>8</sup>B",
        "2<sup>16</sup>B",
        "2<sup>24</sup>B",
        "2<sup>32</sup>B"
      ],
      "correct_answer": [
        "2<sup>24</sup>B"
      ],
      "analysis": "分段存储管理的逻辑地址分为段号和位移量两部分，段内位移的最大值就是最大段长。地址长度为32位，段号占8位，因此位移量占32-8=24位，因此最大段长为2<sup>24</sup>B。"
    },
    {
      "uniqueId": "MEM36",
      "content": "在分段存储管理方式中，()。",
      "type": "single-choice",
      "options": [
        "以段为单位，每段是一个连续存储区",
        "段与段之间必定不连续",
        "段与段之间必定连续",
        "每段是等长的"
      ],
      "correct_answer": [
        "以段为单位，每段是一个连续存储区"
      ],
      "analysis": "在分段存储管理方式中，以段为单位进行分配，每段是一个连续存储区，每段不一定等长，段与段之间可连续，也可不连续。"
    },
    {
      "uniqueId": "MEM37",
      "content": "段页式存储管理汲取了页式管理和段式管理的长处，其实现原理结合了页式和段式管理的基本思想，即()。",
      "type": "single-choice",
      "options": [
        "用分段方法来分配和管理物理存储空间，用分页方法来管理用户地址空间",
        "用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间",
        "用分段方法来分配和管理主存空间，用分页方法来管理辅存空间",
        "用分段方法来分配和管理辅存空间，用分页方法来管理主存空间"
      ],
      "correct_answer": [
        "用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间"
      ],
      "analysis": "段页式存储管理兼有页式管理和段式管理的优点，采用分段方法来分配和管理用户地址空间，采用分页方法来管理物理存储空间。但它的开销要比段式和页式管理的开销大。"
    },
    {
      "uniqueId": "MEM38",
      "content": "某计算机采用二级页表的分页存储管理方式，按字节编址，页大小为2<sup>10</sup>B，页表项大小为2B，逻辑地址结构为\n\n<table border='1'><thead><tr><th>页目录号</th><th>页号</th><th>页内偏移量</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table>\n逻辑地址空间大小为2<sup>16</sup>页，则表示整个逻辑地址空间的页目录表中包含表项的个数至少是()。",
      "type": "single-choice",
      "options": [
        "64",
        "128",
        "256",
        "512"
      ],
      "correct_answer": [
        "128"
      ],
      "analysis": "页大小为2<sup>10</sup>B，页表项大小为2B，因此一页可以存放2<sup>9</sup>个页表项，逻辑地址空间大小为2<sup>16</sup>页，即共需2<sup>16</sup>个页表项，因此需要2<sup>16</sup>/2<sup>9</sup>=2<sup>7</sup>=128个页面保存页表项，即页目录表中包含表项的个数至少是128。"
    },
    {
      "uniqueId": "MEM39",
      "content": "在下列动态分区分配算法中，最容易产生内存碎片的是()。",
      "type": "single-choice",
      "options": [
        "首次适应算法",
        "最坏适应算法",
        "最佳适应算法",
        "循环首次适应算法"
      ],
      "correct_answer": [
        "最佳适应算法"
      ],
      "analysis": "最佳适应算法总是匹配与当前大小要求最接近的空闲分区，但是大多数情况下空闲分区的大小不可能完全和当前要求的大小相等，几乎每次分配内存都会产生很小的难以利用的内存块，所以最佳适应算法最容易产生最多的内存碎片，C正确。"
    },
    {
      "uniqueId": "MEM40",
      "content": "某段表的内容见下表，一逻辑地址为（2，154），它对应的物理地址为（）。\n\n<table border='1'><thead><tr><th>段号</th><th>段首地址</th><th>段长度</th></tr></thead><tbody><tr><td>0</td><td>120K</td><td>40K</td></tr><tr><td>1</td><td>760K</td><td>30K</td></tr><tr><td>2</td><td>480K</td><td>20K</td></tr><tr><td>3</td><td>370K</td><td>20K</td></tr></tbody></table>",
      "type": "single-choice",
      "options": [
        "120K+2",
        "480K+154",
        "30K+154",
        "480K+2"
      ],
      "correct_answer": [
        "480K+154"
      ],
      "analysis": "段号为2，其对应的首地址为480K，段长度为20K，大于154，所以逻辑地址（2，154）对应的物理地址为480K+154。"
    }
  ],
  "sets": [
    {
      "id": "memory_set",
      "name": "操作系统存储-第四章-管理选择题",
      "description": "操作系统存储管理选择题",
      "questionIds": [
        "MEM01",
        "MEM02",
        "MEM03",
        "MEM04",
        "MEM05",
        "MEM06",
        "MEM07",
        "MEM08",
        "MEM09",
        "MEM10",
        "MEM11",
        "MEM12",
        "MEM13",
        "MEM14",
        "MEM15",
        "MEM16",
        "MEM17",
        "MEM18",
        "MEM19",
        "MEM20",
        "MEM21",
        "MEM22",
        "MEM23",
        "MEM24",
        "MEM25",
        "MEM26",
        "MEM27",
        "MEM28",
        "MEM29",
        "MEM30",
        "MEM31",
        "MEM32",
        "MEM33",
        "MEM34",
        "MEM35",
        "MEM36",
        "MEM37",
        "MEM38",
        "MEM39",
        "MEM40"
      ]
    }
  ]
}