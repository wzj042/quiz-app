{
  "questions": [
    {
      "uniqueId": "A01PD01",
      "content": "“ 用高级语言书写的源程序都必须通过编译,产生目标代码后才能投入运行”这种说法。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目中的说法错误。并非所有高级语言书写的源程序都必须通过编译产生目标代码后才能运行。例如，一些解释型语言（如Python）在运行时直接解释执行源代码，无需编译成目标代码。因此，该说法忽略了解释型语言的运行机制。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01PD02",
      "content": "编译程序生成的目标程序都是可执行的程序。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目解析：题干中的‘编译程序生成的目标程序’指的是编译器将源代码转换成的机器码或汇编码。这些程序在特定环境下可以执行，但并非所有情况下都是可执行的，例如，如果目标环境不支持该程序或程序存在逻辑错误，则无法执行。因此，题干表述过于绝对，正确答案为‘错’。解题思路包括理解编译程序的作用和目标程序的可执行性条件。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01PD03",
      "content": "编译程序是对高级语言程序的解释执行。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目解析：题干中的说法错误。编译程序是将高级语言程序转换成机器语言的过程，而不是直接解释执行。解释执行通常是指解释器对高级语言程序逐行解释并执行。因此，正确答案为‘错’。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01PD04",
      "content": "编译程序与具体的机器有关,与具体的语言无关。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目解析：题干中的说法错误。编译程序确实与具体的机器有关，因为编译程序需要针对特定机器的指令集进行代码转换。同时，编译程序也通常与特定的编程语言有关，因为编译程序需要解析和转换特定语言的源代码。因此，编译程序既与机器有关，也与语言有关。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01PD05",
      "content": "编译前端主要由与源语言和目标机相关的那些部分组成。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目解析：编译前端主要涉及词法分析和语法分析，与源语言相关，而与目标机相关的部分属于编译后端。因此，题干说法错误。解题思路是理解编译前端的定义和范围，然后判断题干描述的正确性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01PD06",
      "content": "程序语言的语言处理程序是一种应用软件。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目解析：题干中提到程序语言的语言处理程序是一种应用软件，这是错误的。语言处理程序是系统软件的一部分，负责将源代码转换为机器代码。解题思路是理解语言处理程序的性质，区分系统软件和应用软件的区别。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01PD07",
      "content": "分析作为单独的一遍来处理较好。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目要求判断‘分析作为单独的一遍来处理较好’这一说法的正确性。术语‘分析’在此指对某一问题或现象进行深入研究和解释。解题思路是，分析是否应该单独处理取决于具体情况，因此题干中的说法过于绝对，故答案为‘错’。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01PD08",
      "content": "汇编器将高级语言程序翻译成汇编语言程序。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目解析：汇编器的作用是将汇编语言程序翻译成机器语言程序，而非高级语言程序。因此，题干描述错误，正确答案为‘错’。题目术语‘汇编器’指的是一种将汇编语言转换为机器语言的翻译工具。解题思路是理解汇编器的功能，并判断题干描述的正确性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01PD09",
      "content": "计算机高级语言翻译成低级语言只有解释一种方式。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目中提到计算机高级语言翻译成低级语言只有解释一种方式，这是不正确的。实际上，高级语言翻译成低级语言有两种方式：编译和解释。编译是将整个高级语言程序一次性翻译成机器语言，然后执行；而解释是逐行翻译并执行，不生成可执行文件。因此，正确答案是‘错’。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01PD10",
      "content": "甲机上的某编译程序在乙机上能直接使用的必要条件是甲机和乙机的操作系统功能完全相同。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "（搜题均为错，ai生成为正确，暂不确定）\n题干中提到的编译程序在不同机器上运行，其必要条件是操作系统功能完全相同。解析术语：编译程序，操作系统。解题思路：编译程序依赖于操作系统的功能，若两机操作系统功能相同，则编译程序可直接在乙机上使用。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01PD11",
      "content": "解释程序适用于COBOL和FORTRAN语言。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目解析：题干提到解释程序适用于COBOL和FORTRAN语言。解析：解释程序是一种逐行解释并执行源代码的程序，而COBOL和FORTRAN语言通常使用编译程序进行编译。因此，题干描述不准确，正确答案为‘错’。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01PD12",
      "content": "取编译程序前端改写其后端以生成不同机器上的目标代码，目前技术上还难以实现。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目解析：题干描述了编译程序前端改写后端生成不同机器上的目标代码的技术难题。解析：编译程序的前端主要负责词法分析和语法分析，而后端则负责代码生成和优化。目前技术上，通过前端改写后端生成不同机器上的目标代码是可行的，因此题干描述错误。解题思路：理解编译程序的前后端功能，判断题干描述的技术难题是否实际存在。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01PD13",
      "content": "许多编译程序在识别出语法单位后并不真正构造语法树。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：题干提到编译程序在识别语法单位后不构造语法树。解析：语法树是编译过程中用于表示代码结构的树形结构。正确答案‘对’表明编译程序在识别语法单位后可能跳过语法树的构造，可能采用其他方法处理语法结构。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01PD14",
      "content": "优化的任务在于对前端编译所产生的中间代码进行加工和变换，以其能产生运行结果更为准确的目标代码。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目解析：题干描述了前端编译过程中的优化任务，即对中间代码进行加工和变换以提高目标代码的运行准确性。然而，题干中的描述存在逻辑错误，因为优化的目的是为了生成更准确的目标代码，而不是仅仅加工和变换中间代码。因此，正确答案为'错'。解题思路包括理解题干中的术语（如前端编译、中间代码、优化），分析题干与选项的逻辑关系，并判断题干描述的正确性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01PD15",
      "content": "在编译过程中，既可以将几个不同的阶段合为一遍，也可以把一个阶段的工作分为若干遍。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：编译过程中，将不同阶段合并或分多遍执行是常见的优化手段。合并阶段可以减少编译时间，而分多遍执行可以提高编译效率。因此，题干描述正确。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01PD16",
      "content": "在编译中进行语法检查的目的是为了发现程序中所有错误。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "语法检查是编译过程中的一个阶段，其目的是发现程序中的语法错误，而非所有错误。错误分为语法错误和语义错误，语法错误指的是违反编程语言语法规则的错误，而语义错误则涉及逻辑或运行时错误。因此，题干中的说法不准确。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01PD17",
      "content": "在程序中标识符的出现仅为使用性的。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目解析：标识符在程序中不仅用于使用，还包括定义和声明。因此，题干中的说法不完整，正确答案为'错'。标识符的完整性要求其在程序中具有明确的定义和作用范围。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01PD18",
      "content": "支持程序设计人员进行程序计开发的工具，除了编译程序以外，还需要编辑程序、链接程序和调试程序等其他一些工具。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：题干描述了程序设计开发所需的工具，包括编译程序、编辑程序、链接程序和调试程序等。正确答案为'对'，因为除了编译程序外，确实还需要其他工具来支持程序设计开发。题目术语包括程序设计、开发工具、编译程序、编辑程序、链接程序和调试程序。解题思路是确认题干描述的工具是否全面，并判断其正确性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02pd01",
      "content": "一棵语法树表示了一个句型所有的不同推导过程，包括最右推导和最左推导。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：语法树是表示句型推导过程的工具，包括最右推导和最左推导。最右推导是从左到右，每次替换非终结符号为终结符号；最左推导则相反。题干正确描述了语法树的功能，因此答案为对。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02pd02",
      "content": "可能有两个不同的文法G1和G2，期中一个是二义的而另一个是无二义的，但是却有L(G1)＝L(G2)。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：题干描述了两个文法G1和G2，它们生成的语言L(G1)和L(G2)相同，但一个文法是二义的，另一个是无二义的。正确答案为'对'，因为存在这样的文法，即一个文法可以是二义的，而另一个文法可以是无二义的，但它们生成的语言相同。题目术语包括文法（形式语言的一种定义方式）、二义性（一个文法可能产生多个解析树）和无二义性（一个文法只能产生一个解析树）。解题思路是理解文法和二义性的概念，并确认存在这样的文法关系。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02pd03",
      "content": "变量既持有左值又持有右值，而常数和带有算符的表达式一般认为只持有右值。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：左值是指可以出现在赋值语句左侧的变量，具有内存地址；右值是指可以出现在赋值语句右侧的值，如常量或表达式。题干描述正确，变量可以同时具有左值和右值属性，而常数和带有算符的表达式通常只具有右值属性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02pd04",
      "content": "文法G: S→bA ，A→aA|a  定义的语言是所有以b开头的后跟至少一个a的字符串的集合。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：文法G定义了一个生成语言的过程，其中S是起始符号，bA表示字符串以b开头，A可以递归地以a开头。正确答案为'对'，因为该文法确实生成了所有以b开头后跟至少一个a的字符串集合。解题思路是理解文法规则，并验证其生成的字符串是否符合题目描述。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02pd05",
      "content": "设有文法G：S→S*S | S+S | (S) | a  该文法是二义的。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：文法G中的产生式存在多个解析路径，导致同一句子可以有多种不同的语法分析，因此该文法是二义的。二义性指的是文法中存在歧义，即同一个句子可以有多种不同的解释。解题思路是理解文法的产生式和二义性的定义，判断文法是否具有歧义。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02pd06",
      "content": "正则文法一定不是二义的。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "正则文法指的是用于描述字符串模式的一套规则，它通常用于字符串匹配和搜索。题目中的说法‘正则文法一定不是二义的’是错误的。因为正则文法可以设计成二义的，即同一个模式可以对应多种解释。解题思路是理解正则文法的定义，并判断其是否必然无二义性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02pd07",
      "content": "上下文无关文法可以产生语言：L={ a<sup>n</sup>b<sup>n</sup>c<sup>i</sup>| i>=1, n>=1 }。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "上下文无关文法（CFG）是一种形式文法，用于生成语言。题干描述的语言L由a和b的相同数量n次出现，后跟至少一次c组成。由于该语言符合CFG的定义，因此判断为正确。解题思路是理解上下文无关文法的定义，并验证题干中的语言是否符合该定义。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02pd08",
      "content": "不存在任何正规文法能产生语言：L={a<sup>n</sup>b<sup>n</sup> | n>=1}。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目术语：L={a<sup>n</sup>b<sup>n</sup> | n>=1} 表示一个正则语言，其中包含所有形如 'a^n b^n' 的字符串，n 为大于等于1的整数。题目断言不存在任何正规文法能产生这个语言。解析：正确答案为'对'，因为该语言是上下文无关语言，而正规文法只能产生正则语言，因此不存在正规文法能产生这个语言。解题思路：理解正规文法和上下文无关语言的定义，分析题目中的语言类型，得出结论。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02pd09",
      "content": "对于每一个左线性文法G1，都存在一个右线性文法G2，使得L(G1)=L(G2)。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：左线性文法和右线性文法是两种特定的上下文无关文法。题目断言对于任意的左线性文法G1，都存在一个对应的右线性文法G2，使得它们生成的语言相同。这是正确的，因为左线性文法可以转换为右线性文法而不改变其生成的语言。解题思路是理解两种文法的定义，并确认转换的有效性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02pd10",
      "content": "正规文法产生的语言都可以用上下文无关文法来描述。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：题干中的‘正规文法’指的是能够生成所有正规语言的文法，而‘上下文无关文法’是一种能够描述所有正规语言的文法。正确答案‘对’表明正规文法产生的语言确实可以用上下文无关文法来描述，即上下文无关文法是正规文法的超集。解题思路是理解正规文法和上下文无关文法的定义，并确认它们之间的关系。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02pd11",
      "content": "上下文无关文法比正规文法有更强的描述能力。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "上下文无关文法（CFG）是一种形式文法，可以描述更复杂的语言结构，而正规文法（NF）只能描述较为简单的语言。因此，题干中的说法正确。解析包括对上下文无关文法和正规文法的定义，以及它们在描述语言能力上的差异。解题思路是理解两种文法的定义和特点，然后判断题干陈述的正确性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02pd12",
      "content": "文法的二义性和语言的二义性在概念上是相同的，也就是说，对于某个语言，不可能存在两个以上的文法来描述它。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目解析：文法的二义性指的是一个文法可能产生多个解析树，而语言的二义性指的是一个句子可能有多重含义。题干错误地将两者等同，实际上，一个语言可以由多个文法描述，但每个文法描述的语言是唯一的。解题思路是理解文法和语言二义性的定义，并分析题干中的逻辑关系。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02pd13",
      "content": "二义性是可以判定的，也就是说，可以编这么一个程序，输入该文法后，该程序能确切地给出该文法是否二义的答案。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目讨论了文法二义性的可判定性。二义性是指一个文法可能产生多个等价的语法分析结果。题目中的说法是错误的，因为并非所有文法的二义性都可以通过程序确切判定。对于某些文法，可能存在算法复杂度过高或不可解的情况，使得二义性无法被程序准确判定。解题思路包括理解二义性的定义，以及判断算法是否能够解决所有文法的二义性问题。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02pd14",
      "content": "说明语句旨在定义名字的性质。编译程序把这些性质登记在符号表中，并检查程序中名字的引用和说明是否一致。实际上，许多说明语句并不能翻译成相应的目标代码。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：题干描述了编译程序在处理名字的性质时，将性质登记在符号表中，并检查引用和说明的一致性。许多说明语句不能直接翻译成目标代码。此描述符合编译原理中的基本概念，因此题目表述正确。解题思路是理解编译程序的工作原理，确认题干描述的准确性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02pd15",
      "content": "C语言是一个允许子程序嵌套定义的语言。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题干中提到C语言允许子程序嵌套定义，但实际上C语言不支持子程序嵌套定义。子程序嵌套定义通常指的是函数内部可以定义其他函数，而C语言不支持这种嵌套。因此，正确答案为'错'。题目术语'子程序嵌套定义'指的是函数内部定义其他函数的能力。解题思路是理解C语言的函数定义规则，判断题干描述是否符合这些规则。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03pd01",
      "content": "NFA M的非确定性表现在它有多个终态。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题干中提到NFA（非确定性有限自动机）的非确定性表现在它有多个终态。这是错误的。NFA的非确定性体现在其状态转换上，即对于给定的输入符号，它可以有多个可能的下一个状态，而不仅仅是因为有多个终态。因此，正确答案是‘错’。题目解析应包括对NFA非确定性的定义和解释，以及为何终态数量不是非确定性的表现。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03pd02",
      "content": "有穷自动机接受的语言是正则语言。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：正则语言是指可以用正则表达式描述的语言，有穷自动机能够识别所有正则语言。因此，题干中的说法是正确的。解题思路是理解正则语言和有穷自动机的定义，然后判断题干陈述是否符合这些定义。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03pd03",
      "content": "若r1和r2是Σ上的正规式，则r1|r2也是。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：正规式（Regular Expression）是描述字符串集合的一种方式。题干中提到r1和r2是Σ上的正规式，Σ是字符集合。r1|r2表示r1或r2匹配的情况，这是正规式的一个基本操作。由于正规式的闭包性质，r1|r2也是Σ上的正规式。因此，题目说法正确。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03pd04",
      "content": "设M是一个NFA，并且L(M)＝{x，y，z}，则M的状态数至少为4个。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目中提到NFA M的输出语言L(M)包含三个元素{x，y，z}，但并未说明这些元素是否互不相同。NFA的状态数取决于其能够识别的所有不同输入序列，而非输出语言的元素数量。因此，不能直接根据输出语言的元素数量确定NFA的状态数。正确答案为'错'，因为状态数至少为4个的说法没有充分依据。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03pd05",
      "content": "令Σ＝{a，b}，则Σ上所有以b为首的字符构成的正规集的正规式为b*(a|b)*。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目中的正规集正规式b*(a|b)*描述了所有以b开头的字符串，其中可以包含任意数量的a或b。然而，正规式中的(a|b)*表示字符串可以包含任意数量的a或b，包括没有a的情况，这与题干中描述的“所有以b为首的字符构成的正规集”不符，因为这意味着字符串可以完全由b组成。因此，题干描述的正规式不正确，正确答案为'错'。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03pd06",
      "content": "对任何一个NFA M，都存在一个DFA M'，使得L(M')=L(M)。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：题干中的NFA（非确定有限自动机）和DFA（确定有限自动机）是两种不同的有限自动机。题目表述了NFA与DFA之间的一个重要性质，即对于任意一个NFA，都存在一个等价的DFA。解析中应解释NFA和DFA的基本概念，并说明如何从NFA构造出DFA。解题思路描述为：首先理解NFA和DFA的定义，然后解释如何通过状态转换和状态合并的方法将NFA转换为DFA。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03pd07",
      "content": "对一个右线性文法G，必存在一个左线性文法G'，使得L(G)=L(G')，反之亦然。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：右线性文法G和左线性文法G'的等价性。右线性文法G的每个产生式形式为A→αB或A→α，其中α为符号串。左线性文法G'的每个产生式形式为A→αB或A→α。由于两种文法生成语言的规则相同，因此存在一个左线性文法G'，使得L(G)=L(G')，反之亦然。故答案为对。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03pd08",
      "content": "对任意一个右线性文法G，都存在一个NFA M，满足L(G)=L(M)。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：右线性文法G生成语言L(G)，存在一个非确定有限自动机NFA M，使得L(G)=L(M)。题目术语解释：右线性文法是指文法中的产生式规则只能向右推导。解题思路：根据文法理论，任何右线性文法都可以转换为等价的非确定有限自动机。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03pd09",
      "content": "对任意一个右线性文法G，都存在一个DFA M，满足L(G)=L(M)。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：右线性文法G的语法结构允许从左到右读取，而DFA（确定性有限自动机）M能够识别与G相同的语言L(G)。由于右线性文法生成的语言可以被DFA识别，因此对于任意一个右线性文法G，确实存在一个DFA M，使得L(G)=L(M)。解题思路是理解右线性文法和DFA的定义，以及它们之间的关系。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03pd10",
      "content": "对任何正则表达式r，都存在一个NFA M，满足L(M)=L(r)。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：题干中的正则表达式r指的是一种描述字符串集合的模式，NFA M是确定有限自动机，L(M)表示M识别的字符串集合。题目断言对于任何正则表达式，都存在一个与之等价的NFA。解析：正确。因为正则表达式可以转换为NFA，且两者识别的字符串集合相同。解题思路：理解正则表达式和NFA的基本概念，了解它们之间的转换关系。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03pd11",
      "content": "对任何正则表达式r，都存在一个DFA M，满足L(M)=L(r)。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：题干中的正则表达式r指的是一个定义字符串集合的模式，DFA M是一个确定有限自动机，L(M)表示由DFA M识别的语言。题目断言对于任意正则表达式r，总能找到一个DFA M，使得该DFA识别的语言与r定义的集合相同。这是正确的，因为正则表达式可以转换为等价的DFA，因此解析为‘对’。解题思路是理解正则表达式与DFA之间的关系，并确认这种转换的存在性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03pd12",
      "content": "一张转换图只包含有限个状态，其中有一个被认为是初态，最多只有一个终态。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目描述的是转换图的基本特性，其中转换图是一种有向图，用于表示状态转换。题干中提到转换图只包含有限个状态，并且有一个初态和最多一个终态。然而，转换图中的状态可以是初态和终态的任意组合，因此题干描述不准确。解析中应解释转换图的概念，并指出题干描述的错误在于对初态和终态的限定。解题思路是理解转换图的基本定义，然后分析题干描述与定义的符合程度。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03pd13",
      "content": "一个正规式只能对应一个有限状态自动机；",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "正规式和有限状态自动机之间存在多对一的关系。一个正规式可以对应多个不同的有限状态自动机，因为不同的自动机可能以不同的方式实现相同的语言。因此，题干中的说法是错误的。解题思路包括理解正规式和有限状态自动机的定义，以及它们之间的关系。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03pd14",
      "content": "在词法分析的状态转换图中，有些结点是带星号的，这些结点肯定是终态结点。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：词法分析的状态转换图中的带星号结点表示终态，意味着到达这些结点后，词法分析器将停止进一步的状态转换。因此，正确答案是‘对’。题目术语‘终态’指的是在状态转换图中，到达该状态后不再进行状态转换的状态。解题思路是理解终态的定义，并确认带星号结点是否符合这一特性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03pd15",
      "content": "适当设置扫描缓冲区的大小（比如容纳256个字符）可以保证单词符号不会被它的边界所打断。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目中提到的扫描缓冲区大小设置是为了避免单词符号被边界打断。解析：正确答案为'错'，因为设置缓冲区大小并不能直接保证单词符号不被打断，还需要考虑单词符号的识别和边界处理机制。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A04pd01",
      "content": "LL(k)文法都不是二义性的。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "LL(k)文法指的是一类上下文无关文法，其中k是 lookahead 的长度。这类文法通过限制预测函数来避免二义性。题目断言LL(k)文法都不是二义性的，这是正确的。解析：LL(k)文法的预测函数是确定的，因此不会产生歧义。解题思路：理解LL(k)文法的定义和特性，确认预测函数的确定性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A04pd02",
      "content": "存在一种算法，能判定任何上下文无关文法是否是LL(1)的。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目考察了上下文无关文法与LL(1)文法的关系。LL(1)文法是一种上下文无关文法，具有确定性。题干所述算法能判定任何上下文无关文法是否是LL(1)的，表明存在这样的算法，因此题干说法正确。解题思路是理解LL(1)文法的定义，并确认存在判定算法。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A04pd03",
      "content": "一个文法是含有左递归的，如果存在非终结符P，使得P⇒*α。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目解析：文法中的左递归是指存在非终结符P，使得P可以推导出自身，即P⇒*α。题目中的描述错误，因为左递归的存在意味着P可以无限推导自身，而不是推导出一个特定的字符串。因此，正确答案为'错'。解题思路是理解左递归的定义，并判断题干描述是否符合该定义。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A04pd04",
      "content": "提取公共左因子的副产品是引进了大量的非终结符和ε产生式。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：公共左因子是指在多个产生式中出现的相同的前缀。提取公共左因子时，可能会引入非终结符和ε产生式，这会使得文法更加复杂。因此，题干描述正确。解题思路是理解公共左因子的概念，分析提取过程可能带来的影响。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A04pd05",
      "content": "把一个文法改造成任何非终结符的所有后选终结首符集两两不相交的办法是消除左递归。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目中提到的文法改造是指将文法中的左递归消除，以避免产生无限递归。然而，消除左递归并不能保证任何非终结符的所有后选终结首符集两两不相交。题目解析：左递归消除是文法改造的一种方法，但不是唯一保证后选终结首符集两两不相交的方法，因此题目说法错误。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A04pd06",
      "content": "若X∈VT，则FIRST(X)={ X }。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：题干中提到若X属于非终结符集VT，则其首符集FIRST(X)只包含X本身。这是正确的，因为非终结符X自身不会产生任何终结符，所以其首符集只包含自身。解题思路是理解非终结符和首符集的概念，并应用这些概念来验证题干陈述的正确性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A04pd07",
      "content": "一个文法的预测分析表含有多重定义入口，说明该文法是LL(1)的。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目解析：LL(1)文法要求预测分析表中每个符号的入口唯一。题干中提到预测分析表含有多重定义入口，这与LL(1)文法的定义相矛盾，因此该文法不是LL(1)的。解题思路是理解LL(1)文法的定义，分析预测分析表的入口是否唯一。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A04pd08",
      "content": "自上而下分析及自下而上分析中的“下”是指被分析的源程序串。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：题干中的“下”指的是在自上而下和自下而上分析中，被分析的源程序串。自上而下分析从整体到局部，而自下而上分析从局部到整体。正确答案为‘对’，因为题干中的描述符合这两种分析方法的定义。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05pd01",
      "content": "一个二义性文法可以是SLR文法或LALR文法。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目解析：二义性文法指的是存在多个解析路径的文法，而SLR文法和LALR文法是解析算法，用于确定文法的解析表。SLR和LALR文法都是用来处理无二义性文法的，因此题干中的说法是错误的。解题思路是理解二义性文法与SLR、LALR文法之间的关系，判断题干描述的正确性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05pd02",
      "content": "LL(1)文法不能用LR（1）分析器来分析。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "LL(1)文法是指一种上下文无关文法，其推导过程遵循从左到右的顺序，并且每个推导步骤只能有一个非终结符的选择。LR（1）分析器是一种自底向上的分析器，可以处理LL(1)文法。因此，题干中的说法是错误的。解析包括对LL(1)文法和LR（1）分析器的定义，以及它们之间的关系。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05pd03",
      "content": "LR分析器在自左至右扫描输入串时就能发现其中的任何错误，并能准确地指出出错地点。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：LR分析器是一种自左至右扫描输入串的语法分析器，能够在扫描过程中发现错误并指出错误位置。此题中，题干描述符合LR分析器的特性，因此答案为'对'。题目术语包括LR分析器、自左至右扫描、错误发现和错误位置。解题思路是理解LR分析器的工作原理，并判断题干描述是否符合该原理。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05pd04",
      "content": "在归约过程的任一时刻，一个上下文无关文法的任何句型的直接短语一般都不是唯一的。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：上下文无关文法中，句型的直接短语在归约过程中可能不是唯一的，因为文法规则允许有多种产生式可以应用于句型。解题思路是理解上下文无关文法和归约过程的基本概念，然后分析句型在归约过程中可能出现的多种直接短语情况。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05pd05",
      "content": "算符优先分析法不是一种规范规约法。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：算符优先分析法是一种语法分析方法，它通过分析算符的优先级来确定表达式的结构。规范规约法是一种基于文法规则的解析方法。题目指出算符优先分析法不是规范规约法，这是正确的。解题思路是理解两种方法的定义，然后判断题目陈述的正确性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05pd06",
      "content": "存在有左递归规则的文法是LL(1)的。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目中的文法指的是形式语言中的语法规则，LL(1)是自顶向下解析算法的一种。左递归规则指文法中存在形如A -> Aα的规则。题目表述为存在左递归规则的文法是LL(1)的，这是错误的。因为LL(1)文法要求没有左递归，否则无法正确预测下一个输入符号。解题思路是理解LL(1)文法的定义，并识别左递归规则与LL(1)文法的不兼容性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05pd07",
      "content": "任何算符优先文法的句型中不会有两个相邻的非终结符号。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：算符优先文法是一种上下文无关文法，其中每个产生式都包含一个算符。题目中的说法是正确的，因为在算符优先文法中，每个产生式都确保了非终结符号之间至少有一个终结符号或算符分隔，从而不会有两个相邻的非终结符号。解题思路是理解算符优先文法的定义，并分析题目中的说法是否符合该定义。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05pd08",
      "content": "算符优先文法中任何两个相邻的终结符号之间至少满足三种关系(＜• ，•＞，＝• )之一。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目解析：算符优先文法中，相邻的终结符号之间至少满足三种关系之一，包括小于、大于和等于。正确答案为'错'，因为并非所有相邻的终结符号都满足这三种关系。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05pd09",
      "content": "任何LL(1)文法都是无二义性的。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：LL(1)文法是一种上下文无关文法，其中L表示从左到右扫描，1表示最左推导。由于LL(1)文法在解析过程中能够确定下一个输入符号，因此不会产生二义性。题目中的说法正确，任何LL(1)文法都是无二义性的。解题思路是理解LL(1)文法的定义和特性，然后判断题干陈述的正确性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05pd10",
      "content": "每一个SLR(1)文法也都是LR(1)文法。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：SLR(1)文法是指能够通过SLR(1)解析器的文法，而LR(1)文法是指能够通过LR(1)解析器的文法。由于SLR(1)解析器是LR(1)解析器的子集，因此每一个SLR(1)文法都能够通过LR(1)解析器解析，即每一个SLR(1)文法也都是LR(1)文法。解题思路是理解SLR(1)和LR(1)文法的定义，以及它们之间的关系。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05pd11",
      "content": "存在一种算法，能判定任何上下文无关文法是否是LL(1)的。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目涉及上下文无关文法和LL(1)文法判定。上下文无关文法是一种形式语言，LL(1)文法是其中一种特定类型，具有确定性。题目询问是否存在一种算法能判定任何上下文无关文法是否是LL(1)的。正确答案为'对'，因为确实存在这样的算法，称为LL(1)分析表构造算法，它能够确定一个文法是否是LL(1)的。解题思路是使用该算法对给定的文法进行分析，根据分析结果判断文法是否满足LL(1)的条件。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05pd12",
      "content": "任何一个LL(1)文法都是一个LR(1)文法，反之亦然。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目解析：LL(1)文法和LR(1)文法是两种不同的上下文无关文法。LL(1)文法要求左递归和右递归都不可存在，并且预测函数简单；LR(1)文法则允许存在左递归，但需要更复杂的预测分析。因此，并非所有LL(1)文法都是LR(1)文法，反之亦然。故题目说法错误。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05pd13",
      "content": "LR(1)分析中括号中的1是指，在选用产生式A→α进行分析，看当前读入符号是否在FIRST(α)中。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "“1” 只是指 LR 分析器在构造分析表（项目集）时，为每个项目保存 1 个前瞻符号，而并不是单纯看 FIRST(α)”。题干给出的说法并不准确",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05pd14",
      "content": "若某一个句型中出现了某一产生式的右部，则此右部不一定是该句型的句柄。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "句柄是指句型中不含有任何产生式的右部的符号串。题干指出句型中出现的产生式右部不一定是句柄，这是正确的，因为句柄必须不包含任何产生式的右部。因此，题目表述正确，答案为‘错’。解题思路是理解句柄的定义，然后分析题干中的条件是否符合句柄的定义。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05pd15",
      "content": "算符优先关系表不一定存在对应的优先函数。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：算符优先关系表是用于描述算符之间优先级的表格，但并不总是能直接转换成优先函数。优先函数用于在解析表达式中决定算符的执行顺序。由于表达式的复杂性，某些情况下优先关系表可能无法直接映射到有效的优先函数。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05pd16",
      "content": "简单优先文法允许任意两个产生式具有相同右部。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目解析：简单优先文法不允许任意两个产生式具有相同右部。产生式右部相同会导致歧义，违反了简单优先文法的定义。解题思路是理解简单优先文法的定义，分析产生式右部相同可能带来的问题，从而得出正确答案。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05pd17",
      "content": "一个句型的句柄一定是文法某产生式的右部。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：句柄是指句型中可以扩展的最小单位，产生式是文法规则的一种表示形式。题目表述句柄一定是文法某产生式的右部，这是正确的。因为句柄是句型中可以扩展的部分，而产生式的右部是文法规则中可以扩展的部分，所以句柄必然是产生式的右部。解题思路是理解句柄和产生式的定义，然后根据定义判断题干陈述的正确性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05pd18",
      "content": "若一个句型中出现了某产生式的右部，则此右部一定是该句型的句柄。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "句柄是指句型中不含有任何产生式的右部符号的符号串。题目中的说法错误，因为句柄的定义与产生式的右部无关，即使句型中出现了某产生式的右部，该右部也不一定是句柄。解题思路是理解句柄的定义，并判断题目陈述是否符合该定义。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05pd19",
      "content": "根据项目的定义，可给出文法中所有产生式的项目，而每个项目都为识别活前缀的DFA的一个状态。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "项目（Item）是文法中的一种关键概念。每个项目表示文法产生式的一种特定形式，包含一个点号，用于表示当前分析的进度，在符号的最左到最右意味着分析未开始到已完成。\n\n项目的集合可以描述识别活前缀的 DFA（确定性有限自动机）的状态。DFA 的每个状态与项目集一一对应，通过项目的扩展（闭包）和转移构造整个 DFA。\n\n因此，根据项目定义，文法中所有产生式的项目确实构成识别活前缀的 DFA 的状态。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06pd01",
      "content": "归约和规范推导是互逆的两个过程。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：归约是将复杂问题分解为简单问题的过程，而规范推导是将简单问题的解组合成复杂问题的解。这两个过程是互逆的，即归约的逆过程是规范推导，反之亦然。因此，题目中的说法是正确的。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06pd02",
      "content": "规范归约和规范推导是互逆的两个过程。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "规范归约和规范推导并非互逆过程。规范归约是将语法分析树转换成中间代码的过程，而规范推导是从中间代码生成目标代码的过程。这两个过程在语法和语义上存在差异，因此它们不是完全可逆的。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06pd03",
      "content": "简单优先文法允许任意两个产生式具有相同右部。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目解析：简单优先文法不允许任意两个产生式具有相同右部。产生式右部相同会导致歧义，违反了简单优先文法的定义。解题思路是理解简单优先文法的定义，分析产生式右部相同可能带来的问题，从而得出正确答案。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06pd04",
      "content": "任何算符优先文法的句型中不会有两个相邻的非终结符号。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：算符优先文法是一种上下文无关文法，其中每个产生式都包含一个算符。题目中的术语'非终结符号'指的是文法中的变量。解析：由于算符优先文法的定义，每个产生式中的算符都位于非终结符号之间，因此不会出现两个相邻的非终结符号。解题思路：理解算符优先文法的定义，分析产生式结构，得出结论。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06pd05",
      "content": "若一个句型中出现了某产生式的右部，则此右部一定是该句型的句柄。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "句柄是指句型中不含有任何产生式的右部符号的最右端符号序列。题干中的说法错误，因为句柄的定义与题干描述不符。解题思路是理解句柄的定义，然后判断题干描述是否符合该定义。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06pd06",
      "content": "算符优先分析法不是一种规范规约法。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：算符优先分析法是一种语法分析方法，它通过分析算符的优先级来确定表达式的结构。规范规约法是一种基于文法规则的解析方法。题目指出算符优先分析法不是规范规约法，这是正确的。解题思路是理解两种方法的定义，然后判断题目陈述的正确性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06pd07",
      "content": "算符优先关系表不一定存在对应的优先函数。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：算符优先关系表是描述算符之间优先级的一种方法，但并不总是能直接转换为优先函数。解析时需理解算符优先关系表和优先函数的概念，并分析它们之间的关系。正确答案为'对'，表明算符优先关系表不一定能直接实现为优先函数。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06pd08",
      "content": "算符优先文法中任何两个相邻的终结符号之间至少满足三种关系(＜• ，•＞，＝• )之一。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "题目解析：算符优先文法中，相邻的终结符号之间至少满足三种关系之一，但正确答案为'错'。解析：算符优先文法中，相邻的终结符号之间应满足两种关系（＜• ，•＞，＝•），而非三种。解题思路为理解算符优先文法的定义，并对比选项与定义的差异。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06pd09",
      "content": "一个句型的句柄一定是文法某产生式的右部。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：句柄是指句型中可以扩展的最小单位，产生式是文法规则的一种表示形式。题目指出句柄一定是文法某产生式的右部，这是正确的。因为句柄是句型中可以扩展的部分，而文法规则通过产生式定义了如何扩展句型，所以句柄必然是某个产生式的右部。解题思路是理解句柄和产生式的定义，并确认句柄与产生式的关系。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06pd10",
      "content": "一个算符优先文法可能不存在算符优先函数与之对应。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：算符优先文法是指文法中运算符的优先级是固定的。题目指出算符优先文法可能不存在算符优先函数与之对应，意味着某些文法无法通过算符优先函数来解析。这表明并非所有算符优先文法都能被算符优先解析算法正确解析，因此该说法是正确的。解题思路是理解算符优先文法和算符优先函数的概念，并判断题目陈述的逻辑正确性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06pd11",
      "content": "语法分析时必须先消除文法中的左递归。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题左递归是文法中的一种现象，指产生式右部以非终结符号开始，且该非终结符号出现在产生式右部的最前面。\\ 在语法分析中，左递归的存在可能导致递归下降分析器陷入无限递归。因此，为了构造递归下降分析器或者其他基于自顶向下的分析方法（如 LL 分析器），必须先消除文法中的左递归。(但是，如果采用的是自底向上的分析器（如 LR 分析器），则不要求必须消除左递归，因为自底向上的方法对左递归没有限制。)",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06pd12",
      "content": "在编译中进行语法检查的目的是为了发现程序中所有错误。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "语法检查是编译过程中的一个步骤，其目的是发现程序中的语法错误，而非所有错误。错误分为语法错误和语义错误，语法错误指的是违反语言规则的结构错误，而语义错误可能涉及逻辑、类型不匹配等问题。因此，题干中的说法不准确。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06pd13",
      "content": "在归约过程的任一时刻，一个上下文无关文法的任何句型的直接短语一般都不是唯一的。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：上下文无关文法中，句型的直接短语在归约过程中可能不是唯一的，因为文法规则允许有多种产生式可以应用于句型。解题思路是理解上下文无关文法和归约过程的基本概念，然后分析句型在归约过程中可能出现的多种直接短语情况。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06pd14",
      "content": "自底而上语法分析方法的主要问题是候选式的选择。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "自底而上语法分析方法是一种从句子成分开始逐步构建整个句子的语法分析方法。题目指出其主要问题是候选式的选择，这是不准确的。实际上，自底而上方法的主要问题是可能产生过多的候选式，导致难以确定正确的句子结构。因此，正确答案为'错'。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06pd15",
      "content": "自上而下分析及自下而上分析中的“下”是指被分析的源程序串。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "题目解析：题干中的“下”指的是在自上而下和自下而上分析中，被分析的源程序串。自上而下分析从整体到部分，而自下而上分析从部分到整体。正确答案为‘对’，因为‘下’确实是指被分析的源程序串。解题思路是理解分析方法的定义，并识别题干中的术语所指代的内容。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06pd16",
      "content": "解释程序是按照目标程序的解释执行。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "错"
      ],
      "analysis": "（自其余题库中抽取）解释程序一般是对源程序（或中间形式）逐条解释运行。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06pd17",
      "content": "编译程序是对高级语言程序翻译成机器语言。",
      "type": "single-choice",
      "options": [
        "对",
        "错"
      ],
      "correct_answer": [
        "对"
      ],
      "analysis": "（自其余题库中抽取）编译器的核心功能就是将高级语言翻译为相应机器码。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ01",
      "content": "(  )是两类程序语言处理程序。",
      "type": "single-choice",
      "options": [
        "高级语言程序和低级语言程序",
        "解释程序和编译程序",
        "编译程序和操作系统",
        "系统程序和应用程序"
      ],
      "correct_answer": [
        "解释程序和编译程序"
      ],
      "analysis": "题目解析：题干中提到的两类程序语言处理程序指的是解释程序和编译程序。解释程序逐行解释执行源代码，而编译程序将源代码一次性转换成机器代码。选项中，只有'解释程序和编译程序'准确描述了这两种处理程序。解题思路是识别题目中的术语，并排除与题意不符的选项。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ02",
      "content": "(  )是一种典型的解释型语言。",
      "type": "single-choice",
      "options": [
        "BASIC",
        "C",
        "FORTRAN",
        "PASCAL"
      ],
      "correct_answer": [
        "BASIC"
      ],
      "analysis": "题目解析：题干中提到的解释型语言指的是在程序运行时逐行解释执行的语言。BASIC（Beginner's All-purpose Symbolic Instruction Code）是一种典型的解释型语言，它易于学习和使用。其他选项如C、FORTRAN和PASCAL都是编译型语言，需要先编译成机器码再执行。解题思路是识别解释型语言的特点，并从选项中选出符合这一特点的语言。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ03",
      "content": "把汇编语言程序翻译成机器可执行的目标程序的工作是由(  )完成的。",
      "type": "single-choice",
      "options": [
        "编译器",
        "汇编器",
        "解释器",
        "预处理器"
      ],
      "correct_answer": [
        "汇编器"
      ],
      "analysis": "题目解析：汇编语言程序需要通过汇编器将其翻译成机器可执行的目标程序。编译器通常用于将高级语言程序转换为机器语言，而解释器则逐行解释执行。预处理器用于处理源代码中的预处理指令。因此，正确答案是汇编器，它负责汇编语言到机器语言的转换。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ04",
      "content": "编写一个计算机高级语言的源程序后 ,到正式上机运行之前，一般要经过(  )这几步:\n(1)编辑  (2)编译  (3)连接  (4)运行",
      "type": "single-choice",
      "options": [
        "(1)(2)(3)(4)",
        "(1)(2)(3)",
        "(1)(3)",
        "(1)(4)"
      ],
      "correct_answer": [
        "(1)(2)(3)"
      ],
      "analysis": "题目解析：计算机高级语言源程序在运行前需经过编辑、编译和连接三个步骤。编辑用于编写代码，编译将代码转换为机器语言，连接将编译后的代码与库文件链接。运行是最终执行程序。选项(1)(2)(3)正确描述了这一过程。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ05",
      "content": "编译程序将高级语言程序翻译成(  )。",
      "type": "single-choice",
      "options": [
        "机器语言程序或高级语言程序",
        "汇编语言或机器语言程序",
        "汇编语言程序或高级语言程序",
        "中间语言程序或高级语言程序"
      ],
      "correct_answer": [
        "汇编语言或机器语言程序"
      ],
      "analysis": "题目解析：编译程序的功能是将高级语言程序翻译成机器语言或汇编语言程序。汇编语言是介于高级语言和机器语言之间的语言，因此正确答案为汇编语言或机器语言程序。解题思路是理解编译程序的作用和翻译的目标语言类型。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ06",
      "content": "编译程序绝大多数时间花在(  )上。",
      "type": "single-choice",
      "options": [
        "出错处理",
        "词法分析",
        "目标代码生成",
        "表格管理"
      ],
      "correct_answer": [
        "表格管理"
      ],
      "analysis": "题目解析：本题考察编译程序的工作流程。正确答案为'表格管理'，因为编译程序在处理符号表和中间表示时，需要频繁进行表格管理，这是编译程序耗时最多的部分。而出错处理、词法分析和目标代码生成虽然也是编译程序的重要环节，但通常不会占用绝大多数时间。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ07",
      "content": "编译程序是对(  )。",
      "type": "single-choice",
      "options": [
        "汇编程序的翻译",
        "高级语言程序的解释执行",
        "机器语言的执行",
        "高级语言的翻译"
      ],
      "correct_answer": [
        "高级语言的翻译"
      ],
      "analysis": "题目解析：编译程序是将高级语言编写的源代码翻译成机器语言的过程。它不是汇编程序的翻译，也不是高级语言程序的解释执行或机器语言的执行。正确答案是高级语言的翻译，因为编译程序的主要功能是将高级语言转换为计算机可以直接执行的机器语言代码。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ08",
      "content": "编译程序是一种(  )。",
      "type": "single-choice",
      "options": [
        "汇编程序",
        "翻译程序",
        "解释程序",
        "目标程序"
      ],
      "correct_answer": [
        "翻译程序"
      ],
      "analysis": "题目解析：编译程序是一种翻译程序，它将高级语言源代码转换成机器语言目标代码。解释程序则逐行解释执行源代码，不生成目标代码。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ09",
      "content": "从编译程序的角度说，源程序中的错误通常分为(  )两大类。",
      "type": "single-choice",
      "options": [
        "词法错误和语法错误；",
        "语法错误和语义错误；",
        "编辑错误和诊断错误；",
        "词法错误和语义错误；"
      ],
      "correct_answer": [
        "语法错误和语义错误；"
      ],
      "analysis": "题目解析：源程序中的错误分为语法错误和语义错误。语法错误是指不符合编程语言语法规则的错误，而语义错误是指代码逻辑上的错误，编译器无法检测。正确答案解释了这两类错误的本质区别。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ10",
      "content": "构造编译程序应掌握(  )。",
      "type": "single-choice",
      "options": [
        "源程序",
        "目标语言",
        "编译方法",
        "以上三项都是"
      ],
      "correct_answer": [
        "以上三项都是"
      ],
      "analysis": "题目解析：本题考察构造编译程序所需掌握的知识点。源程序是编译程序的输入，目标语言是编译程序输出的程序语言，编译方法是实现编译过程的技术手段。正确答案‘以上三项都是’表明，构造编译程序需要全面掌握这三方面的知识。解题思路包括理解每个术语的含义，并认识到它们在编译程序构建过程中的重要性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ11",
      "content": "将编译程序分成若干个“遍”是为了(  )。",
      "type": "single-choice",
      "options": [
        "提高程序的执行效率",
        "使程序的结构更加清晰",
        "利用有限的机器内存并提高机器的执行效率",
        "利用有限的机器内存但降低了机器的执行效率"
      ],
      "correct_answer": [
        "使程序的结构更加清晰"
      ],
      "analysis": "编译程序分成若干“遍”主要是为了使程序结构更加清晰。每一遍处理编译过程中的不同阶段，如词法分析、语法分析等，这样可以模块化处理，便于管理和维护。这种做法并不直接提高程序的执行效率，也不会降低机器的执行效率，而是优化了编译过程的组织结构。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ12",
      "content": "解释程序处理语言时 ,大多数采用的是(  )方法。",
      "type": "single-choice",
      "options": [
        "源程序命令被逐个直接解释执行",
        "先将源程序转化为中间代码 ,再解释执行",
        "先将源程序解释转化为目标程序 ,再执行",
        "以上方法都可以"
      ],
      "correct_answer": [
        "先将源程序转化为中间代码 ,再解释执行"
      ],
      "analysis": "题目解析：解释程序处理语言时，通常采用将源程序转化为中间代码的方法，然后解释执行。这种方法称为解释执行，与直接执行源程序命令或先转化为目标程序再执行的方法不同。正确答案解释了这种常见的解释程序处理方式。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ13",
      "content": "目标代码生成阶段所生成的目标代码的形式不可能是(  )。",
      "type": "single-choice",
      "options": [
        "绝对指令代码",
        "可充定位的指令代码。",
        "汇编指令代码",
        "三地址代码"
      ],
      "correct_answer": [
        "三地址代码"
      ],
      "analysis": "题目询问目标代码生成阶段不可能生成的代码形式。三地址代码是一种中间代码，用于表示程序的控制流和数据流，而绝对指令代码、可充定位的指令代码和汇编指令代码都是目标代码的形式。因此，正确答案为三地址代码，因为它不是直接生成于目标代码阶段的代码形式。解题思路是理解目标代码的定义，并区分中间代码和目标代码的区别。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ14",
      "content": "如果一个编译程序能产生不同于其宿主机的机器代码，则称它为：(  )。",
      "type": "single-choice",
      "options": [
        "诊断编译程序",
        "优化编译程序",
        "交叉编译程序",
        "可变目标编译程序"
      ],
      "correct_answer": [
        "交叉编译程序"
      ],
      "analysis": "题目解析：交叉编译程序是指能够生成与宿主机不同机器代码的编译程序。它允许开发者在一个平台上编写代码，然后在不同的目标平台上编译运行。解题思路是理解交叉编译的定义，并识别出选项中描述这一特性的术语。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ15",
      "content": "通常一个编译程序中，不仅包含词法分析，语法分析，中间代码生成，代码优化，目标代码生成等五个部分，还应包括(  )。",
      "type": "single-choice",
      "options": [
        "模拟执行器",
        "解释器",
        "表格处理和出错处理",
        "符号执行器"
      ],
      "correct_answer": [
        "表格处理和出错处理"
      ],
      "analysis": "题目解析：编译程序通常包括词法分析、语法分析、中间代码生成、代码优化和目标代码生成等五个部分。正确答案‘表格处理和出错处理’指的是编译过程中对符号表的管理和错误处理机制，是编译程序不可或缺的一部分。解题思路是识别编译程序的基本组成部分，并理解每个部分的功能。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ16",
      "content": "下面的四个选项中，(  )不是编译程序的组成部分。",
      "type": "single-choice",
      "options": [
        "词法分析程序",
        "代码生成程序",
        "设备管理程序",
        "语法分析程序"
      ],
      "correct_answer": [
        "设备管理程序"
      ],
      "analysis": "编译程序通常包括词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成等部分。设备管理程序不属于编译程序的组成部分，而是操作系统的一部分，负责硬件设备的分配和管理。因此，正确答案是设备管理程序，因为它与编译程序的功能无关。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ17",
      "content": "下面对编译原理的有关概念正确描述的是：(  )。",
      "type": "single-choice",
      "options": [
        "目标语言只能是机器语言",
        "编译程序处理的对象是源语言。",
        "Lex是语法分析自动生成器",
        "解释程序属于编译程序"
      ],
      "correct_answer": [
        "编译程序处理的对象是源语言。"
      ],
      "analysis": "编译程序的输入是源语言代码，它将源语言翻译为目标语言。\n\n 目标语言可以是机器语言，也可以是其他高级语言或中间语言（如三地址代码）。 \n\n Lex 是一个词法分析自动生成器，用于生成词法分析器。\n\n 解释程序与编译程序是不同的概念。编译程序将源代码翻译成目标代码，然后执行；而解释程序是逐条分析和执行源代码的工具，它不生成独立的目标代码。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ18",
      "content": "下面关于解释程序的描述正确的是(  )。\n(1)解释程序的特点是处理程序时不产生目标代码\n(2)解释程序适用于 COBOL和 FORTRAN语言\n(3)解释程序是为打开编译程序技术的僵局而开发的",
      "type": "single-choice",
      "options": [
        "(1)(2)",
        "(1)",
        "(1)(2)(3)",
        "(2)(3)"
      ],
      "correct_answer": [
        "(1)"
      ],
      "analysis": "解释程序在执行时直接翻译源代码为机器代码，不生成目标代码，因此(1)正确。选项(2)错误，因为解释程序并不特定适用于COBOL和FORTRAN语言。选项(3)描述的是编译程序而非解释程序。故正确答案为(1)。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ19",
      "content": "现代多数实用编译程序所产生的目标代码都是一种可重定位的指令代码，在运行前必须借助于一个(  )把各个目标模块，包括系统提供的库模块连接在一起，确定程序变量或常数在主存中的位置，装入内存中制定的起始地址，使之成为一个可运行的绝对指令代码的程序。",
      "type": "single-choice",
      "options": [
        "重定位程序；",
        "解释程序；",
        "连接装配程序；",
        "诊断程序；"
      ],
      "correct_answer": [
        "连接装配程序；"
      ],
      "analysis": "题目解析：题干描述了编译程序生成的目标代码在运行前需要通过某种程序进行连接和重定位。正确答案'连接装配程序'负责将各个目标模块连接，确定变量和常数在内存中的位置，并装入内存。该程序确保目标代码成为可运行的绝对指令代码。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ20",
      "content": "一个编译程序中，不仅包含词法分析，(  )，中间代码生成，代码优化，目标代码生成等五个部分。",
      "type": "single-choice",
      "options": [
        "语法分析",
        "文法分析",
        "语言分析",
        "解释分析"
      ],
      "correct_answer": [
        "语法分析"
      ],
      "analysis": "题目解析：题干描述了一个编译程序的基本组成部分，其中词法分析、语法分析、中间代码生成、代码优化和目标代码生成是编译程序的五个主要阶段。正确答案'语法分析'是其中之一，它负责检查源代码的语法结构是否符合编程语言的规则。解题思路是识别编译程序各阶段的功能，并选择与题干描述相符的选项。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ21",
      "content": "用高级语言编写的程序经编译后产生的程序叫(  )。",
      "type": "single-choice",
      "options": [
        "源程序",
        "目标程序",
        "连接程序",
        "解释程序"
      ],
      "correct_answer": [
        "目标程序"
      ],
      "analysis": "源程序经过编译器翻译后生成的程序，称为目标程序。通常是汇编代码、机器码或者中间代码。\n\n 用高级语言（如 C、Java 等）编写的原始程序，在编译前的状态称为源程序。\n\n 连接程序（Linker）用于将目标程序与所需的库文件等链接在一起，生成最终可执行文件。 \n\n 解释程序直接逐条执行源程序代码，而不是生成独立的目标程序。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ22",
      "content": "与编译系统相比，解释系统(  )。",
      "type": "single-choice",
      "options": [
        "比较简单 ,可移植性好 ,执行速度快",
        "比较复杂 ,可移植性好 ,执行速度快",
        "比较简单 ,可移植性差 ,执行速度慢",
        "比较简单 ,可移植性好 ,执行速度慢"
      ],
      "correct_answer": [
        "比较简单 ,可移植性好 ,执行速度慢"
      ],
      "analysis": "题目解析：解释系统相较于编译系统，其设计相对简单，易于移植，但由于其逐行解释执行，因此执行速度较慢。正确答案强调了这三个特点：简单、可移植性好、执行速度慢。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ23",
      "content": "语义错误是指源程序中不符合语义规则的错误，不包括：(  )",
      "type": "single-choice",
      "options": [
        "非法字符错误",
        "类型不一致错误。",
        "作用域错误",
        "说明错误"
      ],
      "correct_answer": [
        "非法字符错误"
      ],
      "analysis": "题目解析：语义错误是指源程序中不符合语义规则的错误，但不包括非法字符错误。非法字符错误属于语法错误，而语义错误涉及的是变量、类型、作用域等逻辑上的错误。类型不一致错误、作用域错误和说明错误都属于语义错误。解题思路是识别选项中哪些属于语法错误，排除它们，得出正确答案。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A01XZ24",
      "content": "在目标代码生成阶段，符号表用于(  )。",
      "type": "single-choice",
      "options": [
        "目标代码生成",
        "语义检查",
        "语法检查",
        "地址分配"
      ],
      "correct_answer": [
        "地址分配"
      ],
      "analysis": "题目解析：题干询问在目标代码生成阶段，符号表所用的操作。符号表用于存储变量和函数的名称、类型、地址等信息。在目标代码生成阶段，主要任务是生成目标代码，其中地址分配是符号表的重要用途，用于确定每个变量和函数在目标代码中的位置。因此，正确答案是'地址分配'。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02xz01",
      "content": "Chomsky把文法分成四种类型，0型、1型、2型和3型。3型文法称为(  )。",
      "type": "single-choice",
      "options": [
        "上下文无关文法",
        "上下文相关文法",
        "正则文法",
        "短语文法"
      ],
      "correct_answer": [
        "正则文法"
      ],
      "analysis": "Chomsky的文法分类中，3型文法是指正则文法，它只包含有限的状态转换规则；。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02xz02",
      "content": "许多广为使用的语言，如Fortran、C、Pascal等，属于(  )。",
      "type": "single-choice",
      "options": [
        "强制式语言",
        "应用式语言",
        "基于规则的语言",
        "面向对象的语言"
      ],
      "correct_answer": [
        "强制式语言"
      ],
      "analysis": "题目解析：题干中提到的Fortran、C、Pascal等语言属于编程语言的一种。正确答案'强制式语言'指的是这类语言在编程时需要明确指定程序的控制流程和数据结构。解题思路是识别题干中的语言类型，并理解'强制式语言'的定义，从而选出正确答案。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02xz03",
      "content": "设G是一个文法，S是开始符号。若S⇒*α，α∈(VT∪VN)*，则称α是一个(  )。",
      "type": "single-choice",
      "options": [
        "句子",
        "句型",
        "推导",
        "语言"
      ],
      "correct_answer": [
        "句型"
      ],
      "analysis": "题目解析：在文法G中，若从开始符号S出发，通过一系列的推导步骤得到字符串α，则α被称为句型。句型是文法推导的最终结果，可以是终结符（VT）或非终结符（VN）的序列。解题思路是理解句型的定义，并将其与题目中的推导过程联系起来。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02xz04",
      "content": "一个数据类型通常包括的三种要素中，没有下面的(  )。",
      "type": "single-choice",
      "options": [
        "用于区别这种类型的数据对象的属性",
        "这种类型的数据对象可以具有的值",
        "对这种类型的数据对象的内存分配",
        "可以作用于这种类型的数据对象的操作"
      ],
      "correct_answer": [
        "对这种类型的数据对象的内存分配"
      ],
      "analysis": "数据类型的三种要素包括属性、值和操作。属性用于区分数据对象，值是数据对象可以具有的，操作是作用于数据对象的。选项中，'对这种类型的数据对象的内存分配'不属于数据类型的要素，而是内存管理的范畴。因此，正确答案为'对这种类型的数据对象的内存分配'。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02xz05",
      "content": "Chomsky把文法分成四种类型，其中，(  )也称正规文法",
      "type": "single-choice",
      "options": [
        "0型",
        "1型",
        "2型",
        "3型"
      ],
      "correct_answer": [
        "3型"
      ],
      "analysis": "题目解析：Chomsky的文法分类中，0型为短语结构文法，1型为上下文有关文法，2型为上下文无关文法，3型为正则文法。正则文法也称正规文法，是3型文法，其规则简单，易于实现。解题思路为识别文法类型并对应其名称。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02xz06",
      "content": "语言的词法规则一般用Chomsky的(  )型文法来描述：",
      "type": "single-choice",
      "options": [
        "0",
        "1",
        "2",
        "3"
      ],
      "correct_answer": [
        "3"
      ],
      "analysis": "题目解析：Chomsky的文法分为0型、1型、2型和3型，其中3型文法也称为正则文法，用于描述语言的词法规则。解题思路是识别题干中提到的Chomsky文法类型，并选择与之对应的选项。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02xz07",
      "content": "文法\n S→(L)|a\nL→L，S|S 中，下面哪个选项是该文法中的终结符号",
      "type": "single-choice",
      "options": [
        "S",
        "，",
        "L",
        "|"
      ],
      "correct_answer": [
        "，"
      ],
      "analysis": "终结符号是文法中不可进一步分解的符号。在给定的文法中，终结符号包括'a'和'，'。选项中'S'和'L'是文法中的非终结符号，可以进一步分解。'|'是文法中的运算符，也不是终结符号。因此，正确答案是'，'，它是文法中的终结符号。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02xz08",
      "content": "文法G所描述的语言是(  )的集合。",
      "type": "single-choice",
      "options": [
        "文法G的字母表中的所有符号组成的符号串",
        "文法G的字母表的闭包*中的所有符号串",
        "文法G的识别符号推出的所有符号串",
        "文法G的识别符号推出的所有终结符号串"
      ],
      "correct_answer": [
        "文法G的识别符号推出的所有终结符号串"
      ],
      "analysis": "题目解析：文法G所描述的语言是指由文法G的识别符号推出的所有终结符号串组成的集合。这里的终结符号串是指由文法G的终结符号组成的字符串。解题思路是理解文法G的定义，以及终结符号串的概念，从而确定正确答案。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02xz09",
      "content": "语言L={αcα| α∈(a|b)*}，该语言是(  )语言。",
      "type": "single-choice",
      "options": [
        "3型语言",
        "2型语言",
        "1型语言",
        "0型语言"
      ],
      "correct_answer": [
        "2型语言"
      ],
      "analysis": "语言L={αcα∣α∈(a∣b)∗}表示的语言要求字符串形式为：任意长度的字符串 α ，紧跟一个字符 c，再接相同的字符串 𝛼。\n\n 该语言语言的描述不依赖字符串前后的上下文，仅依赖 𝛼 和 c 的结构，为 2型语言（上下文无关语言）",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02xz10",
      "content": "设有文法G：I→I1 | I0 | Ia | Ic | a | b | c |\n下面符号串中不是该文法的句子是：",
      "type": "single-choice",
      "options": [
        "ab0",
        "a0c01",
        "aaa，",
        "bc10"
      ],
      "correct_answer": [
        "ab0"
      ],
      "analysis": "题目解析：文法G定义了一组产生式，包括I的非终结符和终结符a, b, c。选项中，'ab0'符合文法，而'aaa，'包含逗号，不属于终结符，因此不是文法G的句子。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02xz11",
      "content": "给定文法A→bA|cc，下面的符号串中，是该文法句子的是(  )。",
      "type": "single-choice",
      "options": [
        "bcbc，",
        "bbbcc，",
        "bcbcc，",
        "bccbcc；"
      ],
      "correct_answer": [
        "bbbcc，"
      ],
      "analysis": "题目解析：文法A→bA|cc表示A可以由bA或cc构成。正确答案bbbcc符合文法规则，因为它可以按照A→bA→bbA→bbbbA→bbbbcc的步骤生成。其他选项不符合文法规则，因为它们无法通过上述步骤生成。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02xz12",
      "content": "Chomsky定义的四种形式语言文法中，2型文法可由(  )识别。",
      "type": "single-choice",
      "options": [
        "图灵机；",
        "确定性有限自动机；",
        "下推自动机；",
        "非确定性有限自动机；"
      ],
      "correct_answer": [
        "下推自动机；"
      ],
      "analysis": "2型文法，又称上下文无关文法，是一种语法规则。下推自动机能够根据输入符号序列从右向左推导出字符串，符合2型文法的识别需求。因此，正确答案是下推自动机。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02xz13",
      "content": "若文法G定义的语言是无限集，则文法必然是(  )。",
      "type": "single-choice",
      "options": [
        "上下文无关的",
        "递归的",
        "二义性的",
        "无二义性的"
      ],
      "correct_answer": [
        "递归的"
      ],
      "analysis": "题目解析：文法G定义的语言是无限集，意味着该语言包含无限多个字符串。根据形式语言理论，只有递归文法能够生成无限语言。因此，正确答案是'递归的'。题目术语'递归的'指的是文法能够生成自身，即文法生成的语言是递归可枚举的。解题思路是理解无限集与递归文法的关系，排除其他选项。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02xz14",
      "content": "文法S→aaS|abc 定义的语言是(  )。",
      "type": "single-choice",
      "options": [
        "{a<sup>2k</sup>bc|k>0}",
        "{a<sup>k</sup>bc|k>0}",
        "{a<sup>2k-1</sup>bc|k>0}",
        "{a<sup>k</sup> a<sup>k</sup>bc|k>0}"
      ],
      "correct_answer": [
        "{a<sup>2k-1</sup>bc|k>0}"
      ],
      "analysis": "题干中给出的文法S→aaS|abc表示S可以生成形式为aaS或abc的字符串，其中a和b是字母，k是大于0的整数。正确答案'{a<sup>2k-1</sup>bc|k>0}'表示字符串由2k-1个a，一个b，一个c组成，且k大于0。解题思路是分析文法规则，确定能生成的字符串形式。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A02xz15",
      "content": "文法：G：S→xSx | y所识别的语言是(  )。",
      "type": "single-choice",
      "options": [
        "xyx",
        "(xyx)*",
        "x*yx*",
        "x<sup>n</sup>yx<sup>n</sup>（n≥0）"
      ],
      "correct_answer": [
        "x<sup>n</sup>yx<sup>n</sup>（n≥0）"
      ],
      "analysis": "题目解析：题干中描述的文法G定义了一个生成语言，其中S是起始符号，x和y是字母。该文法生成所有形如x^n yx^n的字符串，其中n是非负整数。正确答案解释了该语言的构成，即所有由x和y组成的字符串，其中x和y的个数相等。解题思路是识别文法生成的字符串模式，并理解其结构。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03xz01",
      "content": "程序语言下面的单词符号中，( )一般不需要超前搜索。",
      "type": "single-choice",
      "options": [
        "关键字",
        "标识符",
        "常数",
        "算符和界符"
      ],
      "correct_answer": [
        "标识符"
      ],
      "analysis": "题目解析：题干中提到的单词符号，标识符是程序中用户定义的名称，通常不需要在代码中提前声明，因此不需要超前搜索。关键字、常数和算符和界符在程序中可能有特定的使用规则，可能需要根据上下文进行搜索。解题思路是理解标识符的特性，并排除其他可能需要搜索的符号类型。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03xz02",
      "content": "在状态转换图的实现中，( ) 一般对应一个循环语句",
      "type": "single-choice",
      "options": [
        "不含回路的分叉结点",
        "含回路的状态结点",
        "终态结点",
        "都不是"
      ],
      "correct_answer": [
        "含回路的状态结点"
      ],
      "analysis": "在状态转换图中，'含回路的状态结点'指的是存在至少一个回路的结点。这类结点通常对应循环语句，因为它们可以重复访问，形成循环。解题思路是识别状态转换图中的循环结构，并将其与循环语句相对应。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03xz03",
      "content": "从左线性文法构造有限自动机时，通常自动机状态个数比文法非终结符号数多( )个。",
      "type": "single-choice",
      "options": [
        "4",
        "2",
        "0",
        "1"
      ],
      "correct_answer": [
        "1"
      ],
      "analysis": "从左线性文法构造有限自动机时，通常会为每个非终结符号分配一个状态。此外，还需要增加一个终止状态（接受状态），以表示文法的结束。\n\n 假设文法有 n 个非终结符号，那么构造的有限自动机需要 n+1 个状态，其中：n 个状态对应文法中的非终结符号,1 个状态作为接受状态。\n\n 因此，自动机的状态个数通常比文法非终结符号数多 1 个。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03xz04",
      "content": "正规表达式(ε|a|b)<sup>2</sup>表示的集合是( )。",
      "type": "single-choice",
      "options": [
        "{ε，ab，ba，aa，bb}",
        "{ab，ba，aa，bb}",
        "{a，b，ab，aa，ba，bb}",
        "{ε，a，b，aa，bb，ab，ba}"
      ],
      "correct_answer": [
        "{ε，a，b，aa，bb，ab，ba}"
      ],
      "analysis": "正规表达式(ε|a|b)<sup>2</sup>表示的是由ε、a、b组成的字符串，且长度为2。ε表示空字符串，|表示或，<sup>2</sup>表示重复两次。因此，可能的字符串包括ε、aa、ab、ba、bb、aaa、aab、aba、abb、baa、bab、bba、aaa、aab、aba、abb、baa、bab、bba。正确答案包含所有这些字符串，故解析为{ε，a，b，aa，bb，ab，ba}。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03xz05",
      "content": "有限状态自动机可用五元组（VT，Q，δ，q0，Qf）来描述，设有一有限状态自动机M的定义如下：\nVT={0，1}，Q={q0，q1，q2}，Qf= {q2}，δ的定义为：\nδ（q0，0）=q1\nδ（q1，0）=q2\nδ（q2，1）=q2\nδ（q2，0）=q2\nM所能接受的语言可以用正则表达式表示为( )。",
      "type": "single-choice",
      "options": [
        "(0|1)*",
        "00(0|1)*",
        "(0|1)*00",
        "0(0|1)*0"
      ],
      "correct_answer": [
        "00(0|1)*"
      ],
      "analysis": "题目描述了一个有限状态自动机M，其五元组定义了自动机的状态、输入符号、状态转换函数、初始状态和终止状态。正确答案'00(0|1)*'表示该自动机识别的语言是所有以'00'开头，后面跟任意数量'0'或'1'的字符串。解题思路是理解五元组的含义，并识别出正确答案所描述的语言模式。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03xz06",
      "content": "有限状态自动机可用五元组（VT，Q，δ，q0，Qf）来描述，设有一有限状态自动机M的定义如下：\nVT={0，1}，Q={q0，q1，q2}，Qf={q2}，δ的定义为：\nδ（q0，0）=q1\nδ（q1，0）=q2\nδ（q2，1）=q2\nδ（q2，0）=q2\nM所能接受的语言为( )。",
      "type": "single-choice",
      "options": [
        "由0和1所组成的符号串的集合",
        "以0为头符号和尾符号、由0和1所组成的符号串的集合",
        "以两个0结束的，由0和1所组成的符号串的集合",
        "以两个0开始的，由0和1所组成的符号串的集合"
      ],
      "correct_answer": [
        "以两个0开始的，由0和1所组成的符号串的集合"
      ],
      "analysis": "题目描述了有限状态自动机的五元组定义，并要求识别符合该定义的符号串集合。正确答案指出集合由以两个0开始的0和1组成，即符号串必须以两个0开头。解题思路是理解有限状态自动机的概念，识别出符号串的起始条件，并选择符合这一条件的选项。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03xz07",
      "content": "从接受语言的能力上来说，非确定型有穷自动机和( )是等价的。",
      "type": "single-choice",
      "options": [
        "ⅰ.正规式；ⅱ.上下文无关文法；ⅲ.确定性有穷自动机；",
        "ⅰ.左线性正规文法；ⅱ.右线性正规文法；ⅲ.确定性有穷自动机；",
        "ⅰ.正规式；ⅱ.上下文无关文法；ⅲ.正规文法；",
        "ⅰ.正规式；ⅱ.确定性有穷自动机；ⅲ.下推自动机；"
      ],
      "correct_answer": [
        "ⅰ.左线性正规文法；ⅱ.右线性正规文法；ⅲ.确定性有穷自动机；"
      ],
      "analysis": "题目解析：本题考察语言识别的理论基础。非确定型有穷自动机（NFA）和左线性正规文法（LLG）以及右线性正规文法（RLG）在识别语言的能力上是等价的。确定性有穷自动机（DFA）和正规式在识别能力上与NFA等价。因此，正确答案为左线性正规文法和右线性正规文法，它们与NFA等价。解题思路是理解不同类型的文法和自动机在语言识别上的能力，并识别出与NFA等价的语言识别模型。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03xz08",
      "content": "关于NFA的叙述中，下面( )是不正确的。",
      "type": "single-choice",
      "options": [
        "有一个有穷字母表",
        "有多个初始状态",
        "有多个终止状态",
        "有多个有限状态"
      ],
      "correct_answer": [
        "有多个初始状态"
      ],
      "analysis": "有限自动机（FA）具有一个有穷字母表，且NFA 和 DFA都只有一个初始状态。这是有限自动机的定义决定的。虽然 NFA 的多个路径可能从初始状态分叉，但其初始状态本身是唯一的。\n\n NFA 允许多个终止状态，这与 DFA 相同。\n\n NFA 的定义之一，它需要有限的状态集合，故可以有多个有限状态。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03xz09",
      "content": "词法分析的理论基础是( )。",
      "type": "single-choice",
      "options": [
        "有穷自动机理论",
        "图灵机理论",
        "图论",
        "无穷自动机理论"
      ],
      "correct_answer": [
        "有穷自动机理论"
      ],
      "analysis": "词法分析是编译过程中的第一步，其理论基础是有穷自动机理论。有穷自动机理论提供了一种模型来描述词法分析器如何识别和分类源代码中的单词。解题思路是理解词法分析的定义和其理论基础，然后从选项中选出符合这一理论的选项。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03xz10",
      "content": "设有两个状态S和T，如果从S出发能读出某个字w而停于终态，那么从T出发也能读出同样的字而停于终态；反之，果从T出发能读出某个字w而停于终态，那么从S出发也能读出同样的字而停于终态。则我们称状态S和状态T是( )。",
      "type": "single-choice",
      "options": [
        "可区分的；",
        "等价的；",
        "多余的；",
        "无用的。"
      ],
      "correct_answer": [
        "等价的；"
      ],
      "analysis": "题目中提到的状态S和T，如果它们在读取某个字w后能停于终态，且这种读取能力相互对称，即S到T和T到S都能实现相同的读取，则称这两个状态是等价的。这里的等价指的是状态转换的对称性，解题时需关注状态转换图或状态转移矩阵，分析状态间是否具有对称的转换关系。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03xz11",
      "content": "词法分析器的输出结果是( )。",
      "type": "single-choice",
      "options": [
        "单词自身值",
        "单词在符号表中的位置",
        "单词的种别编码",
        "单词的种别编码和自身值"
      ],
      "correct_answer": [
        "单词的种别编码和自身值"
      ],
      "analysis": "词法分析器，也称为扫描器，其输出结果通常包括单词的种别编码和自身值。种别编码用于标识单词的类型，如标识符、关键字、运算符等；自身值则表示单词的具体内容。正确答案指出，词法分析器的输出应包含这两部分信息。解题时，需理解词法分析的基本概念和输出内容。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03xz12",
      "content": "编译过程中扫描器的任务包括( )。\n①组织源程序的输入\n②按词法规则分割出单词，识别出其属性，并转换成属性字的形式输出\n③删除注解\n④删除空格及无用字符\n⑤行计数、列计数\n⑥发现并定位词法错误\n⑦建立符号表",
      "type": "single-choice",
      "options": [
        "②③④⑦",
        "②③④⑥⑦",
        "①②③④⑥⑦",
        "①②③④⑤⑥⑦"
      ],
      "correct_answer": [
        "①②③④⑤⑥⑦"
      ],
      "analysis": "编译过程中扫描器的任务包括组织源程序输入、按词法规则分割单词、删除注解、删除空格及无用字符、行列计数、发现词法错误和建立符号表。这些任务共同完成词法分析，确保源代码的初步结构化。解题时需理解每个选项的含义，并判断其是否属于扫描器的任务。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03xz13",
      "content": "下述正则表达式中( )与(a*+b)*(c+d)等价(即有相同符号串集)。(x+y亦可写作x|y) \n ①a*(c+d)+b(c+d) \n②a*(c+d)*+b(c+d)* \n③a*(c+d)+b(c+d) \n④(a+b)*c+(a+b)*d \n⑤(a*+b)*c+(a*+b)*d ",
      "type": "single-choice",
      "options": [
        "①③",
        "③④⑤",
        "③",
        "④⑤"
      ],
      "correct_answer": [
        "④⑤"
      ],
      "analysis": "整个表达式描述的语言为：一串 a 或 b 的重复序列，接着是 c 或 d, ④表达式表示任意多次 a 或 b 后接 c，或任意多次 a 或 b 后接 d。这与原式等价。⑤表达式允许 a∗ 或 b 的任意组合多次重复，后接 c 或 d，这与原式等价。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03xz14",
      "content": "正则式的“*”读作( )。",
      "type": "single-choice",
      "options": [
        "并且",
        "或者",
        "连接",
        "闭包"
      ],
      "correct_answer": [
        "闭包"
      ],
      "analysis": "正则表达式中的“*”符号表示闭包，意味着匹配前面的字符0次或多次。解题时，需理解正则表达式的符号含义，排除其他选项，选择正确答案‘闭包’。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03xz15",
      "content": "在状态转换图中，结点代表( )，用圆圈表示。",
      "type": "single-choice",
      "options": [
        "输入缓冲区",
        "向前搜索",
        "状态",
        "字符串"
      ],
      "correct_answer": [
        "状态"
      ],
      "analysis": "题目解析：在状态转换图中，结点代表系统可能的状态，用圆圈表示。状态转换图是一种图形化工具，用于描述系统从一个状态转换到另一个状态的过程。正确答案为'状态'，因为结点是状态转换图中的基本元素，表示系统可能存在的不同状态。解题思路是识别状态转换图的基本组成部分，即状态，并排除其他与图形表示无关的选项。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03xz16",
      "content": "与(a|b)*(a|b)等价的正规式是( )。",
      "type": "single-choice",
      "options": [
        "a*| b*",
        "(ab)*(a|b)*",
        "(a|b)(a|b)*",
        "(a|b)*"
      ],
      "correct_answer": [
        "(a|b)(a|b)*"
      ],
      "analysis": "题目要求找出与(a|b)*(a|b)等价的正规式。术语解释：正规式是描述字符串集合的模式。解题思路：分析题干中的表达式(a|b)*(a|b)，表示任意数量的(a或b)后跟任意数量的(a或b)。选项中，只有'(a|b)(a|b)*'正确地表示了这一模式，即先出现一次(a或b)，然后可以跟任意多次(a或b)。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A03xz17",
      "content": "无符号常数的识别和拼数工作通常都在( ) 阶段完成。",
      "type": "single-choice",
      "options": [
        "词法分析",
        "语法分析",
        "语义分析",
        "代码生成"
      ],
      "correct_answer": [
        "词法分析"
      ],
      "analysis": "题目解析：无符号常数的识别和拼数工作属于对源代码的初步分析，这一阶段称为词法分析。词法分析阶段负责将源代码分解成一个个的词法单元，如标识符、关键字、常量等。无符号常数作为常量的一种，在这一阶段被识别和拼数。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A04xz01",
      "content": "高级语言编译程序常用的语法分析方法中，递归下降分析法属于(  )分析法。",
      "type": "single-choice",
      "options": [
        "自左至右",
        "自顶向下",
        "自底向上",
        "自右向左"
      ],
      "correct_answer": [
        "自顶向下"
      ],
      "analysis": "递归下降分析法是一种自顶向下的语法分析方法。它将输入的源代码从上到下、从整体到局部进行解析，通过递归调用分析函数来模拟语法规则。这种方法适用于上下文无关文法，能够有效地分析复杂的高级语言程序。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A04xz02",
      "content": "上下文无关文法可以用(  )来描述。",
      "type": "single-choice",
      "options": [
        "正则表达式",
        "正规文法",
        "扩展的BNF",
        "翻译模式"
      ],
      "correct_answer": [
        "扩展的BNF"
      ],
      "analysis": "上下文无关文法（CFG）是一种用于描述计算机语言中句子结构的文法。扩展的BNF（Backus-Naur Form）是一种用于描述上下文无关文法的语法表示方法，它通过扩展标准BNF，允许在产生式中包含非终结符和终结符。解题思路是识别描述上下文无关文法的术语，并选择正确的描述方法，即扩展的BNF。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A04xz03",
      "content": "自上而下分析面临的四个问题中，不包括(  )。",
      "type": "single-choice",
      "options": [
        "需消除左递归",
        "存在回朔",
        "虚假匹配",
        "寻找可归约串"
      ],
      "correct_answer": [
        "寻找可归约串"
      ],
      "analysis": "题目解析：题干要求从四个选项中找出不属于自上而下分析面临的四个问题的选项。自上而下分析是一种语法分析方法，其中需消除左递归、存在回溯、虚假匹配是常见问题。'寻找可归约串'不是自上而下分析的问题，而是属于语法分析的一般任务。解题思路是识别自上而下分析中特有的问题，排除非特有问题。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A04xz04",
      "content": "语法分析器接收以(  )为单位的输入，并产生有关信息供以后各阶段使用。",
      "type": "single-choice",
      "options": [
        "表达式",
        "产生式",
        "单词",
        "语句"
      ],
      "correct_answer": [
        "单词"
      ],
      "analysis": "题目解析：题干描述了语法分析器的输入单位，正确答案为'单词'。在编译原理中，单词是构成程序的基本元素，语法分析器通过识别单词来构建语法结构。解题思路是理解语法分析器的功能，并识别其输入的基本单位。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A04xz05",
      "content": "自上而下分析的主旨是，对任何单词符号串，试图用一切可能的办法，从文法开始符号（根结点）出发，(  )。",
      "type": "single-choice",
      "options": [
        "为输入串寻找最右推导",
        "为输入串寻找最左直接子树",
        "为输入串建立最右直接子树",
        "为输入串寻找最左推导"
      ],
      "correct_answer": [
        "为输入串寻找最左推导"
      ],
      "analysis": "题目解析：题干中提到的自上而下分析，是指从文法开始符号（根结点）出发，逐步向下分析的过程。正确答案'为输入串寻找最左推导'表明，在分析过程中，我们是从左到右、从上到下地寻找最左边的推导路径，直到得到完整的单词符号串。这种方法有助于理解文法的结构，并验证输入串是否符合文法规则。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05xz01",
      "content": "LR语法分析栈中存放的状态是识别(  )的DFA状态。",
      "type": "single-choice",
      "options": [
        "前缀",
        "可归前缀",
        "项目",
        "句柄"
      ],
      "correct_answer": [
        "可归前缀"
      ],
      "analysis": "题目解析：LR语法分析栈中存放的是识别过程中可能遇到的所有DFA状态，这些状态被称为'可归前缀'。它们是预测分析过程中，根据当前输入符号和栈顶符号所能归约的前缀。解题思路是理解LR分析器的状态转换机制，识别出与DFA状态相对应的术语。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05xz02",
      "content": "算符优先分析法每次都是对(  )进行归约：",
      "type": "single-choice",
      "options": [
        "句柄",
        "最左素短语",
        "素短语",
        "简单短语"
      ],
      "correct_answer": [
        "最左素短语"
      ],
      "analysis": "算符优先分析法是一种语法分析方法，它通过分析表达式中算符的优先级来对表达式进行归约。题目中提到的'最左素短语'是指在进行归约时，首先考虑最左侧的素短语，即不可再分解的最小语法单位。解题思路是理解算符优先级，并识别出最左素短语作为归约的起点。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05xz03",
      "content": "有文法G＝（｛S｝，｛a｝，｛S→SaS，S→ε｝，S），该文法是(  )。",
      "type": "single-choice",
      "options": [
        "LL(1)文法",
        "二义性文法",
        "算符优先文法",
        "SLR(1)文法"
      ],
      "correct_answer": [
        "二义性文法"
      ],
      "analysis": "题目解析：文法G中，S可以推导出自身，导致存在多个可能的解析路径，因此具有二义性。题目术语解释：二义性文法指存在多个解析路径的文法。解题思路描述：通过分析文法规则，发现S可以推导出自身，从而判断该文法具有二义性。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05xz04",
      "content": "在编译程序中，语法分析分为自顶向下分析和自底向上分析两类，(  )和LL(1)分析法属于自顶向下分析。",
      "type": "single-choice",
      "options": [
        "深度分析法",
        "宽度优先分析法",
        "算符优先分析法",
        "递归下降子程序分析法"
      ],
      "correct_answer": [
        "递归下降子程序分析法"
      ],
      "analysis": "题目解析：自顶向下分析是一种从整体到局部的语法分析方法。递归下降子程序分析法是一种典型的自顶向下分析方法，它通过递归调用来匹配文法规则。该题要求识别属于自顶向下分析的语法分析方法，正确答案是递归下降子程序分析法，因为它符合自顶向下分析的定义。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05xz05",
      "content": "自底向上语法分析采用(  )分析法，常用的是自底向上语法分析有算符优先分析法和LR分析法。",
      "type": "single-choice",
      "options": [
        "递归",
        "回溯",
        "枚举",
        "移进－归约"
      ],
      "correct_answer": [
        "移进－归约"
      ],
      "analysis": "题目解析：题干中提到的自底向上语法分析是一种解析方法，其中'移进－归约'分析法是常用的一种。移进－归约分析法通过逐步移进输入符号到分析栈，并尝试归约到产生式，从而构建语法树。解题思路是识别题目中的术语，理解移进－归约分析法的概念，并选择与之对应的选项。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05xz06",
      "content": "一个LR(k)文法，无论k取多大，(  )。",
      "type": "single-choice",
      "options": [
        "都是无二义性的",
        "都是二义性的",
        "一部分是二义性的",
        "无法判定二义性"
      ],
      "correct_answer": [
        "都是无二义性的"
      ],
      "analysis": "LR(k)文法是一种上下文无关文法，其中k表示预测的符号数量。题目中的解析指出，无论k取多大，LR(k)文法都是无二义性的。这意味着对于任何给定的LR(k)文法，其生成的语言都是确定的，不会产生歧义。解题思路是理解LR(k)文法的定义和性质，以及无二义性的概念。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05xz07",
      "content": "在编译程序中，语法分析分为自顶向下分析和自底向上分析两类，(  )和LR分析法属于自底向上分析。",
      "type": "single-choice",
      "options": [
        "深度分析法",
        "宽度优先分析法",
        "算符优先分析法",
        "递归下降子程序分析法"
      ],
      "correct_answer": [
        "算符优先分析法"
      ],
      "analysis": "题目解析：题干中提到的自底向上分析是指从具体到一般的分析过程。算符优先分析法是一种自底向上的语法分析方法，它通过分析输入符号序列中的算符优先级来确定语法结构。解题思路是识别题目中的术语，理解自底向上分析的概念，然后根据选项选择符合该定义的方法。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05xz08",
      "content": "在编译程序中，语法分析分为自顶向下分析和自底向上分析两类，自顶向下分析试图为输入符号串构造一个(  )。",
      "type": "single-choice",
      "options": [
        "语法树",
        "有向无环图",
        "最左推导",
        "最右推导"
      ],
      "correct_answer": [
        "最左推导"
      ],
      "analysis": "题目解析：自顶向下分析在编译程序中用于构造输入符号串的语法结构。它试图从根节点开始，逐步向下构造出整个语法树。最左推导是指从根节点开始，按照从左到右的顺序进行推导，直到到达叶节点。因此，自顶向下分析试图为输入符号串构造一个最左推导。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05xz09",
      "content": "在编译程序中，语法分析分为自顶向下分析和自底向上分析两类，自底向上分析试图为输入符号串构造一个(  )。",
      "type": "single-choice",
      "options": [
        "语法树",
        "有向无环图",
        "最左推导",
        "最右推导"
      ],
      "correct_answer": [
        "最右推导"
      ],
      "analysis": "题目解析：题干描述了编译程序中的语法分析方法，自底向上分析旨在从输入符号串构造一个推导过程。最右推导是指从输入符号串开始，逐步替换为更简单的符号，直到得到终结符序列的过程。因此，正确答案为'最右推导'。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05xz10",
      "content": "采用自顶向下分析方法时，要求文法中不含有(  )。",
      "type": "single-choice",
      "options": [
        "右递归",
        "左递归",
        "直接右递归",
        "直接左递归"
      ],
      "correct_answer": [
        "左递归"
      ],
      "analysis": "题目解析：自顶向下分析方法要求文法中不含有左递归。左递归是指文法规则中，产生式的右部以非终结符开头，并且该非终结符出现在产生式的开头位置。这种递归会导致自顶向下分析过程中产生无限递归，影响分析的正确性。解题思路是理解左递归的定义，并识别出选项中描述左递归的术语。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05xz11",
      "content": "LR分析是寻找右句型的(  )；而算符优先分析是寻找右句型的最左素短语。",
      "type": "single-choice",
      "options": [
        "短语",
        "素短语",
        "最左素短语",
        "句柄"
      ],
      "correct_answer": [
        "最左素短语"
      ],
      "analysis": "题目解析：LR分析是一种语法分析技术，它寻找的是最左素短语，即从左到右扫描时，第一个能匹配的短语。算符优先分析则是寻找最左素短语的最左部分。因此，题目中的空格应填入'最左素短语'。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05xz12",
      "content": "LR分析法中分析能力最强的是LR(1)；分析能力最弱的是(  )。",
      "type": "single-choice",
      "options": [
        "SLR(1)",
        "LR(0)",
        "LR(1)",
        "LALR(1)"
      ],
      "correct_answer": [
        "LR(0)"
      ],
      "analysis": "LR分析法中，LR(1)具有最强的分析能力，因为它能够处理更多的语法结构。LR(0)的分析能力最弱，因为它只能处理LR(1)能够处理的所有结构，以及一些额外的结构。解题思路是理解不同LR分析器的分析能力差异，并识别出分析能力最弱的选项。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05xz13",
      "content": "设有文法G：T->T*F | F\nF->F↑P | P\nP->(T) | a\n该文法句型T*P↑(T*F)的最左直接短语是下列符号串(  )",
      "type": "single-choice",
      "options": [
        "(T*F)，",
        "T*F，",
        "P，",
        "P↑(T*F)"
      ],
      "correct_answer": [
        "(T*F)，"
      ],
      "analysis": "题目解析：文法G中，句型T*P↑(T*F)的最左直接短语是指从左至右第一个非终结符开始，直到遇到一个终结符或更高级别的非终结符为止的符号串。在给定的句型中，最左直接短语是'(T*F)'，因为它是最左侧的非终结符序列，直到遇到终结符'a'。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05xz14",
      "content": "在通常的语法分析方法中，(  )特别适用于表达式的分析。",
      "type": "single-choice",
      "options": [
        "算符优先分析法",
        "LR分析法",
        "递归下降分析法",
        "LL(1)分析法"
      ],
      "correct_answer": [
        "算符优先分析法"
      ],
      "analysis": "算符优先分析法是一种语法分析方法，特别适用于表达式的分析。它通过定义算符的优先级和结合性来分析表达式，无需考虑上下文。解题思路是识别表达式中各个算符的优先级，按照优先级顺序进行解析。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05xz15",
      "content": "运算符的优先数之间有几种关系(  )。",
      "type": "single-choice",
      "options": [
        "3种",
        "2种",
        "4种",
        "1种"
      ],
      "correct_answer": [
        "3种"
      ],
      "analysis": "题目解析：运算符的优先数关系涉及运算符在表达式中的执行顺序。根据编程语言规则，运算符的优先数关系主要有三种：优先级高的运算符先执行，相同优先级的从左至右执行，括号内的运算先执行。因此，运算符的优先数之间有3种关系。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05xz16",
      "content": "算符优先法属于(  )。",
      "type": "single-choice",
      "options": [
        "自上而下分析法",
        "LR分析法",
        "ＳLR分析法",
        "自下而上分析法"
      ],
      "correct_answer": [
        "自下而上分析法"
      ],
      "analysis": "算符优先法是一种语法分析方法，它通过分析算符的优先级来确定表达式的求值顺序。题目中的正确答案是'自下而上分析法'，这是因为算符优先法从表达式的末尾开始，逐步向上分析，直到整个表达式被解析。这种方法不需要考虑语法规则，而是直接根据算符的优先级进行计算。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A05xz17",
      "content": "在LR分析法中，分析栈中存放的状态是识别规范句型(  )的DFA状态。",
      "type": "single-choice",
      "options": [
        "句柄",
        "前缀",
        "活前缀",
        "LR(0)项目"
      ],
      "correct_answer": [
        "活前缀"
      ],
      "analysis": "题目解析：LR分析法中，分析栈用于存储状态，活前缀是指包含当前分析符号且不包含任何后续符号的前缀。活前缀对应DFA状态，用于识别规范句型。解题思路是理解活前缀的定义及其在LR分析中的作用。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06xz01",
      "content": "一个句型中的最左(  )称为该句型的句柄。",
      "type": "single-choice",
      "options": [
        "短语",
        "简单短语",
        "素短语",
        "终结符号"
      ],
      "correct_answer": [
        "简单短语"
      ],
      "analysis": "题目解析：句柄是指句型中最左边的部分，它决定了句型的结构。在给出的选项中，'简单短语'是指由一个词或几个词组成的、结构完整的短语。因此，句柄通常是指句型中的第一个简单短语，它决定了句型的基本结构。解题思路是识别句柄的定义，然后从选项中选择符合定义的答案。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06xz02",
      "content": "设 G是一个给定的文法，S是文法的开始符号，如果 S=>* x(其中 x∈V*),则称 x是文法 G的一个(  )。",
      "type": "single-choice",
      "options": [
        "候选式",
        "句型",
        "单词",
        "产生式"
      ],
      "correct_answer": [
        "句型"
      ],
      "analysis": "题目解析：文法G中的句型是指从开始符号S出发，通过文法规则推导出的所有可能的字符串。'S=>* x'表示从开始符号S出发可以推导出字符串x，因此x是文法G的一个句型。解题思路是理解句型的定义，并将其与题干中的推导关系对应。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06xz03",
      "content": "在自底向上的语法分析方法中，分析的关键是(  )。",
      "type": "single-choice",
      "options": [
        "寻找句柄",
        "寻找句型",
        "消除递归",
        "选择候选式"
      ],
      "correct_answer": [
        "寻找句柄"
      ],
      "analysis": "题目解析：自底向上的语法分析方法中，分析的关键是寻找句柄。句柄是句法分析中用于识别和组合句子的最小单位，通过识别句柄，可以逐步构建出完整的句子结构。解题思路是理解句柄的定义及其在自底向上分析中的作用。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06xz04",
      "content": "在规范归约中，用(  )来刻画可归约串。",
      "type": "single-choice",
      "options": [
        "直接短语",
        "句柄",
        "最左素短语",
        "素短语"
      ],
      "correct_answer": [
        "句柄"
      ],
      "analysis": "题目解析：在规范归约中，句柄是用来刻画可归约串的术语。句柄是语法树中一个特定的节点，它包含了一个句子的核心部分。解题思路是理解规范归约的概念，并识别出句柄在其中的作用。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06xz05",
      "content": "若 a为终结符，则 A ->α• aβ为(  )项目。",
      "type": "single-choice",
      "options": [
        "归约",
        "移进",
        "接受",
        "待约"
      ],
      "correct_answer": [
        "移进"
      ],
      "analysis": "题目解析：在上下文无关文法中，若a为终结符，则A -> α• aβ表示移进项目。移进项目是指预测下一个输入符号是终结符a，并将非终结符A替换为αaβ的过程。解题思路是理解移进的概念，并识别题干中的符号表示。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06xz06",
      "content": "算符优先分析法每次都是对(  )进行归约：",
      "type": "single-choice",
      "options": [
        "句柄",
        "最左素短语",
        "素短语",
        "简单短语"
      ],
      "correct_answer": [
        "最左素短语"
      ],
      "analysis": "算符优先分析法是一种语法分析方法，它通过对文法中的表达式进行归约来分析其结构。题目中提到的归约对象是'最左素短语'，即从表达式的最左侧开始，找到最左边的素短语进行归约。素短语是由单个符号或由符号组成的序列，这些符号在文法规则中是不可进一步分解的。解题思路是识别表达式中的最左素短语，并按照文法规则进行归约，直到整个表达式被归约完成。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06xz07",
      "content": "自底向上语法分析采用(  )分析法，常用的是自底向上语法分析有算符优先分析法和LR分析法。",
      "type": "single-choice",
      "options": [
        "递归",
        "回溯",
        "枚举",
        "移进－归约"
      ],
      "correct_answer": [
        "移进－归约"
      ],
      "analysis": "题目解析：题干中提到的自底向上语法分析是一种解析方法，其中正确答案'移进－归约'是一种自底向上语法分析方法。该方法通过移进（将输入符号读入分析栈）和归约（将分析栈中的符号序列替换为产生式右部）的步骤来构建语法树。解题思路是识别并应用移进－归约规则，直到整个输入被成功解析。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06xz08",
      "content": "在编译程序中，语法分析分为自顶向下分析和自底向上分析两类，()和LR分析法属于自底向上分析。",
      "type": "single-choice",
      "options": [
        "深度分析法",
        "宽度优先分析法",
        "算符优先分析法",
        "递归下降子程序分析法"
      ],
      "correct_answer": [
        "算符优先分析法"
      ],
      "analysis": "题目解析：题干中提到的自底向上分析是指从具体到一般的分析过程，算符优先分析法属于此类。它通过分析输入符号串中的算符优先级来进行语法分析。解题思路是识别输入串中的算符优先级，并据此构建分析树。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06xz09",
      "content": "在编译程序中，语法分析分为自顶向下分析和自底向上分析两类，自底向上分析试图为输入符号串构造一个(  )。",
      "type": "single-choice",
      "options": [
        "语法树",
        "有向无环图",
        "最左推导",
        "最右推导"
      ],
      "correct_answer": [
        "最右推导"
      ],
      "analysis": "题目解析：题干描述了编译程序中的语法分析方法，自底向上分析旨在从输入符号串构造一个推导过程。正确答案'最右推导'是指从输入符号串的末尾开始，逐步向左进行推导，直到构造出整个输入串的过程。该解析解释了题目中的术语'自底向上分析'和'最右推导'，并描述了解题思路。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06xz10",
      "content": "算符优先分析是寻找右句型的(  )。",
      "type": "single-choice",
      "options": [
        "短语；",
        "素短语；",
        "最左素短语；",
        "句柄"
      ],
      "correct_answer": [
        "最左素短语；"
      ],
      "analysis": "题目解析：算符优先分析是一种语法分析方法，用于确定表达式中运算符的优先级。题目中的'右句型'指的是语法分析中的最左素短语，即从左至右第一个非终结符开始，直到遇到第一个终结符为止的短语。解题思路是理解算符优先分析的概念，并识别出题目中的术语'最左素短语'。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06xz11",
      "content": "设有文法G：\n T->T*F | F\nF->F↑P | P\nP->(T) | a\n该文法句型T*P↑(T*F)的最左直接短语是下列符号串(  )",
      "type": "single-choice",
      "options": [
        "(T*F)，",
        "T*F，",
        "P，",
        "P↑(T*F)"
      ],
      "correct_answer": [
        "(T*F)，"
      ],
      "analysis": "题目解析：文法G定义了T、F、P的生成规则。句型T*P↑(T*F)的最左直接短语是指从左至右第一个不可再分解的短语。根据文法，T*F是最左边的不可再分解短语，因此正确答案是'(T*F)，'。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06xz12",
      "content": "在通常的语法分析方法中，(  )特别适用于表达式的分析。",
      "type": "single-choice",
      "options": [
        "算符优先分析法",
        "LR分析法",
        "递归下降分析法",
        "LL(1)分析法"
      ],
      "correct_answer": [
        "算符优先分析法"
      ],
      "analysis": "算符优先分析法是一种语法分析方法，特别适用于表达式的分析。它通过定义算符的优先级和结合性来分析表达式，无需考虑上下文。解题思路是识别表达式中各个算符的优先级，按照优先级顺序进行解析。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06xz13",
      "content": "运算符的优先数之间有几种关系( )。",
      "type": "single-choice",
      "options": [
        "3种",
        "2种",
        "4种",
        "1种"
      ],
      "correct_answer": [
        "3种"
      ],
      "analysis": "题目解析：运算符的优先数关系涉及运算符在表达式中的执行顺序。运算符的优先数分为三种关系：优先级高、优先级低和相同优先级。正确答案为'3种'，意味着存在三种不同的优先级关系。解题思路是理解运算符优先级的概念，并识别出优先级关系的种类。",
      "isBuiltin": true
    },
    {
      "uniqueId": "A06xz14",
      "content": "算符优先法属于（ ）。",
      "type": "single-choice",
      "options": [
        "自上而下分析法",
        "LR分析法",
        "ＳLR分析法",
        "自下而上分析法"
      ],
      "correct_answer": [
        "自下而上分析法"
      ],
      "analysis": "算符优先法是一种分析表达式的方法，它通过从左到右扫描表达式，根据算符的优先级来决定运算顺序。题目中的正确答案'自下而上分析法'描述了算符优先法的基本原理，即从表达式的最内层开始分析，逐步向上分析，直到整个表达式。这种方法不同于自上而下分析法和LR分析法，后者通常用于上下文无关文法分析。",
      "isBuiltin": true
    }
  ],
  "sets": [
    {
      "id": "example-set1",
      "name": "编译原理复习",
      "description": "包含判断题与选择题的示例合集",
      "questionIds": [
        "A01PD01",
        "A01PD02",
        "A01PD03",
        "A01PD04",
        "A01PD05",
        "A01PD06",
        "A01PD07",
        "A01PD08",
        "A01PD09",
        "A01PD10",
        "A01PD11",
        "A01PD12",
        "A01PD13",
        "A01PD14",
        "A01PD15",
        "A01PD16",
        "A01PD17",
        "A01PD18",
        "A02pd01",
        "A02pd02",
        "A02pd03",
        "A02pd04",
        "A02pd05",
        "A02pd06",
        "A02pd07",
        "A02pd08",
        "A02pd09",
        "A02pd10",
        "A02pd11",
        "A02pd12",
        "A02pd13",
        "A02pd14",
        "A02pd15",
        "A03pd01",
        "A03pd02",
        "A03pd03",
        "A03pd04",
        "A03pd05",
        "A03pd06",
        "A03pd07",
        "A03pd08",
        "A03pd09",
        "A03pd10",
        "A03pd11",
        "A03pd12",
        "A03pd13",
        "A03pd14",
        "A03pd15",
        "A04pd01",
        "A04pd02",
        "A04pd03",
        "A04pd04",
        "A04pd05",
        "A04pd06",
        "A04pd07",
        "A04pd08",
        "A05pd01",
        "A05pd02",
        "A05pd03",
        "A05pd04",
        "A05pd05",
        "A05pd06",
        "A05pd07",
        "A05pd08",
        "A05pd09",
        "A05pd10",
        "A05pd11",
        "A05pd12",
        "A05pd13",
        "A05pd14",
        "A05pd15",
        "A05pd16",
        "A05pd17",
        "A05pd18",
        "A05pd19",
        "A06pd01",
        "A06pd02",
        "A06pd03",
        "A06pd04",
        "A06pd05",
        "A06pd06",
        "A06pd07",
        "A06pd08",
        "A06pd09",
        "A06pd10",
        "A06pd11",
        "A06pd12",
        "A06pd13",
        "A06pd14",
        "A06pd15",
        "A06pd16",
        "A06pd17",
        "A01XZ01",
        "A01XZ02",
        "A01XZ03",
        "A01XZ04",
        "A01XZ05",
        "A01XZ06",
        "A01XZ07",
        "A01XZ08",
        "A01XZ09",
        "A01XZ10",
        "A01XZ11",
        "A01XZ12",
        "A01XZ13",
        "A01XZ14",
        "A01XZ15",
        "A01XZ16",
        "A01XZ17",
        "A01XZ18",
        "A01XZ19",
        "A01XZ20",
        "A01XZ21",
        "A01XZ22",
        "A01XZ23",
        "A01XZ24",
        "A02xz01",
        "A02xz02",
        "A02xz03",
        "A02xz04",
        "A02xz05",
        "A02xz06",
        "A02xz07",
        "A02xz08",
        "A02xz09",
        "A02xz10",
        "A02xz11",
        "A02xz12",
        "A02xz13",
        "A02xz14",
        "A02xz15",
        "A03xz01",
        "A03xz02",
        "A03xz03",
        "A03xz04",
        "A03xz05",
        "A03xz06",
        "A03xz07",
        "A03xz08",
        "A03xz09",
        "A03xz10",
        "A03xz11",
        "A03xz12",
        "A03xz13",
        "A03xz14",
        "A03xz15",
        "A03xz16",
        "A03xz17",
        "A04xz01",
        "A04xz02",
        "A04xz03",
        "A04xz04",
        "A04xz05",
        "A05xz01",
        "A05xz02",
        "A05xz03",
        "A05xz04",
        "A05xz05",
        "A05xz06",
        "A05xz07",
        "A05xz08",
        "A05xz09",
        "A05xz10",
        "A05xz11",
        "A05xz12",
        "A05xz13",
        "A05xz14",
        "A05xz15",
        "A05xz16",
        "A05xz17",
        "A06xz01",
        "A06xz02",
        "A06xz03",
        "A06xz04",
        "A06xz05",
        "A06xz06",
        "A06xz07",
        "A06xz08",
        "A06xz09",
        "A06xz10",
        "A06xz11",
        "A06xz12",
        "A06xz13",
        "A06xz14"
      ],
      "isBuiltin": true
    }
  ],
  "schema": {
    "question": {
      "uniqueId": "String (必填，唯一标识符)",
      "content": "String (必填，题目内容，支持Markdown格式)",
      "type": "String (必填，可选值：'single-choice'|'multiple-choice'|'short-answer')",
      "options": "Array<String> (选择题必填，选项列表)",
      "correct_answer": "Array<String> (必填，正确答案列表)",
      "analysis": "String (可选，题目解析，支持Markdown格式)",
      "isBuiltin": "Boolean (可选，是否为内置题目，默认false)"
    },
    "set": {
      "id": "String (必填，唯一标识符)",
      "name": "String (必填，合集名称)",
      "description": "String (可选，合集描述)",
      "questions": "Array<String> (必填，题目ID列表)",
      "isBuiltin": "Boolean (可选，是否为内置合集，默认false)"
    }
  }
}