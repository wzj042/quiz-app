{
  "questions": [
    {
      "uniqueId": "PRO01",
      "content": "一个进程映像是()。",
      "type": "single-choice",
      "options": [
        "由协处理器执行的一个程序",
        "一个独立的程序+数据集",
        "PCB结构与程序和数据的组合",
        "一个独立的程序"
      ],
      "correct_answer": [
        "PCB结构与程序和数据的组合"
      ],
      "analysis": "进程映像是PCB、程序段和数据的组合，其中PCB是进程存在的唯一标志。"
    },
    {
      "uniqueId": "PRO02",
      "content": "进程与程序的根本区别是()。",
      "type": "single-choice",
      "options": [
        "静态和动态特点",
        "是不是被调入内存",
        "是不是具有就绪、运行和等待三种状态",
        "是不是占有处理器"
      ],
      "correct_answer": [
        "静态和动态特点"
      ],
      "analysis": "动态性是进程最重要的特性，以此来区分文件形式的静态程序。操作系统引入进程的概念，是为了从变化的角度动态地分析和研究程序的执行。"
    },
    {
      "uniqueId": "PRO03",
      "content": "操作系统是根据()来对并发执行的进程进行控制和管理的。",
      "type": "single-choice",
      "options": [
        "进程的基本状态",
        "进程控制块",
        "多道程序设计",
        "进程的优先权"
      ],
      "correct_answer": [
        "进程控制块"
      ],
      "analysis": "在进程的整个生命周期中，系统总是通过其PCB对进程进行控制。也就是说，系统是根据进程的PCB而非任何其他因素来感知到进程存在的，PCB是进程存在的唯一标志。同时PCB常驻内存。A和D选项的内容都包含在进程PCB中。"
    },
    {
      "uniqueId": "PRO04",
      "content": "在任何时刻，一个进程的状态变化()引起另一个进程的状态变化。",
      "type": "single-choice",
      "options": [
        "必定",
        "一定不",
        "不一定",
        "不可能"
      ],
      "correct_answer": [
        "不一定"
      ],
      "analysis": "一个进程的状态变化可能会引起另一个进程的状态变化。例如，一个进程时间片用完，可能会引起另一个就绪进程的运行。同时，一个进程的状态变化也可能不会引起另一个进程的状态变化。例如，一个进程由阻塞态转变为就绪态就不会引起其他进程的状态变化。"
    },
    {
      "uniqueId": "PRO05",
      "content": "在单处理器系统中，若同时存在10个进程，则处于就绪队列中的进程最多有()个。",
      "type": "single-choice",
      "options": [
        "1",
        "8",
        "9",
        "10"
      ],
      "correct_answer": [
        "9"
      ],
      "analysis": "不可能出现这样一种情况。单处理器系统的10个进程都处于就绪态，但9个处于就绪态、1个正在运行是可能存在的。还要想到，可能10个进程都处于阻塞态。"
    },
     {
      "uniqueId": "PRO06",
      "content": "一个进程释放了一台打印机，它可能会改变()的状态。",
      "type": "single-choice",
      "options": [
        "自身进程",
        "输入/输出进程",
        "另一个等待打印机的进程",
        "所有等待打印机的进程"
      ],
      "correct_answer": [
        "另一个等待打印机的进程"
      ],
      "analysis": "由于打印机独占资源，当一个进程释放打印机后，另一个等待打印机的进程就可能从阻塞态转到就绪态。\n当然，也存在一个进程执行完毕后由运行态转为结束态时释放打印机的情况，但这并不是由于释放打印机引起的，相反是因为运行完成才释放了打印机。"
    },
     {
      "uniqueId": "PRO07",
      "content": "并发进程失去封闭性，是指()。",
      "type": "single-choice",
      "options": [
        "多个相对独立的进程以各自的速度向前推进",
        "并发进程的执行结果与速度无关",
        "并发进程执行时，在不同时刻发生的错误",
        "并发进程共享变量，其执行结果与速度有关"
      ],
      "correct_answer": [
       "并发进程共享变量，其执行结果与速度有关"
      ],
      "analysis": "程序封闭性是指进程执行的结果只取决于进程本身，不受外界影响。也就是说，进程在执行过程中不管是不停顿地执行，还是走走停停，进程的执行速度都不会改变它的执行结果。失去封闭性后，不同速度下的执行结果不同。"
    },
     {
      "uniqueId": "PRO08",
      "content": "进程在处理器上执行时，()。",
      "type": "single-choice",
      "options": [
       "进程之间是无关的，具有封闭特性",
       "进程之间都有交互性，相互依赖、相互制约，具有并发性",
        "具有并发性，即同时执行的特性",
        "进程之间可能是无关的，但也可能是有交互性的"
      ],
      "correct_answer": [
        "进程之间可能是无关的，但也可能是有交互性的"
      ],
      "analysis": "A和B都说得太绝对，进程之间有可能具有相关性，也有可能是相互独立的。C错在“同时”。"
    },
    {
      "uniqueId": "PRO09",
      "content": "下面的说法中，正确的是()。",
      "type": "single-choice",
      "options": [
        "不论是系统支持的线程还是用户级线程，其切换都需要内核的支持",
        "线程是资源分配的单位，进程是调度和分派的单位",
        "不管系统中是否有线程，进程都是拥有资源的独立单位",
        "在引入线程的系统中，进程仍是资源调度和分派的基本单位"
      ],
      "correct_answer": [
       "不管系统中是否有线程，进程都是拥有资源的独立单位"
      ],
      "analysis": "引入线程后，进程仍然是资源分配的单位。线程是处理器调度和分派的单位，线程本身不具有资源，它可以共享所属进程的全部资源，C对，B、D明显是错的。至于A，可以这样来理解:假如有一个内核进程，它映射到用户级后有多个线程，那么这些线程之间的切换不需要在内核级切换进程，也就不需要内核的支持。"
    },
    {
      "uniqueId": "PRO10",
      "content": "在多对一的线程模型中，当一个多线程进程中的某个线程被阻塞后，()。",
      "type": "single-choice",
      "options": [
       "该进程的其他线程仍可继续运行",
       "整个进程都将阻塞",
       "该阻塞线程将被撤销",
        "该阻塞线程将永远不可能再执行"
      ],
      "correct_answer": [
        "整个进程都将阻塞"
      ],
       "analysis": "在多对一的线程模型中，用户级线程的“多”对操作系统透明，即操作系统并不知道用户有多少线程。因此该进程的一个线程被阻塞后，该进程就被阻塞，进程的其他线程当然也都被阻塞。"
    },
     {
      "uniqueId": "PRO11",
      "content": "进程创建完成后会进入一个序列，这个序列称为()。",
      "type": "single-choice",
      "options": [
       "阻塞队列",
        "挂起序列",
       "就绪队列",
        "运行队列"
      ],
      "correct_answer": [
       "就绪队列"
      ],
       "analysis": "我们先要考虑创建进程的过程，当该进程所需的资源分配完成只等CPU时，进程的状态为就绪态，因此所有的就绪PCB一般以链表方式链成一个序列，称为就绪队列。"
    },
     {
      "uniqueId": "PRO12",
      "content": "进程自身决定()。",
      "type": "single-choice",
      "options": [
       "从运行态到阻塞态",
        "从运行态到就绪态",
        "从就绪态到运行态",
        "从阻塞态到就绪态"
      ],
      "correct_answer": [
        "从运行态到阻塞态"
      ],
       "analysis": "只有从运行态到阻塞态的转换是由进程自身决定的。从运行态到就绪态的转换是由于进程的时间片用完，“主动”调用程序转向就绪态。虽然从就绪态到运行态的转换同样是由调度程序决定的，但进程是“被动的”。从阻塞态到就绪态的转换是由协作进程决定的。"
    },
     {
      "uniqueId": "PRO13",
      "content": "对进程的管理和控制使用()。",
      "type": "single-choice",
      "options": [
       "指令",
        "原语",
        "信号量",
        "信箱"
      ],
      "correct_answer": [
       "原语"
      ],
       "analysis": "对进程的管理和控制功能是通过执行各种原语来实现的，如创建原语等。"
    },
      {
      "uniqueId": "PRO14",
      "content": "下面的叙述中，正确的是()。",
      "type": "single-choice",
      "options": [
       "引入线程后，处理器只能在线程间切换",
       "引入线程后，处理器仍在进程间切换",
        "线程的切换，不会引起进程的切换",
       "线程的切换，可能引起进程的切换"
      ],
      "correct_answer": [
       "线程的切换，可能引起进程的切换"
      ],
      "analysis": "在同一进程中，线程的切换不会引起进程的切换。当从一个进程中的线程切换到另一个进程中的线程时，才会引起进程的切换，因此A、B、C错误。"
    },
       {
      "uniqueId": "PRO15",
      "content": "下列关于进程和线程的叙述中，正确的是()。",
      "type": "single-choice",
      "options": [
        "不管系统是否支持线程，进程都是资源分配的基本单位",
       "线程是资源分配的基本单位，进程是调度的基本单位",
       "系统级线程和用户级线程的切换都需要内核的支持",
        "同一进程中的各个线程拥有各自不同的地址空间"
      ],
      "correct_answer": [
        "不管系统是否支持线程，进程都是资源分配的基本单位"
      ],
       "analysis": "在引入线程后，进程依然是资源分配的基本单位，线程是调度的基本单位，同一进程中的各个线程共享进程的地址空间。在用户级线程中，有关线程管理的所有工作都由应用程序完成，无须内核的干预，内核意识不到线程的存在。"
    },
      {
      "uniqueId": "PRO16",
      "content": "在进程转换时，下列()转换是不可能发生的。",
      "type": "single-choice",
      "options": [
        "就绪态→运行态",
        "运行态→就绪态",
        "运行态→阻塞态",
        "阻塞态→运行态"
      ],
      "correct_answer": [
        "阻塞态→运行态"
      ],
      "analysis": "阻塞的进程在获得所需资源时只能由阻塞态转变为就绪态，并插入就绪队列，而不能直接转变为运行态。"
    },
      {
      "uniqueId": "PRO17",
      "content": "当()时，进程从运行状态转变为就绪态。",
       "type": "single-choice",
      "options": [
        "进程被调度程序选中",
        "时间片到",
        "等待某一事件",
        "等待的事件发生"
      ],
      "correct_answer": [
        "时间片到"
      ],
      "analysis": "当进程的时间片到时，进程由运行态转变为就绪态，等待下一个时间片的到来。"
    },
      {
      "uniqueId": "PRO18",
      "content": "进程处于()时，它处于非阻塞态。",
      "type": "single-choice",
      "options": [
        "等待从键盘输入数据",
        "等待协作进程的一个信号",
        "等待操作系统分配CPU时间",
        "等待网络数据进入内存"
      ],
      "correct_answer": [
        "等待操作系统分配CPU时间"
      ],
      "analysis": "进程有三种基本状态，处于阻塞态的进程由于某个事件不满足而等待。这样的事件一般是/O操作，如键盘等，或是因互斥或同步数据引起的等待，如等待信号或等待进入互斥临界区代码段等，等待网络数据进入内存是为了进程同步。而等待CPU调度的进程处于就绪态，只有它是非阻塞态。"
    },
      {
      "uniqueId": "PRO19",
      "content": "一个进程被唤醒，意味着()。",
       "type": "single-choice",
      "options": [
       "该进程可以重新竞争CPU",
        "优先级变大",
        "PCB移动到就绪队列之首",
        "进程变为运行态"
      ],
      "correct_answer": [
       "该进程可以重新竞争CPU"
      ],
      "analysis": "当一个进程被唤醒时，这个进程就进入了就绪态，等待进程调度而占有CPU运行。进程被唤醒在某种情形下优先级可以增大，但一般不会变为最大，而由固定的算法来计算。也不会在唤醒后位于就绪队列的队首，就绪队列是按照一定的规则赋予其位置的，如先来先服务，或者高优先级优先，或者短进程优先等，更不能直接占有处理器运行。"
    },
      {
      "uniqueId": "PRO20",
      "content": "下列说法中，不正确的是()。",
      "type": "single-choice",
      "options": [
       "一个进程可以创建一个或多个线程",
        "一个线程可以创建一个或多个线程",
        "一个线程可以创建一个或多个进程",
        "一个进程可以创建一个或多个进程"
      ],
      "correct_answer": [
       "一个线程可以创建一个或多个进程"
      ],
      "analysis": "进程可以创建进程或线程，线程也可以创建线程，但线程不能创建进程。"
    },
      {
      "uniqueId": "PRO21",
      "content": "下列对临界区的论述中，正确的是()。",
        "type": "single-choice",
      "options": [
        "临界区是指进程中用于实现进程互斥的那段代码",
        "临界区是指进程中用于实现进程同步的那段代码",
        "临界区是指进程中用于实现进程通信的那段代码",
        "临界区是指进程中用于访问临界资源的那段代码"
      ],
       "correct_answer": [
        "临界区是指进程中用于访问临界资源的那段代码"
      ],
      "analysis": "多个进程可以共享系统中的资源，一次仅允许一个进程使用的资源称为临界资源。访问临界资源的那段代码称为临界区。"
    },
       {
      "uniqueId": "PRO22",
      "content": "若一个信号量的初值为3，经过多次PV操作后当前值为-1，这表示等待进入临界区的进程数是()。",
         "type": "single-choice",
      "options": [
        "1",
        "2",
        "3",
        "4"
      ],
      "correct_answer": [
        "1"
      ],
       "analysis": "信号量是一个特殊的整型变量，只有初始化和PV操作才能改变其值。通常，信号量分为互斥量和资源量，互斥量的初值一般为1，表示临界区只允许一个进程进入，从而实现互斥。当互斥量等于0时，表示临界区已有一个进程进入，临界区外尚无进程等待;当互斥量小于0时，表示临界区中有一个进程，互斥量的绝对值表示在临界区外等待进入的进程数。同理，资源信号量的初值可以是任意整数，表示可用的资源数，当资源量小于0时，表示所有资源已全部用完，而且还有进程正在等待使用该资源，等待的进程数就是资源量的绝对值。"
    },
       {
      "uniqueId": "PRO23",
      "content": "一个正在访问临界资源的进程由于申请等待I/O操作而被中断时，它()。",
      "type": "single-choice",
      "options": [
        "允许其他进程进入与该进程相关的临界区",
        "不允许其他进程进入任何临界区",
        "允许其他进程抢占处理器，但不得进入该进程的临界区",
        "不允许任何进程抢占处理器"
      ],
      "correct_answer": [
        "允许其他进程抢占处理器，但不得进入该进程的临界区"
      ],
       "analysis":"进程进入临界区必须满足互斥条件，当进程进入临界区但尚未离开时就被迫进入阻塞是可以的，系统中经常出现这样的情形。在此状态下，只要其他进程在运行过程中不寻求进入该进程的临界区，就应允许其运行，即分配CPU。该进程所锁定的临界区是不允许其他进程访问的，其他进程若要访问，必定会在临界区的“锁”上阻塞，期待该进程下次运行时可以离开并将临界区交给它。所以正确答案为C。"
    },
      {
      "uniqueId": "PRO24",
      "content": "临界区是指并发进程访问共享变量段的()。",
      "type": "single-choice",
      "options": [
        "管理信息",
        "信息存储",
        "数据",
        "代码程序"
      ],
      "correct_answer": [
        "代码程序"
      ],
      "analysis": "所谓临界区，并不是指临界资源，如共享的数据、代码或硬件设备等，而是指访问临界资源的那段代码程序，如PV操作、加减锁等。操作系统访问临界资源时，关心的是临界区的操作过程，具体对临界资源做何操作是应用程序的事情，操作系统并不关心。"
    },
     {
      "uniqueId": "PRO25",
      "content": "以下不是同步机制应遵循的准则的是()。",
      "type": "single-choice",
      "options": [
        "让权等待",
       "空闲让进",
        "忙则等待",
       "无限等待"
      ],
      "correct_answer": [
        "无限等待"
      ],
      "analysis": "同步机制的4个准则是空闲让进、忙则等待、让权等待和有限等待。"
    },
     {
      "uniqueId": "PRO26",
      "content": "以下()不属于临界资源。",
      "type": "single-choice",
      "options": [
        "打印机",
        "非共享数据",
        "共享变量",
        "共享缓冲区"
      ],
      "correct_answer": [
        "非共享数据"
      ],
      "analysis": "临界资源是互斥共享资源，非共享数据不属于临界资源。打印机、共享变量和共享缓冲区都只允许一次供一个进程使用。"
    },
    {
      "uniqueId": "PRO27",
      "content": "在操作系统中，要对并发进程进行同步的原因是()。",
      "type": "single-choice",
      "options": [
        "进程必须在有限的时间内完成",
        "进程具有动态性",
        "并发进程是异步的",
        "进程具有结构性"
      ],
       "correct_answer": [
        "并发进程是异步的"
      ],
      "analysis": "进程同步是指进程之间一种直接的协同工作关系，这些进程的并发是异步的，它们相互合作，共同完成一项任务。"
    },
     {
      "uniqueId": "PRO28",
      "content": "进程A和进程B通过共享缓冲区协作完成数据处理，进程A负责产生数据并放入缓冲区，进程B从缓冲区读数据并输出。进程A和进程B之间的制约关系是()。",
      "type": "single-choice",
      "options": [
        "互斥关系",
        "同步关系",
       "互斥和同步关系",
       "无制约关系"
      ],
      "correct_answer": [
        "互斥和同步关系"
      ],
      "analysis": "并发进程因为共享资源而产生相互之间的制约关系，可以分为两类:①互斥关系，指进程之间因相互竞争使用独占型资源(互斥资源)所产生的制约关系;②同步关系，指进程之间为协同工作需要交换信息、相互等待而产生的制约关系。本题中两个进程之间的制约关系是同步关系，进程B必须在进程A将数据放入缓冲区后才能从缓冲区中读出数据。此外，共享的缓冲区一定是互斥访问的，所以它们也具有互斥关系。"
    },
    {
      "uniqueId": "PRO29",
      "content": "P操作可能导致()。",
      "type": "single-choice",
      "options": [
       "进程就绪",
        "进程结束",
       "进程阻塞",
        "新进程创建"
      ],
       "correct_answer": [
       "进程阻塞"
      ],
      "analysis": "P操作即wit操作，表示等待某种资源直到可用。若这种资源暂时不可用，则进程进入阻塞态。注意，执行P操作时的进程处于运行态。"
    },
     {
      "uniqueId": "PRO30",
      "content": "用V操作唤醒一个等待进程时，被唤醒进程变为()态。",
      "type": "single-choice",
      "options": [
       "运行",
        "等待",
       "就绪",
        "完成"
      ],
      "correct_answer": [
        "就绪"
      ],
      "analysis": "只有就绪进程能获得处理器资源，被唤醒的进程并不能直接转换为运行态。"
    },
      {
      "uniqueId": "PRO31",
      "content": "在用信号量机制实现互斥时，互斥信号量的初值为()。",
      "type": "single-choice",
      "options": [
        "0",
        "1",
       "2",
        "3"
      ],
      "correct_answer": [
       "1"
      ],
       "analysis": "互斥信号量的初值为1，P操作成功则将其减1，禁止其他进程进入;V操作成功则将其加1，允许等待队列中的一个进程进入。"
    },
      {
      "uniqueId": "PRO32",
      "content": "用P，V操作实现进程同步，信号量的初值为()。",
      "type": "single-choice",
      "options": [
       "-1",
       "0",
       "1",
        "由用户确定"
      ],
        "correct_answer": [
       "由用户确定"
      ],
      "analysis": "与互斥信号量初值一般为1时不同，用P，V操作实现进程同步，信号量的初值应根据具体情况来确定。若期望的消息尚未产生，则对应的初值应为0若期望的消息已存在，则信号量的初值应设为一个非0的正整数。"
    },
    {
      "uniqueId": "PRO33",
      "content": "对于两个并发进程，设互斥信号量为mutex(初值为1)，若mutex=0，则()。",
      "type": "single-choice",
      "options": [
       "表示没有进程进入临界区",
        "表示有一个进程进入临界区",
       "表示有一个进程进入临界区，另一个进程等待进入",
       "表示有两个进程进入临界区"
      ],
       "correct_answer": [
       "表示有一个进程进入临界区"
      ],
       "analysis": "临界区不允许两个进程同时进入，D选项明显错误。mutex的初值为1，表示允许一个进程进入临界区，当有一个进程进入临界区且没有进程等待进入时，mutex减1，变为0。"
    },
    {
      "uniqueId": "PRO34",
      "content": "对于两个并发进程，设互斥信号量为mutex(初值为1)，若mutex= -1，则()。",
        "type": "single-choice",
      "options": [
        "表示没有进程进入临界区",
        "表示有一个进程进入临界区",
        "表示有一个进程进入临界区，另一个进程等待进入",
        "表示有两个进程进入临界区"
      ],
      "correct_answer": [
        "表示有一个进程进入临界区，另一个进程等待进入"
      ],
      "analysis": "当有一个进程进入临界区且有另一个进程等待进入临界区时，mutex=-1。mutex小于0时，其绝对值等于等待进入临界区的进程数。"
    }
  ],
  "sets": [
    {
      "id": "process_set",
      "name": "操作系统进程第二章-同步选择题",
       "description": "操作系统进程同步选择题",
      "questionIds": [
        "PRO01",
        "PRO02",
        "PRO03",
        "PRO04",
        "PRO05",
        "PRO06",
        "PRO07",
        "PRO08",
         "PRO09",
        "PRO10",
        "PRO11",
        "PRO12",
        "PRO13",
        "PRO14",
        "PRO15",
         "PRO16",
        "PRO17",
        "PRO18",
        "PRO19",
        "PRO20",
         "PRO21",
         "PRO22",
         "PRO23",
         "PRO24",
        "PRO25",
        "PRO26",
        "PRO27",
        "PRO28",
          "PRO29",
         "PRO30",
         "PRO31",
         "PRO32",
          "PRO33",
           "PRO34"
      ]
    }
  ]
}