{
  "questions": [
    {
      "uniqueId": "DL01",
      "content": "下列情况中，可能导致死锁的是()。",
      "type": "single-choice",
      "options": [
        "进程释放资源",
        "一个进程进入死循环",
        "多个进程竞争资源出现了循环等待",
        "多个进程竞争使用共享型的设备"
      ],
      "correct_answer": [
        "多个进程竞争资源出现了循环等待"
      ],
      "analysis": "引起死锁的4个必要条件是:互斥、占有并等待、非剥夺和循环等待。本题中，出现了循环等待的现象，意味着可能会导致死锁。进程释放资源不会导致死锁，进程自己进入死循环只能产生“饥饿”，不涉及其他进程。共享型设备允许多个进程申请使用，因此不会造成死锁。再次提醒，死锁一定要有两个或两个以上的进程才会导致，而饥饿可能由一个进程导致。"
    },
    {
      "uniqueId": "DL02",
      "content": "在操作系统中，死锁出现是指()。",
      "type": "single-choice",
      "options": [
        "计算机系统发生重大故障",
        "资源个数远远小于进程数",
        "若干进程因竞争资源而无限等待其他进程释放已占有的资源",
        "进程同时申请的资源数超过资源总数"
      ],
      "correct_answer": [
        "若干进程因竞争资源而无限等待其他进程释放已占有的资源"
      ],
      "analysis": "死锁是指多个进程因竞争系统资源或相互通信而处于永久阻塞态，若无外力作用，这些进程都将无法推进。"
    },
    {
      "uniqueId": "DL03",
      "content": "一次分配所有资源的方法可以预防死锁的发生，它破坏死锁4个必要条件中的()。",
      "type": "single-choice",
      "options": [
        "互斥",
        "占有并请求",
        "非剥夺",
        "循环等待"
      ],
      "correct_answer": [
        "占有并请求"
      ],
      "analysis": "发生死锁的4个必要条件:互斥、占有并请求、非剥夺和循环等待。一次分配所有资源的方法是当进程需要资源时，一次性提出所有的请求，若请求的所有资源均满足则分配，只要有一项不满足，就不分配任何资源，该进程阻塞，直到所有的资源空闲后，满足进程的所有需求时再分配。这种分配方式不会部分地占有资源，因此打破了死锁的4个必要条件之一，实现了对死锁的预防。但是，这种分配方式需要凑齐所有资源，因此当一个进程所需的资源较多时，资源的利用率会较低，甚至会造成进程“饥饿”。"
    },
    {
      "uniqueId": "DL04",
      "content": "系统产生死锁的可能原因是()。",
      "type": "single-choice",
      "options": [
        "独占资源分配不当",
        "系统资源不足",
        "进程运行太快",
        "CPU内核太多"
      ],
      "correct_answer": [
        "独占资源分配不当"
      ],
      "analysis": "系统死锁的可能原因主要是时间上和空间上的。时间上由于进程运行中推进顺序不当，即调度时机不合适，不该切换进程时进行了切换，可能会造成死锁;空间上的原因是对独占资源分配不当，互斥资源部分分配又不可剥夺，极易造成死锁。那么，为什么系统资源不足不是造成死锁的原因呢?系统资源不足只会对进程造成“饥饿”。例如，某系统只有三台打印机，若进程运行中要申请四台，显然不能满足，该进程会永远等待下去。若该进程在创建时便声明需要四台打印机，则操作系统立即就会拒绝，这实际上是资源分配不当的一种表现。不能以系统资源不足来描述剩余资源不足的情形。"
    },
    {
      "uniqueId": "DL05",
      "content": "死锁的避免是根据()采取措施实现的。",
      "type": "single-choice",
      "options": [
        "配置足够的系统资源",
        "使进程的推进顺序合理",
        "破坏死锁的四个必要条件之一",
        "防止系统进入不安全状态"
      ],
      "correct_answer": [
        "防止系统进入不安全状态"
      ],
      "analysis": "死锁避免是指在资源动态分配过程中用某些算法加以限制，防止系统进入不安全状态从而避免死锁的发生。选项B是避免死锁后的结果，而不是措施的原理。"
    },
    {
      "uniqueId": "DL06",
      "content": "死锁预防是保证系统不进入死锁状态的静态策略，其解决办法是破坏产生死锁的四个必要条件之一。下列方法中破坏了“循环等待”条件的是()。",
      "type": "single-choice",
      "options": [
        "银行家算法",
        "一次性分配策略",
        "剥夺资源法",
        "资源有序分配策略"
      ],
      "correct_answer": [
        "资源有序分配策略"
      ],
      "analysis": "资源有序分配策略可以限制循环等待条件的发生。选项A判断是否为不安全状态;选项B破坏了占有请求条件;选项C破坏了非剥夺条件。"
    },
    {
      "uniqueId": "DL07",
      "content": "解除死锁通常不采用的方法是()。",
      "type": "single-choice",
      "options": [
        "终止一个死锁进程",
        "终止所有死锁进程",
        "从死锁进程处抢夺资源",
        "从非死锁进程处抢夺资源"
      ],
      "correct_answer": [
        "从非死锁进程处抢夺资源"
      ],
      "analysis": "解除死锁的方法有，①剥夺资源法:挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程;②撤销进程法:强制撤销部分甚至全部死锁进程并剥夺这些进程的资源。②回退执行法:让某个占有必要资源的进程回退到它取得其他资源之前的一个检查点。"
    },
    {
      "uniqueId": "DL08",
      "content": "采用资源剥夺法可以解除死锁，还可以采用()方法解除死锁。",
      "type": "single-choice",
      "options": [
        "执行并行操作",
        "撤销进程",
        "拒绝分配新资源",
        "修改信号量"
      ],
      "correct_answer": [
        "撤销进程"
      ],
      "analysis": "资源剥夺法允许一个进程强行剥夺其他进程所占有的系统资源。而撤销进程强行释放一个进程已占有的系统资源，与资源剥夺法同理，都通过破坏死锁的“请求和保持”条件来解除死锁。\n拒绝分配新资源只能维持死锁的现状，无法解除死锁。"
    },
    {
      "uniqueId": "DL09",
      "content": "在下列死锁的解决方法中，属于死锁预防策略的是()。",
      "type": "single-choice",
      "options": [
        "银行家算法",
        "资源有序分配算法",
        "死锁检测算法",
        "资源分配图化简法"
      ],
      "correct_answer": [
        "资源有序分配算法"
      ],
      "analysis": "其中，银行家算法为死锁避免算法，死锁检测算法和资源分配图化简法为死锁检测，根据排除法可以得出资源有序分配算法为死锁预防策略。"
    },
    {
      "uniqueId": "DL10",
      "content": "以下有关资源分配图的描述中，正确的是()。",
      "type": "single-choice",
      "options": [
        "有向边包括进程指向资源类的分配边和资源类指向进程申请边两类",
        "矩形框表示进程，其中圆，点表示申请同一类资源的各个进程",
        "圆圈结点表示资源类",
        "资源分配图是一个有向图，用于表示某时刻系统资源与进程之间的状态"
      ],
      "correct_answer": [
        "资源分配图是一个有向图，用于表示某时刻系统资源与进程之间的状态"
      ],
      "analysis": "进程指向资源的有向边称为申请边，资源指向进程的有向边称为分配边，A选项张冠李戴;矩形框表示资源，其中的圆点表示资源的数目，选项B错:圆圈结点表示进程，选项C错;选项D的说法是正确的。"
    },
    {
      "uniqueId": "DL11",
      "content": "死锁的四个必要条件中，无法破坏的是()。",
      "type": "single-choice",
      "options": [
        "环路等待资源",
        "互斥使用资源",
        "占有且等待资源",
        "非抢夺式分配"
      ],
      "correct_answer": [
        "互斥使用资源"
      ],
      "analysis": "所谓破坏互斥使用资源，是指允许多个进程同时访问资源，但有些资源根本不能同时访问，如打印机只能互斥使用。因此，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。其他三个条件都可以实现。"
    },
    {
      "uniqueId": "DL12",
      "content": "死锁与安全状态的关系是()。",
      "type": "single-choice",
      "options": [
        "死锁状态有可能是安全状态",
        "安全状态有可能成为死锁状态",
        "不安全状态就是死锁状态",
        "死锁状态一定是不安全状态"
      ],
      "correct_answer": [
        "死锁状态一定是不安全状态"
      ],
      "analysis": "如右图所示，并非所有不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态;反之，只要系统处于安全状态，系统便可避免进入死锁状态:死锁状态必定是不安全状态。"
    },
    {
      "uniqueId": "DL13",
      "content": "系统的资源分配图在下列情况下，无法判断是否处于死锁状态的有（）。\n\nI.出现了环路\n\nⅡ.没有环路\n\nⅢ.每种资源只有一个，并出现环路\n\nIV.每个进程结点至少有一条请求边",
      "type": "single-choice",
      "options": [
        "I、Ⅱ、Ⅲ、V",
        "I、II、IV",
        "I、IV",
        "以上答案都不正确"
      ],
      "correct_answer": [
        "I、IV"
      ],
      "analysis": "出现了环路，只是满足了循环等待的必要条件，而满足必要条件不一定会导致死锁，I对;没有环路，破坏了循环等待条件，一定不会发生死锁，Ⅱ错;每种资源只有一个，又出现了环路，这是死锁的充分条件，可以确定是否有死锁，Ⅱ错;即使每个进程至少有一条请求边，若资源足够，则不会发生死锁，但若资源不充足，则有发生死锁的可能，V对。\n综上所述，选择C选项。"
    },
    {
      "uniqueId": "DL14",
      "content": "下列关于死锁的说法中，正确的有（）。\n\nI.死锁状态一定是不安全状态\n\nII.产生死锁的根本原因是系统资源分配不足和进程推进顺序非法\n\nⅢ.资源的有序分配策略可以破坏死锁的循环等待条件\n\nIV.采用资源剥夺法可以解除死锁，还可以采用撤销进程方法解除死锁",
      "type": "single-choice",
      "options": [
        "I、III",
        "II",
        "IV",
        "四个说法都对"
      ],
      "correct_answer": [
        "四个说法都对"
      ],
      "analysis": "I正确：见答案解析图。Ⅱ正确：这是产生死锁的两大原因。Ⅲ正确：在对资源进行有序分配时，进程间不可能出现环形链，即不会出现循环等待。\nV正确：资源剥夺法允许一个进程强行剥夺其他进程占有的系统资源。而撤销进程强行释放一个进程已占有的系统资源，与资源剥夺法同理，都通过破坏死锁的“请求和保持”条件来解除死锁，所以选择D选项。"
    },
    {
      "uniqueId": "DL15",
      "content": "一个进程在获得资源后，只能在使用完资源后由自己释放，这属于死锁必要条件的()。",
      "type": "single-choice",
      "options": [
        "互斥条件",
        "请求和释放条件",
        "不剥夺条件",
        "防止系统进入不安全状态"
      ],
      "correct_answer": [
        "不剥夺条件"
      ],
      "analysis": "一个进程在获得资源后，只能在使用完资源后由自己释放，即它的资源不能被系统剥夺，答案为C选项。"
    },
    {
      "uniqueId": "DL16",
      "content": "下列关于银行家算法的叙述中，正确的是()。",
      "type": "single-choice",
      "options": [
        "银行家算法可以预防死锁",
        "当系统处于安全状态时，系统中一定无死锁进程",
        "当系统处于不安全状态时，系统中一定会出现死锁进程",
        "银行家算法破坏了死锁必要条件中的“请求和保持”条件"
      ],
      "correct_answer": [
        "当系统处于安全状态时，系统中一定无死锁进程"
      ],
      "analysis": "银行家算法是避免死锁的方法，选项A、D错。"
    },
    {
      "uniqueId": "DL17",
      "content": "假设5个进程Po，P1，P2，P3，P4共享三类资源R，R2，R3，这些资源总数分别为18，6，22。T时刻的资源分配情况如下表所示，此时存在的一个安全序列是\n\n<table border='1'><thead><tr><th>进程</th><th>已分配资源R<sub>1</sub></th><th>已分配资源R<sub>2</sub></th><th>已分配资源R<sub>3</sub></th><th>资源最大需求R<sub>1</sub></th><th>资源最大需求R<sub>2</sub></th><th>资源最大需求R<sub>3</sub></th></tr></thead><tbody><tr><td>P<sub>0</sub></td><td>3</td><td>2</td><td>3</td><td>5</td><td>5</td><td>10</td></tr><tr><td>P<sub>1</sub></td><td>4</td><td>0</td><td>3</td><td>5</td><td>3</td><td>6</td></tr><tr><td>P<sub>2</sub></td><td>4</td><td>0</td><td>5</td><td>4</td><td>0</td><td>11</td></tr><tr><td>P<sub>3</sub></td><td>2</td><td>0</td><td>4</td><td>4</td><td>2</td><td>5</td></tr><tr><td>P<sub>4</sub></td><td>3</td><td>1</td><td>4</td><td>4</td><td>2</td><td>4</td></tr></tbody></table>",
      "type": "single-choice",
      "options": [
        "P0,P2,P4;P1,P3",
        "P1; P0,P3,P4;P2",
        "P2,P1, P0;P3,P4",
        "P3,P4;P2,P1; P0"
      ],
      "correct_answer": [
        "P3,P4;P2,P1; P0"
      ],
      "analysis": "首先求得各进程的需求矩阵Need与可利用资源向量Available:\n\n<table border='1'><thead><tr><th>进程</th><th>Need R<sub>1</sub></th><th>Need R<sub>2</sub></th><th>Need R<sub>3</sub></th></tr></thead><tbody><tr><td>P<sub>0</sub></td><td>2</td><td>3</td><td>7</td></tr><tr><td>P<sub>1</sub></td><td>1</td><td>3</td><td>3</td></tr><tr><td>P<sub>2</sub></td><td>0</td><td>0</td><td>6</td></tr><tr><td>P<sub>3</sub></td><td>2</td><td>2</td><td>1</td></tr><tr><td>P<sub>4</sub></td><td>1</td><td>1</td><td>0</td></tr></tbody></table>\n\n<table border='1'><thead><tr><th>Available</th><th>R<sub>1</sub></th><th>R<sub>2</sub></th><th>R<sub>3</sub></th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table>\n\n比较Need和Available发现，初始时进程P1与P3可满足需求，排除A、C。尝试给P1分配资源时，P1完成后Available将变为(6，3，6)，无法满足Po的需求，排除B。尝试给P3分配资源时，P3完成后Available将变为(4，3，7)，该向量能满足其他所有进程的需求。因此，以P3开头的所有序列都是安全序列。"
    },
    {
      "uniqueId": "DL18",
      "content": "系统的资源分配图在下列情况下，无法判断是否处于死锁状态的有（）。\n\nI.出现了环路\n\nⅡ.没有环路\n\nⅢ.每种资源只有一个，并出现环路\n\nIV.每个进程结点至少有一条请求边",
      "type": "single-choice",
      "options": [
        "I、Ⅱ、I、V",
        "I、II、IV",
        "I、IV",
        "以上答案都不正确"
      ],
      "correct_answer": [
        "I、IV"
      ],
      "analysis": "出现了环路，只是满足了循环等待的必要条件，而满足必要条件不一定会导致死锁，I对；没有环路，破坏了循环等待条件，一定不会发生死锁，Ⅱ错；每种资源只有一个，又出现了环路，这是死锁的充分条件，可以确定是否有死锁，Ⅱ错；即使每个进程至少有一条请求边，若资源足够，则不会发生死锁，但若资源不充足，则有发生死锁的可能，V对。综上所述，选择C选项。"
    },
    {
      "uniqueId": "DL19",
      "content": "下列关于死锁的说法中，正确的有（）。\n\nI.死锁状态一定是不安全状态\n\nⅡ.产生死锁的根本原因是系统资源分配不足和进程推进顺序非法\n\n|||.资源的有序分配策略可以破坏死锁的循环等待条件\n\nIV.采用资源剥夺法可以解除死锁，还可以采用撤销进程方法解除死锁",
      "type": "single-choice",
      "options": [
        "I、|||",
        "II",
        "IV",
        "四个说法都对"
      ],
      "correct_answer": [
        "四个说法都对"
      ],
      "analysis": "I正确：见答案解析图。Ⅱ正确：这是产生死锁的两大原因。Ⅲ正确：在对资源进行有序分配时，进程间不可能出现环形链，即不会出现循环等待。V正确：资源剥夺法允许一个进程强行剥夺其他进程占有的系统资源。而撤销进程强行释放一个进程已占有的系统资源，与资源剥夺法同理，都通过破坏死锁的“请求和保持”条件来解除死锁，所以选择D选项。"
    },
    {
      "uniqueId": "DL20",
      "content": "某系统中有A、B两类资源各6个，t时刻资源分配及需求情况如下表所示\n\n<table border='1'><thead><tr><th>进程</th><th>A已分配数量</th><th>B已分配数量</th><th>A需求总量</th><th>B需求总量</th></tr></thead><tbody><tr><td>P<sub>1</sub></td><td>2</td><td>3</td><td>4</td><td>4</td></tr><tr><td>P<sub>2</sub></td><td>2</td><td>1</td><td>3</td><td>1</td></tr><tr><td>P<sub>3</sub></td><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table>\n\nt时刻安全性检测结果是（）。",
      "type": "single-choice",
      "options": [
        "存在安全序列P1、P2、P3",
        "存在安全序列P2、P1、P3",
        "存在安全序列P2、P3、P1",
        "不存在安全序列"
      ],
      "correct_answer": [
        "存在安全序列P2、P1、P3"
      ],
      "analysis": "首先求出需求矩阵：\n\n<table border='1'><thead><tr><th></th><th>A</th><th>B</th></tr></thead><tbody><tr><td>Need = Max - Allocation =</td><td><table border='1'><tbody><tr><td>4</td><td>4</td></tr><tr><td>3</td><td>1</td></tr><tr><td>3</td><td>4</td></tr></tbody></table>-</td><td><table border='1'><tbody><tr><td>2</td><td>3</td></tr><tr><td>2</td><td>1</td></tr><tr><td>1</td><td>2</td></tr></tbody></table></td><td>=<table border='1'><tbody><tr><td>2</td><td>1</td></tr><tr><td>1</td><td>0</td></tr><tr><td>2</td><td>2</td></tr></tbody></table></td></tr></tbody></table>\n\n由Allocation得知当前Available为（1，0）。由需求矩阵可知，初始只能满足P2的需求。P2释放资源后Available变为(3，1)，此时仅能满足P1的需求。C错误。P1释放资源后Available变为（5，4），可以满足P3的需求，得到的安全序列为P2，P1，P3，B正确，D错误。"
    }
  ],
  "sets": [
    {
      "id": "deadlock_set",
      "name": "操作系统死锁选择题",
      "description": "操作系统死锁选择题",
      "questionIds": [
        "DL01",
        "DL02",
        "DL03",
        "DL04",
        "DL05",
        "DL06",
        "DL07",
        "DL08",
        "DL09",
        "DL10",
        "DL11",
        "DL12",
        "DL13",
        "DL14",
        "DL15",
        "DL16",
        "DL17",
        "DL18",
        "DL19",
        "DL20"
      ]
    }
  ]
}