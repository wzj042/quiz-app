<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <title>刷题</title>
    <meta name="referrer" content="no-referrer">
    <link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/katex.min.css">
    <script defer src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/katex.min.js"></script>
    <script defer src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/contrib/auto-render.min.js"></script>
    <script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vue/3.2.23/vue.global.prod.min.js"></script>
    <script src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/marked/4.0.2/marked.min.js"></script>
    <link rel="stylesheet" href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css">
    <!-- 添加 highlight.js -->
    <link href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/highlight.js/11.4.0/styles/qtcreator-light.min.css" type="text/css" rel="stylesheet" />
    <script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/highlight.js/11.4.0/highlight.min.js" type="application/javascript"></script>
    <!-- 添加 SQL 语言支持 -->
    <script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/highlight.js/11.4.0/languages/sql.min.js" type="application/javascript"></script>

    <!-- 配置 marked 和 highlight.js -->
    <script>
        // 配置 marked 的代码高亮
        marked.setOptions({
            highlight: function(code, lang) {
                if (lang) {
                    try {
                        const highlighted = hljs.highlight(code, {
                            language: lang.toLowerCase(),
                            ignoreIllegals: true
                        }).value;
                        return `<pre data-language="${lang}"><code class="hljs language-${lang}">${highlighted}</code></pre>`;
                    } catch (e) {
                        console.warn('Language highlight failed:', e);
                        return `<pre data-language="${lang}"><code class="hljs">${hljs.highlightAuto(code).value}</code></pre>`;
                    }
                }
                return `<pre><code class="hljs">${hljs.highlightAuto(code).value}</code></pre>`;
            },
            breaks: true,
            gfm: true
        });
    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/mobile.css?v=_timestamp_">
    <link rel="icon" href="favicon.ico?v=_timestamp_" type="image/x-icon">
    <script>
        // 动态加载 JS 模块，使用时间戳防止缓存
        window.addEventListener('DOMContentLoaded', function() {
            const timestamp = Date.now();  // 使用时间戳确保每次加载最新资源
            const modules = [
                'js/modules/DataManager.js',
                'js/modules/jsonLoader.js',
                'js/modules/keyboard.js',
                'js/modules/PracticeManager.js',
                'js/modules/ProgressManager.js',
                'js/modules/QuestionManager.js',
                'js/modules/storage.js'
            ];
            
            // 更新 CSS 和 favicon 的时间戳
            document.querySelector('link[href*="mobile.css"]').href = `css/mobile.css?v=${timestamp}`;
            document.querySelector('link[rel="icon"]').href = `favicon.ico?v=${timestamp}`;
            
            // 动态加载 JS 模块
            modules.forEach(module => {
                const script = document.createElement('script');
                script.type = 'module';
                script.src = `${module}?v=${timestamp}`;
                document.head.appendChild(script);
            });

            // 添加键盘快捷键支持
            const handleKeydown = (e) => {
                // 如果正在输入，不处理快捷键
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }

                // T: 打开标签筛选
                if (e.key === 't' && !e.ctrlKey && !e.altKey && !e.shiftKey) {
                    e.preventDefault();
                    const tagsButton = document.querySelector('.tags-button');
                    if (tagsButton) tagsButton.click();
                }

                // Esc: 关闭模态窗口
                if (e.key === 'Escape') {
                    const modalOverlay = document.querySelector('.modal-overlay');
                    if (modalOverlay) {
                        const closeBtn = modalOverlay.querySelector('.close-btn');
                        if (closeBtn) closeBtn.click();
                    }
                }

                // Ctrl + S: 导出修改
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    const exportBtn = document.querySelector('.export-btn');
                    if (exportBtn) exportBtn.click();
                }
            };

            document.addEventListener('keydown', handleKeydown);

            // 初始化焦点管理
            initFocusManagement();
        });

        function initFocusManagement() {
            // 模态窗口焦点管理
            const modalOverlay = document.querySelector('.modal-overlay');
            if (modalOverlay) {
                const focusableElements = modalOverlay.querySelectorAll(
                    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                );
                const firstFocusable = focusableElements[0];
                const lastFocusable = focusableElements[focusableElements.length - 1];
                // 焦点循环
                modalOverlay.addEventListener('keydown', function(e) {
                    if (e.key === 'Tab') {
                        if (e.shiftKey) {
                            if (document.activeElement === firstFocusable) {
                                e.preventDefault();
                                lastFocusable.focus();
                            }
                        } else {
                            if (document.activeElement === lastFocusable) {
                                e.preventDefault();
                                firstFocusable.focus();
                            }
                        }
                    }
                });
            }
        }
    </script>
</head>
<body>
<div id="app" class="container">
    <!-- 导航栏 -->
    <nav class="nav" role="navigation">
        <a href="#" 
           class="nav-title-link" 
           @click="goHome" 
           @mouseover="hoverTitle = true" 
           @mouseout="hoverTitle = false">
            <span class="nav-title">Quiz App</span>
        </a>
        <a href="https://github.com/wzj042/quiz-app" 
           class="github-link" 
           target="_blank" 
           rel="noopener noreferrer" 
           aria-label="在 GitHub 上查看项目"
           title="项目调试中，欢迎参与开发和反馈。可参考 demo.json 格式，Fork 项目后添加自己的题库。">
            <svg class="github-icon" viewBox="0 0 16 16" width="24" height="24" aria-hidden="true">
                <path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
            </svg>
        </a>
    </nav>

    <!-- 未保存修改的模态窗口 -->
    <div v-if="showUnsavedModal" 
         class="modal-overlay" 
         @click.self="closeUnsavedModal"
         role="dialog"
         aria-labelledby="unsaved-modal-title"
         aria-modal="true"
         @keydown.esc="closeUnsavedModal">
        <div class="modal-content" tabindex="-1">
            <h3 id="unsaved-modal-title">未导出的修改</h3>
            <div class="modal-body">
                <p>当前题库有未导出的修改：</p>
                <div class="modified-questions-list" role="list">
                    <ul>
                        <li v-for="q in groupedModifiedQuestions" 
                            :key="q.uniqueId"
                            role="listitem">
                            题目ID: {{ q.uniqueId }}
                            <br>
                            <span class="question-preview">{{ truncateText(q.content, 50) }}</span>
                        </li>
                    </ul>
                </div>
                <div class="modal-actions">
                    <div class="modal-actions">
                        <div class="action-buttons">
                            <button class="btn export-btn" 
                                    @click="exportModifiedData"
                                    data-shortcut="Ctrl+S">
                                导出修改
                            </button>
                            <button class="btn close-btn" 
                                    @click="closeUnsavedModalAndContinue"
                                    data-shortcut="Esc">
                                直接退出
                            </button>
                        </div>
                        <label class="dont-show-again">
                            <input type="checkbox" 
                                   v-model="dontShowExportReminder"
                                   @keydown.enter="$event.target.click()">
                            <span>不再提醒</span>
                        </label>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 列出题库 -->
    <div v-if="isLoading" class="card" role="status">
        <p>正在处理，请稍后...</p>
    </div>

    <template v-else>
        <div v-if="pageState === 'home'" class="card">
            <h1 class="title">
                选择题库
                <span class="update-time" v-if="updateTime">更新于: {{ formatUpdateTime(updateTime) }}</span>
            </h1>

            <!-- 总体统计 -->
            <div class="overall-stats" role="region" aria-label="总体统计">
                <h2 class="stats-title">总体统计</h2>
                <div class="stats-grid">
                    <div class="stats-item">
                        <div class="stats-value">{{ totalStats.completedQuestions }}/{{ totalStats.totalAttempts }}</div>
                        <div class="stats-label">总练习题数</div>
                    </div>
                    <div class="stats-item">
                        <div class="stats-value">{{ totalStats.averageAccuracy }}%</div>
                        <div class="stats-label">平均正确率</div>
                    </div>
                    <div class="stats-item">
                        <div class="stats-value">{{ totalStats.todayPracticed }}</div>
                        <div class="stats-label">今日已练习</div>
                    </div>
                </div>
                <button class="cross-practice-btn" @click="showCrossPracticeModal = true">
                    <i class="fas fa-random"></i>
                    跨卷练习设置
                </button>
            </div>

            <!-- 题库列表 -->
            <template v-if="fileList.length > 0">
                <ul class="horizontal-list" role="list">
                    <!-- Tags筛选器 -->
                    <div class="tags-filter" role="region" aria-label="标签筛选">
                        <div class="top-tags">
                            <button v-for="tag in topTags" 
                                    :key="tag.tag"
                                    :class="['tag-chip', { active: selectedTags.includes(tag.tag) }]"
                                    @click="toggleTag(tag.tag)"
                                    :aria-pressed="selectedTags.includes(tag.tag)"
                                    :aria-label="'选择标签: ' + tag.tag">
                                {{ tag.tag }}
                                <span v-if="selectedTags.includes(tag.tag)" class="tag-count">({{ tag.count }})</span>
                            </button>
                        </div>
                        <button :class="['tags-button', { 'has-active': selectedTags.length > 0 }]" 
                                @click="showTagsModal = true"
                                aria-label="更多标签"
                                data-shortcut="T">
                            <i class="fas fa-tags" aria-hidden="true"></i>
                        </button>
                    </div>

                    <template v-for="(group, groupIndex) in filteredGroupedFileList" :key="groupIndex">
                        <li class="category-header" role="separator">
                            <h2>{{ group[0] }}</h2>
                            <hr>
                        </li>
                        <li v-for="(fileObj, idx) in group[1]"
                            :key="idx"
                            class="quiz-item"
                            role="button"
                            tabindex="0"
                            @click="loadJsonFile(fileObj.file)"
                            @keydown.enter="loadJsonFile(fileObj.file)"
                            @keydown.space.prevent="loadJsonFile(fileObj.file)">
                            <div class="quiz-item-content">
                                <div class="quiz-item-title">{{ fileObj.name }}</div>
                                <div class="quiz-item-tags" v-if="fileObj.tags && fileObj.tags.length">
                                    <span v-for="tag in fileObj.tags.slice(0, 3)" :key="tag" class="item-tag">
                                        {{ tag }}
                                    </span>
                                </div>
                                <div class="quiz-item-stats" v-if="bankStats[fileObj.file]">
                                    <div class="quiz-stat">
                                        共{{ bankStats[fileObj.file].totalQuestions }}题 (已练{{ bankStats[fileObj.file].uniquePracticed || 0 }}题/提交{{ bankStats[fileObj.file].totalSubmissions || 0 }}次)
                                        <span class="accuracy-stat" v-if="bankStats[fileObj.file].averageAccuracy !== undefined">
                                            - 正确率: {{ bankStats[fileObj.file].averageAccuracy }}%
                                        </span>
                                    </div>
                                </div>
                            </div>
                        </li>
                    </template>
                </ul>
            </template>

            <!-- 如果列表为空 -->
            <template v-else>
                <div class="empty-state" role="status">
                    没有找到可用的题库
                </div>
            </template>
        </div>

        <!-- 题库详情页面 -->
        <div v-else-if="pageState === 'setDescription'" 
            class="card"
            @keydown.prevent="handleKeyNavigation"
            tabindex="-1">
            <h1 class="title">
                {{ chosenSet.name }}
                <div class="time-info" v-if="chosenSet.createTime || chosenSet.updateTime">
                    <div v-if="chosenSet.updateTime" class="update-time">
                        更新于：{{ formatDate(chosenSet.updateTime) }}
                    </div>
                    <div v-else-if="chosenSet.createTime" class="create-time">
                        创建于：{{ formatDate(chosenSet.createTime) }}
                    </div>
                </div>
            </h1>
            <p v-if="chosenSet.description" class="pre-wrap" v-html="renderMarkdown(chosenSet.description)"></p>
            
            <!-- 题库统计信息 -->
            <!-- <div class="set-stats">
                <div class="stats-grid">
                    <div class="stats-item" tabindex="0">
                        <div class="stats-value">{{ setStats.completedQuestions }}/{{ setStats.totalQuestions }}</div>
                        <div class="stats-label">已练习题数</div>
                    </div>
                    <div class="stats-item" tabindex="0">
                        <div class="stats-value">{{ setStats.averageAccuracy }}%</div>
                        <div class="stats-label">平均正确率</div>
                    </div>
                    <div class="stats-item" tabindex="0">
                        <div class="stats-value">{{ setStats.todayAttempts }}</div>
                        <div class="stats-label">今日练习次数</div>
                        <div class="stats-sublabel">正确: {{ setStats.todayCorrect }}</div>
                    </div>
                </div>
            </div> -->

            <!-- 练习模式选择 -->
            <div class="mode-selection" 
                role="group" 
                aria-label="练习模式选择">
                <button 
                    class="mode-btn" 
                    @click="enterQuizMode"
                    @keydown.enter.prevent="enterQuizMode"
                    @keydown.space.prevent="enterQuizMode"
                    @keydown.left.prevent="focusPrevButton($event)"
                    @keydown.right.prevent="focusNextButton($event)"
                    @keydown.up.prevent="focusUpButton($event)"
                    @keydown.down.prevent="focusDownButton($event)"
                    tabindex="0"
                    role="button"
                    data-nav="mode-btn">
                    全部练习
                    <span class="mode-description">按顺序练习所有题目</span>
                </button>
                <button 
                    class="mode-btn" 
                    @click="enterOrderQuizMode"
                    @keydown.enter.prevent="enterOrderQuizMode"
                    @keydown.space.prevent="enterOrderQuizMode"
                    @keydown.left.prevent="focusPrevButton($event)"
                    @keydown.right.prevent="focusNextButton($event)"
                    @keydown.up.prevent="focusUpButton($event)"
                    @keydown.down.prevent="focusDownButton($event)"
                    tabindex="0"
                    role="button"
                    data-nav="mode-btn">
                    错题练习
                    <span class="mode-description">专注于之前答错的题目</span>
                </button>
                <button 
                    class="mode-btn" 
                    @click="enterRandomQuizMode"
                    @keydown.enter.prevent="enterRandomQuizMode"
                    @keydown.space.prevent="enterRandomQuizMode"
                    @keydown.left.prevent="focusPrevButton($event)"
                    @keydown.right.prevent="focusNextButton($event)"
                    @keydown.up.prevent="focusUpButton($event)"
                    @keydown.down.prevent="focusDownButton($event)"
                    tabindex="0"
                    role="button"
                    data-nav="mode-btn">
                    随机练习
                    <span class="mode-description">随机顺序练习题目</span>
                </button>
                <button 
                    class="mode-btn" 
                    @click="enterPreviewMode"
                    @keydown.enter.prevent="enterPreviewMode"
                    @keydown.space.prevent="enterPreviewMode"
                    @keydown.left.prevent="focusPrevButton($event)"
                    @keydown.right.prevent="focusNextButton($event)"
                    @keydown.up.prevent="focusUpButton($event)"
                    @keydown.down.prevent="focusDownButton($event)"
                    tabindex="0"
                    role="button"
                    data-nav="mode-btn">
                    预览模式
                    <span class="mode-description">查看和编辑所有题目和答案</span>
                </button>
            </div>
        </div>

        <!-- 题目页面 -->
        <div v-else-if="['quiz', 'orderQuiz', 'randomQuiz'].includes(pageState)" class="card">
            <!-- 添加已提交数量显示 -->
            <div class="progress-info">
                已提交：{{ currentSessionCompleted.size }}/{{ quizList.length }}
            </div>

            <div class="question-header">
                <div class="header-row">
                    <div class="flex-center">
                        <button class="back-button" @click="backToHome">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M19 12H5M12 19l-7-7 7-7"/>
                            </svg>
                            返回
                        </button>
                        <span class="progress-text">
                            {{ practiceManager.currentIndex + 1 }} / {{ practiceManager.questions.length }}
                            <template v-if="chosenSet.isCrossPractice && currentQuestion">
                                · 来自：{{ currentQuestion.sourceBank }}
                            </template>
                        </span>
                    </div>
                    <div class="action-buttons">
                        <button class="action-button" @click="copyCurrentLink" title="复制当前题目链接">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
                                <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
                            </svg>
                            复制链接
                        </button>
                        <button class="action-button" @click="saveCurrentEdit" v-if="isEditing && questionManager.checkUnsavedChanges()" title="保存并导出修改">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                                <polyline points="17 21 17 13 7 13 7 21"/>
                                <polyline points="7 3 7 8 15 8"/>
                            </svg>
                            保存并导出
                        </button>
                        <button class="action-button" @click="togglePreviewMode" v-if="isAdmin">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                                <circle cx="12" cy="12" r="3"/>
                            </svg>
                            {{ isPreviewMode ? '退出预览' : '预览模式' }}
                        </button>
                        <button class="action-button" @click="editCurrentQuestion" v-if="isAdmin && !isPreviewMode">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                            </svg>
                            编辑
                        </button>
                    </div>
                </div>
            </div>

            <!-- 题目内容 -->
            <div 
                v-if="!isEditing || editingField !== 'content'"
                @click="isEditing && !isPreviewMode ? enterEditMode('content', currentQuestion.content) : null"
                class="question-content"
                :class="{ 'editable': !isPreviewMode && isEditing }"
            >
                <span v-html="renderedContent"></span>
                <span v-if="currentQuestion.type === 'multiple-choice'" class="question-type-label">多选题</span>
            </div>
            <textarea
                v-else-if="editingField === 'content'"
                v-model="editingContent"
                @blur="exitEditMode"
                class="edit-textarea"
                rows="8"
            ></textarea>

            <!-- 选项 -->
            <div v-if="currentQuestion.type === 'single-choice' || currentQuestion.type === 'multiple-choice'">
                <label
                    v-for="(opt, idx) in currentQuestion.options"
                    :key="idx"
                    class="option-item"
                    :class="{
                        'green': showAnswer && (currentQuestion.type === 'single-choice' ? isCorrectOptionSingle(opt) : isCorrectOptionMulti(opt)),
                        'red': showAnswer && (currentQuestion.type === 'single-choice' ? 
                            (isChosenOptionSingle(opt) && !isCorrectOptionSingle(opt)) : 
                            (chosenAnswers.includes(opt) && !isCorrectOptionMulti(opt))),
                        'editable': !isPreviewMode
                    }"
                >
                    <input
                        :type="currentQuestion.type === 'single-choice' ? 'radio' : 'checkbox'"
                        :name="currentQuestion.type === 'single-choice' ? 'single-choice-' + currentQuestion.uniqueId : ''"
                        :value="opt"
                        :checked="currentQuestion.type === 'single-choice' ? chosenAnswer === opt : chosenAnswers.includes(opt)"
                        @change="handleOptionChange(opt, currentQuestion.type === 'single-choice')"
                        :disabled="showAnswer || isEditing || isPreviewMode"
                        class="margin-right-6"
                    >
                    <div class="option-content" v-if="!isEditing || editingField !== `option-${idx}`">
                        <strong>{{ letterMap[idx] }}. </strong>
                        <span 
                            v-html="renderMarkdownWithLatex(opt)"
                            @click="isEditing && !isPreviewMode ? enterEditMode(`option-${idx}`, opt) : null"
                        ></span>
                    </div>
                    <div v-else class="option-edit">
                        <strong>{{ letterMap[idx] }}. </strong>
                        <input
                            type="text"
                            v-model="editingContent"
                            @blur="exitEditMode"
                            class="edit-input"
                        >
                    </div>
                </label>
            </div>

            <div v-else-if="currentQuestion.type === 'short-answer'">
                <!-- 简答题 -->
                <textarea
                    v-model="shortAnswerText"
                    :disabled="showAnswer"
                    rows="4"
                    class="full-width-input"
                    placeholder="请输入你的答案"
                ></textarea>
                <!-- 显示正确答案 -->
                <div v-if="showAnswer" class="correct-answer">
                    <h4>参考答案：</h4>
                    <div v-for="(answer, index) in currentQuestion.correct_answer" 
                         :key="index"
                         v-html="renderMarkdownWithLatex(answer)"
                         class="short-answer-content">
                    </div>
                </div>
            </div>

            <div v-else-if="currentQuestion.type === 'fill-in-blank'">
                <!-- 填空题 -->
                <div v-for="(blank, idx) in currentQuestion.blanks" :key="idx" class="fill-blank-item">
                    <label :for="'blank-'+idx">空{{idx + 1}}：</label>
                    <input
                        :id="'blank-'+idx"
                        type="text"
                        v-model="fillInAnswers[idx]"
                        :disabled="showAnswer"
                        class="medium-input"
                        :placeholder="'请填写空'+(idx+1)"
                    >
                    <span v-if="showAnswer" class="answer-info">
                        正确答案：{{ currentQuestion.correct_answer[idx] }}
                    </span>
                </div>
            </div>

            <!-- 提交答案 / 下一题 按钮 -->
            <div class="flex-gap-12">
                <button
                    type="button"
                    v-if="practiceManager?.currentIndex > 0"
                    class="btn"
                    @click="prevQuestion"
                    title="快捷键：q"
                >
                    <i class="fas fa-chevron-left"></i> 上一题
                </button>
                <button
                    type="button"
                    v-if="!showAnswer"
                    class="btn"
                    @click="submitAnswer"
                    title="快捷键：空格"
                >
                    提交答案
                </button>
                <button
                    type="button"
                    v-else
                    class="btn"
                    @click="nextQuestion"
                    :disabled="practiceManager?.currentIndex === quizList.length - 1 && isPreviewMode"
                    title="快捷键：空格"
                >
                    下一题 <i class="fas fa-chevron-right"></i>
                </button>
                <button
                    type="button"
                    v-if="practiceManager?.currentIndex < quizList.length - 1"
                    class="btn"
                    @click="nextQuestion"
                    title="快捷键：e"
                >
                    跳过 <i class="fas fa-forward"></i>
                </button>
            </div>

            <!-- 解析 -->
            <div v-if="showAnswer" class="analysis">
                <h3>解析</h3>
                <div 
                    v-if="(!isEditing || editingField !== 'analysis') && currentQuestion.analysis"
                    @click="isEditing && !isPreviewMode ? enterEditMode('analysis', currentQuestion.analysis) : null"
                    v-html="renderedAnalysis"
                    :class="{ 'editable': isEditing && !isPreviewMode }"
                ></div>
                <div 
                    v-if="(!isEditing || editingField !== 'analysis') && !currentQuestion.analysis"
                    @click="isEditing && !isPreviewMode ? enterEditMode('analysis', '') : null"
                    class="empty-analysis"
                    :class="{ 'editable': isEditing && !isPreviewMode }"
                >
                    点击添加解析
                </div>
                <textarea
                    v-else-if="editingField === 'analysis'"
                    v-model="editingContent"
                    @blur="exitEditMode"
                    class="edit-textarea"
                    rows="6"
                    placeholder="请输入解析内容..."
                ></textarea>
            </div>

            <p class="small-text">
                键盘：1~4 选项，空格提交/下一题，Shift+C切换解析，q/e切换上一题/下一题
            </p>
        </div>

        <!-- 5) result: 最终结果 -->
        <div v-else-if="pageState === 'result'" class="card">
            <h1 class="title">答题完成</h1>
            <p>本轮共 {{ quizList.length }} 题，已完成：{{ completedCount }}。</p>
            <button type="button" class="btn" @click="pageState = 'home'">
                返回题目选择 (空格)
            </button>
        </div>
    </template>

    <!-- Tags Modal -->
    <div v-if="showTagsModal" class="modal-overlay" @click="showTagsModal = false">
        <div class="modal-content" @click.stop>
            <h2>选择标签</h2>
            <div class="tags-grid">
                <span 
                    v-for="tagInfo in allTags" 
                    :key="tagInfo.tag"
                    :class="['tag-chip', { active: selectedTags.includes(tagInfo.tag) }]"
                    @click="toggleTag(tagInfo.tag)"
                >
                    {{ tagInfo.tag }} ({{ tagInfo.count }})
                </span>
            </div>
            <div class="modal-footer">
                <button @click="clearTags" class="btn btn-clear">清除筛选</button>
                <button @click="showTagsModal = false" class="btn btn-close">关闭窗口</button>
            </div>
        </div>
    </div>

    <!-- Cross Practice Modal -->
    <div v-if="showCrossPracticeModal" 
         class="modal-overlay" 
         @click="showCrossPracticeModal = false"
         @keydown.stop>
        <div class="modal-content cross-practice-modal" 
             @click.stop
             @keydown.left.prevent
             @keydown.right.prevent
             @keydown.up.prevent
             @keydown.down.prevent>
            <h2>跨卷练习设置</h2>
            
            <!-- 题型筛选 -->
            <div class="setting-section">
                <h3>题型筛选</h3>
                <div class="question-types">
                    <label v-for="type in questionTypes" :key="type.value" class="type-checkbox">
                        <input type="checkbox" 
                               v-model="selectedQuestionTypes" 
                               :value="type.value">
                        {{ type.label }}
                    </label>
                </div>
            </div>

            <!-- 练习模式 -->
            <div class="setting-section">
                <h3>练习模式</h3>
                <div class="practice-mode">
                    <label class="mode-radio">
                        <input type="radio" 
                               v-model="crossPracticeMode" 
                               value="random">
                        随机抽题
                    </label>
                    <label class="mode-radio">
                        <input type="radio" 
                               v-model="crossPracticeMode" 
                               value="error-rate">
                        错误率优先
                    </label>
                </div>
            </div>

            <!-- 题目数量 -->
            <div class="setting-section">
                <h3>练习题数</h3>
                <div class="question-count">
                            <input type="number" 
               :value="crossPracticeCount"
               min="1" 
               :max="maxQuestionCount"
               class="count-input"
               @input="handleQuestionInput"
               @blur="handleQuestionBlur"
               @keydown.stop
               @keydown.left.prevent
               @keydown.right.prevent
               @keydown.up.prevent
               @keydown.down.prevent
               ref="countInput">
                    <span class="max-count" :class="{ 'error': crossPracticeCount > maxQuestionCount }">
                        当前可选 {{ maxQuestionCount }} 题
                        <template v-if="crossPracticeCount > maxQuestionCount">
                            (超出限制)
                        </template>
                    </span>
                </div>
            </div>

            <!-- 参与题库及占比 -->
            <div class="setting-section">
                <h3>参与题库及占比</h3>
                <div class="bank-distribution">
                    <div v-for="bank in filteredBankDistribution" 
                         :key="bank.file" 
                         class="bank-item">
                        <div class="bank-name">{{ bank.name }}</div>
                        <div class="bank-count">
                            {{ bank.questionCount }}/{{ bank.availableQuestions }}题
                            ({{ calculateBankPercentage(bank) }}%)
                        </div>
                        <div class="bank-progress">
                            <div class="progress-bar" 
                                 :style="{ width: calculateBankPercentage(bank) + '%' }"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="modal-footer">
                <button @click="showCrossPracticeModal = false" 
                        class="btn btn-clear">取消</button>
                <button @click="startCrossPractice" 
                        class="btn btn-primary"
                        :disabled="!canStartCrossPractice">
                    开始练习
                </button>
            </div>
        </div>
    </div>
</div>

<script type="module">
    import StorageManager from './js/modules/storage.js';
    import JsonLoader from './js/modules/jsonLoader.js';
    import KeyboardManager from './js/modules/keyboard.js';
    import QuestionManager from './js/modules/QuestionManager.js';
    import PracticeManager from './js/modules/PracticeManager.js';

    const app = Vue.createApp({
        data() {
            return {
                storageManager: new StorageManager(),
                jsonLoader: null,
                keyboardManager: null,
                questionManager: null,
                practiceManager: null,
                pageState: 'home',
                isLoading: false,
                loadError: null,
                fileList: [],
                groupedFileList: [],
                chosenSet: null,
                showAnswer: false,
                isEditing: false,
                editingField: null,
                editingContent: '',
                showExportButton: false,
                chosenAnswer: null,
                chosenAnswers: [],
                shortAnswerText: '',
                fillInAnswers: [],
                currentSessionCompleted: new Set(),
                modifiedCount: 0,
                showUnsavedModal: false,
                dontShowExportReminder: false,
                groupedModifiedQuestions: {},
                lastExportTimestamp: null,
                updateTime: null,
                showTagsModal: false,
                selectedTags: [],
                topTags: [],
                allTags: [],
                bankStats: {},
                _altHPressed: false,
                hoverTitle: false,  // 添加 hoverTitle 数据属性
                // 跨卷练习相关
                _showCrossPracticeModal: false,
                selectedQuestionTypes: ['single-choice', 'multiple-choice', 'fill-in-blank', 'short-answer'],
                crossPracticeMode: 'random',
                crossPracticeCount: 30,
                questionTypes: [
                    { value: 'single-choice', label: '单选题' },
                    { value: 'multiple-choice', label: '多选题' },
                    { value: 'fill-in-blank', label: '填空题' },
                    { value: 'short-answer', label: '简答题' }
                ],
            }
        },
                    mounted() {
                // 初始化键盘事件监听
                this.initKeyboardEvents();
                
                // 从URL参数中获取初始状态
                const urlParams = new URLSearchParams(window.location.search);
                const state = urlParams.get('state') || 'setDescription';
                const bank = urlParams.get('bank');
                const mode = urlParams.get('mode');
                const qid = urlParams.get('qid');
                
                // 如果有bank参数，加载对应的题库
                if (bank) {
                    const matchedSet = this.fileList.find(f => f.file === bank);
                    if (matchedSet) {
                        this.chosenSet = matchedSet;
                        this.loadQuestions(matchedSet).then(() => {
                            // 如果有qid参数，跳转到对应题目
                            if (qid) {
                                const targetIndex = parseInt(qid) - 1;
                                if (!isNaN(targetIndex) && targetIndex >= 0 && targetIndex < this.practiceManager.questions.length) {
                                    this.practiceManager.currentIndex = targetIndex;
                                }
                            }
                            
                            // 更新URL参数
                            this.updateUrlParams('quiz', {
                                mode: mode || this.getCurrentMode(),
                                qid: this.getCurrentQuestionId(),
                                bank: bank
                            });
                        });
                    }
                }
                
                // 设置初始状态
                this.currentState = state;
        },
        beforeUnmount() {
            // 清理事件监听器
            window.removeEventListener('popstate', this.handlePopState);
            window.removeEventListener('hashchange', this.handleUrlChange);
            window.removeEventListener('popstate', this.handleUrlChange);
            window.removeEventListener('keydown', this.handleGlobalBackShortcut);
        },
        watch: {
            selectedQuestionTypes: {
                handler() {
                    console.log('[selectedQuestionTypes] Question types changed, updating distribution');
                    this.updateBankDistribution();
                },
                deep: true
            },
            pageState: {
                handler(newState, oldState) {
                    console.log('Page state changed:', {
                        from: oldState,
                        to: newState
                    });
                    if (newState === 'setDescription') {
                        this.$nextTick(() => {
                            const buttons = document.querySelectorAll('.mode-btn');
                            console.log('Mode buttons after state change:', {
                                totalButtons: buttons.length,
                                buttonElements: Array.from(buttons).map(btn => ({
                                    text: btn.textContent.trim(),
                                    tabIndex: btn.tabIndex,
                                    hasClickHandler: btn.onclick !== null,
                                    hasKeydownHandler: btn.onkeydown !== null
                                }))
                            });
                        });
                    }
                },
                immediate: true
            },
            'practiceManager.currentIndex': {
                handler(newIndex) {
                    console.log('[watch] currentIndex changed:', newIndex);
                    if (this.practiceManager && this.practiceManager.questions) {
                        const currentQuestion = this.practiceManager.questions[newIndex];
                        console.log('[watch] Current question:', currentQuestion);
                        if (currentQuestion) {
                            // 确保保持 bank 参数
                            const currentFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                            this.updateUrlParams('quiz', {
                                mode: this.getCurrentMode(),
                                qid: newIndex + 1, // 使用题目序号（从1开始）
                                bank: currentFile
                            });
                        }
                    }
                },
                immediate: true
            }
        },
        async created() {
            // 初始化各个管理器
            this.jsonLoader = new JsonLoader();
            this.keyboardManager = new KeyboardManager(this);
            this.questionManager = new QuestionManager(this.storageManager);
            this.practiceManager = new PracticeManager(this.storageManager);

            // 先加载题库列表
            await this.loadBankList();
            
            // 然后处理URL参数
            await this.handleUrlParams();
        },
        computed: {
            currentQuestion() {
                return this.practiceManager?.getCurrentQuestion() || null;
            },
            currentIndex() {
                return this.practiceManager?.currentIndex || 0;
            },
            quizList() {
                return this.practiceManager?.questions || [];
            },
            isPreviewMode() {
                return this.practiceManager?.isPreviewMode || false;
            },
            totalStats() {
                const stats = this.storageManager.getAllBanksStats();
                console.log('[totalStats computed] Raw stats from storage:', stats);
                return {
                    completedQuestions: stats.completedQuestions || 0,
                    totalAttempts: stats.totalAttempts || 0,
                    averageAccuracy: stats.averageAccuracy || 0,
                    todayPracticed: stats.todayPracticed || 0,
                };
            },
            setStats() {
                if (!this.chosenSet) return null;
                const stats = this.storageManager.getSetStats(this.chosenSet.id, this.jsonLoader.questions);
                const today = new Date().toISOString().split('T')[0];
                
                // 获取今日练习题数
                const todayCount = this.jsonLoader.questions.reduce((count, q) => {
                    const completion = this.storageManager.getQuestionCompletion(this.chosenSet.id, q.uniqueId);
                    if (completion && completion.lastAttemptDate === today) {
                        return count + 1;
                    }
                    return count;
                }, 0);

                return {
                    ...stats,
                    todayCount,
                    averageAccuracy: stats.totalAttempts > 0 
                        ? Math.round((stats.totalCorrect / stats.totalAttempts) * 100)
                        : 0
                };
            },
            renderedContent() {
                if (!this.currentQuestion.content) return '';
                return this.renderMarkdownWithLatex(this.currentQuestion.content);
            },
            renderedAnalysis() {
                if (!this.currentQuestion.analysis) return '';
                return this.renderMarkdownWithLatex(this.currentQuestion.analysis);
            },
            progressText() {
                return `本次练习完成度：${this.currentSessionCompleted.size}/${this.quizList.length}`;
            },
            completedCount() {
                return this.currentSessionCompleted.size;
            },
            letterMap() {
                return ['A','B','C','D','E','F'];
            },
            hoverTitle() {
                return false;
            },
            hasChanges() {
                return false;
            },
            changesExported() {
                return false;
            },
            questionStats() {
                if (!this.chosenSet || !this.currentQuestion) return null;
                return this.storageManager.getQuestionStats(
                    this.chosenSet.id,
                    this.currentQuestion.uniqueId
                );
            },
            filteredGroupedFileList() {
                if (this.selectedTags.length === 0) return this.groupedFileList;
                
                return this.groupedFileList.map(([category, items]) => {
                    const filteredItems = items.filter(item => 
                        this.selectedTags.every(tag => item.tags && item.tags.includes(tag))
                    );
                    return [category, filteredItems];
                }).filter(([_, items]) => items.length > 0);
            },
            // 跨卷练习相关的计算属性
            filteredBankDistribution() {
                // 获取符合当前标签和题型筛选的题库及题目数
                const distribution = [];

                // 遍历所有题库
                this.fileList.forEach(bank => {
                    // 检查标签筛选
                    if (this.selectedTags.length > 0 && 
                        !this.selectedTags.every(tag => bank.tags && bank.tags.includes(tag))) {
                        return;
                    }

                    // 获取题库中符合题型的题目数量
                    const questions = this.jsonLoader.getQuestionsFromBank(bank.file);
                    const filteredQuestions = questions.filter(q => 
                        this.selectedQuestionTypes.includes(q.type)
                    );

                    if (filteredQuestions.length > 0) {
                        distribution.push({
                            file: bank.file,
                            name: bank.name,
                            questionCount: 0, // 初始化为0，实际分配由updateBankDistribution处理
                            availableQuestions: filteredQuestions.length,
                            questions: filteredQuestions
                        });
                    }
                });

                return distribution;
            },

            maxQuestionCount() {
                // 计算所有可用题目的总数
                return this.filteredBankDistribution.reduce(
                    (sum, bank) => sum + bank.availableQuestions, 
                    0
                );
            },

            canStartCrossPractice() {
                return this.selectedQuestionTypes.length > 0 && 
                       this.crossPracticeCount > 0 && 
                       this.crossPracticeCount <= this.maxQuestionCount &&
                       this.filteredBankDistribution.length > 0;
            },
            showCrossPracticeModal: {
                get() {
                    return this._showCrossPracticeModal;
                },
                set(value) {
                    this._showCrossPracticeModal = value;
                    if (value) {
                        // 打开模态框时初始化
                        this.$nextTick(() => {
                            // 先更新题库分布
                            this.updateBankDistribution();
                            // 如果当前选择的题目数大于最大可选数，自动调整
                            if (this.crossPracticeCount > this.maxQuestionCount) {
                                console.log(`[showCrossPracticeModal] Adjusting initial count from ${this.crossPracticeCount} to ${this.maxQuestionCount}`);
                                this.crossPracticeCount = this.maxQuestionCount;
                            }
                            // 再次更新分布以确保百分比正确
                            this.updateBankDistribution();
                        });
                    }
                }
            }
        },
        methods: {
            // 加载题库列表
            async loadBankList() {
                this.isLoading = true;
                this.loadError = null;
                try {
                    const response = await fetch('assets/list.json');
                    const data = await response.json();
                    this.fileList = data.banks || [];
                    this.updateTime = data.updateTime;
                    
                    // 初始化 jsonLoader
                    if (!this.jsonLoader) {
                        this.jsonLoader = new JsonLoader();
                    }
                    
                    // 加载每个题库的统计信息
                    for (const bank of this.fileList) {
                        try {
                            // 先加载题库数据
                            await this.jsonLoader.loadFile(bank.file);
                            // 然后获取统计信息
                            const stats = await this.storageManager.getBankStats(bank.file, this.jsonLoader);
                            this.bankStats[bank.file] = stats;
                        } catch (error) {
                            console.error(`Error loading bank ${bank.file}:`, error);
                            this.bankStats[bank.file] = {
                                totalQuestions: 0,
                                uniquePracticed: 0,
                                totalSubmissions: 0
                            };
                        }
                    }
                    
                    // 加载每个题库的sets信息以获取category和tags
                    const fileCategories = {};
                    const fileTags = {};
                    const tagsCount = new Map();
                    
                    for (const bank of this.fileList) {
                        try {
                            const bankData = await this.jsonLoader.loadFile(bank.file);
                            const category = bankData.sets[0]?.category || '未分类';
                            const tags = bankData.sets[0]?.tags || [];
                            
                            fileCategories[bank.file] = category;
                            fileTags[bank.file] = tags;
                            
                            // 统计tags
                            tags.forEach(tag => {
                                tagsCount.set(tag, (tagsCount.get(tag) || 0) + 1);
                            });
                        } catch (error) {
                            console.error(`Error loading bank ${bank.file}:`, error);
                            fileCategories[bank.file] = '未分类';
                            fileTags[bank.file] = [];
                        }
                    }
                    
                    // 更新fileList添加tags信息
                    this.fileList = this.fileList.map(bank => ({
                        ...bank,
                        tags: fileTags[bank.file] || []
                    }));
                    
                    // 获取前三个最常用的tags
                    this.topTags = Array.from(tagsCount.entries())
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3)
                        .map(([tag, count]) => ({ tag, count }));
                    
                    // 获取所有tags
                    this.allTags = Array.from(tagsCount.entries())
                        .sort((a, b) => b[1] - a[1])
                        .map(([tag, count]) => ({ tag, count }));
                    
                    // 按category对题库进行分组
                    const groups = {};
                    this.fileList.forEach(bank => {
                        const category = fileCategories[bank.file] || '未分类';
                        if (!groups[category]) {
                            groups[category] = [];
                        }
                        groups[category].push(bank);
                    });
                    
                    // 对每个分类内的题库按名称排序
                    for (const category in groups) {
                        groups[category].sort((a, b) => a.name.localeCompare(b.name));
                    }
                    
                    // 转换为数组并按分类名排序，确保"未分类"永远在最后
                    this.groupedFileList = Object.entries(groups)
                        .sort((a, b) => {
                            if (a[0] === '未分类') return 1;
                            if (b[0] === '未分类') return -1;
                            return a[0].localeCompare(b[0]);
                        });
                } catch (error) {
                    console.error('Error loading file list:', error);
                    this.loadError = error.message;
                }
                this.isLoading = false;
            },

            // 加载题库文件
            async loadJsonFile(fileName) {
                console.log('[loadJsonFile] Starting to load file:', fileName);
                if (this.isLoading) {
                    console.log('[loadJsonFile] Already loading, skipping');
                    return;
                }
                this.isLoading = true;
                try {
                    console.log('[loadJsonFile] Loading data from file');
                    const data = await this.jsonLoader.loadFile(fileName);
                    console.log('[loadJsonFile] Data loaded:', {
                        setName: data.sets[0]?.name,
                        questionCount: data.questions?.length
                    });
                    
                    // Set chosenSet with proper id
                    this.chosenSet = {
                        ...data.sets[0],
                        id: fileName.replace('.json', '') // Ensure id matches the file name without extension
                    };
                    
                    // 更新统计数据
                    console.log('[loadJsonFile] Updating bank stats');
                    const stats = await this.storageManager.getBankStats(fileName, this.jsonLoader);
                    this.bankStats[fileName] = stats;
                    
                    // 更新URL并切换到题库详情页
                    console.log('[loadJsonFile] Updating page state to setDescription');
                    this.updatePageState('setDescription');
                } catch (error) {
                    console.error('[loadJsonFile] Failed to load bank:', error);
                    alert('加载题库失败: ' + error.message);
                } finally {
                    this.isLoading = false;
                    console.log('[loadJsonFile] Loading completed');
                }
            },

            // 开始练习
            startQuiz(mode) {
                switch (mode) {
                    case 'all':
                        this.enterQuizMode();
                        break;
                    case 'wrong':
                        this.enterOrderQuizMode();
                        break;
                    case 'random':
                        this.enterRandomQuizMode();
                        break;
                    case 'preview':
                        this.enterPreviewMode();
                        break;
                }
            },

            // 进入练习模式
            enterQuizMode() {
                this.practiceManager.initPractice(this.jsonLoader.questions, 'sequence');
                this.practiceManager.togglePreviewMode(false);
                this.showAnswer = false;
                this.currentSessionCompleted.clear();
                this.updatePageState('quiz', { 
                    mode: 'all',
                    qid: 1 // 从第一题开始
                });
            },

            enterOrderQuizMode() {
                this.practiceManager.initPractice(this.jsonLoader.questions, 'error-rate');
                this.practiceManager.togglePreviewMode(false);
                this.showAnswer = false;
                this.currentSessionCompleted.clear();
                this.updatePageState('quiz', { 
                    mode: 'wrong',
                    qid: 1 // 从第一题开始
                });
            },

            enterRandomQuizMode() {
                this.practiceManager.initPractice(this.jsonLoader.questions, 'random');
                this.practiceManager.togglePreviewMode(false);
                this.showAnswer = false;
                this.currentSessionCompleted.clear();
                this.updatePageState('quiz', { 
                    mode: 'random',
                    qid: 1 // 从第一题开始
                });
            },

            enterPreviewMode() {
                this.practiceManager.initPractice(this.jsonLoader.questions, 'sequence');
                this.practiceManager.togglePreviewMode(false); // 关闭预览模式
                this.showAnswer = true; // 显示解析
                this.isEditing = true; // 启用编辑模式
                this.questionManager.startEditing(this.jsonLoader.questions[0]); // 开始编辑第一题
                this.showExportButton = true; // 显示导出按钮
                this.updatePageState('quiz', { 
                    mode: 'preview',
                    qid: 1 // 从第一题开始
                });
            },

            // 编辑相关方法
            editQuestion() {
                if (this.isPreviewMode) return;
                console.log('Starting edit mode for question:', this.currentQuestion);
                this.questionManager.startEditing(this.currentQuestion);
                this.isEditing = true;
                this.showExportButton = true;
                // 自动切换到解析模式
                this.showAnswer = true;
            },

            enterEditMode(field, content) {
                if (this.isPreviewMode) return;
                console.log('Entering edit mode:', {
                    field,
                    content,
                    currentContent: content || '点击编辑'
                });
                this.editingField = field;
                this.editingContent = content || '';
            },

            exitEditMode() {
                console.log('Exiting edit mode:', {
                    field: this.editingField,
                    content: this.editingContent,
                    question: this.currentQuestion
                });
                
                if (this.editingField && this.editingContent !== undefined) {
                    const question = this.currentQuestion;
                    if (this.editingField === 'content') {
                        question.content = this.editingContent;
                    } else if (this.editingField === 'analysis') {
                        question.analysis = this.editingContent;
                    } else if (this.editingField.startsWith('option-')) {
                        const idx = parseInt(this.editingField.split('-')[1]);
                        question.options[idx] = this.editingContent;
                    }
                    this.questionManager.saveCurrentEdit();
                    // 更新修改计数
                    this.modifiedCount = this.questionManager.getModifiedQuestions().length;
                }
                this.editingField = null;
                this.editingContent = '';
            },

            // 退出整个编辑模式
            exitEntireEditMode() {
                if (this.editingField) {
                    this.exitEditMode();
                }
                this.isEditing = false;
                this.showAnswer = false;
                this.showExportButton = false;
                this.questionManager.cancelEditing();
            },

            // 导出相关方法
            handleExport(questions) {
                const exportData = {
                    questions: questions,
                    sets: [this.chosenSet]
                };

                const blob = new Blob([JSON.stringify(exportData, null, 4)], 
                    { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                // 从fileList中获取当前题库的文件名
                const currentFile = this.fileList.find(f => f.name === this.chosenSet.name)?.file;
                a.download = this.questionManager.generateExportFileName(currentFile || 'export');
                a.click();
                URL.revokeObjectURL(url);

                // 更新导出状态
                this.lastExportTimestamp = Date.now();
                this.modifiedCount = 0;
                this.questionManager.clearModifiedQuestions();
                this.showExportButton = false;
                this.isEditing = false;
                this.showUnsavedModal = false;
            },

            // 导出修改
            exportModifiedData() {
                const modifiedQuestions = this.questionManager.getModifiedQuestions();
                const questions = this.jsonLoader.questions.map(q => {
                    if (modifiedQuestions.includes(q.uniqueId)) {
                        return { ...q };
                    }
                    return q;
                });
                this.handleExport(questions);
            },

            // 状态更新
            updatePageState(newState, params = {}) {
                console.log('[updatePageState] from:', this.pageState, 'to:', newState, 'params:', params);
                // 如果有未导出的修改，且不是刚刚导出的，且不是在编辑模式中
                if (this.modifiedCount > 0 && !this.dontShowExportReminder && 
                    (!this.lastExportTimestamp || Date.now() - this.lastExportTimestamp > 1000) &&
                    !this.isEditing) {
                    const hasUnsaved = this.checkModifiedQuestions();
                    if (hasUnsaved) {
                        return;
                    }
                }
                
                if (this.isEditing && this.questionManager.checkUnsavedChanges()) {
                    this.showUnsavedDialog(newState);
                    return;
                }
                
                this.pageState = newState;
                
                // 如果是返回题库详情页，确保传递当前题库参数
                if (newState === 'setDescription' && this.chosenSet) {
                    const currentFile = this.fileList.find(f => f.name === this.chosenSet.name)?.file;
                    if (currentFile) {
                        params.bank = currentFile;
                    }
                }
                
                // 如果是进入答题页面，确保传递当前题目序号
                if (newState === 'quiz' && this.practiceManager) {
                    params.qid = params.qid || (this.practiceManager.currentIndex + 1);
                }
                
                // 更新URL参数
                this.updateUrlParams(newState, params);
                
                if (newState === 'home') {
                    this.questionManager.clearEditHistory();
                    this.showExportButton = false;
                }
            },

            showUnsavedDialog(action) {
                const dialog = document.createElement('div');
                dialog.className = 'modal-overlay';
                dialog.innerHTML = `
                    <div class="modal-content modal-btn">
                        <h3>未保存的修改</h3>
                        <p>当前题目有未保存的修改，请选择操作：</p>
                        <div class="modal-btn-group">
                            <button class="btn btn-continue-edit" id="continueEdit">继续编辑</button>
                            <button class="btn btn-save-export" id="saveAndExport">保存导出</button>
                            <button class="btn btn-discard" id="discardAndContinue">放弃修改</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(dialog);

                // 确保元素已经添加到DOM后再添加事件监听器
                const continueEditBtn = dialog.querySelector('#continueEdit');
                const saveAndExportBtn = dialog.querySelector('#saveAndExport');
                const discardBtn = dialog.querySelector('#discardAndContinue');

                if (continueEditBtn && saveAndExportBtn && discardBtn) {
                    // 点击遮罩层关闭对话框（继续编辑）
                    dialog.addEventListener('click', (e) => {
                        if (e.target === dialog) {
                            document.body.removeChild(dialog);
                        }
                    });

                    // 继续编辑
                    continueEditBtn.addEventListener('click', () => {
                        document.body.removeChild(dialog);
                    });

                    // 保存并导出
                    saveAndExportBtn.addEventListener('click', () => {
                        this.questionManager.saveCurrentEdit();
                        this.exportModifiedData();
                        document.body.removeChild(dialog);
                        
                        // 根据action执行相应操作
                        this.handleActionAfterSave(action);
                    });

                    // 放弃修改并继续
                    discardBtn.addEventListener('click', () => {
                        this.questionManager.cancelEditing();
                        document.body.removeChild(dialog);
                        
                        // 根据action执行相应操作
                        this.handleActionAfterSave(action);
                    });
                } else {
                    console.error('Failed to find dialog buttons');
                    document.body.removeChild(dialog);
                }
            },

            // 处理保存后的操作
            handleActionAfterSave(action) {
                if (action === 'next') {
                    this.practiceManager.currentIndex++;
                    this.questionManager.startEditing(this.practiceManager.questions[this.practiceManager.currentIndex]);
                } else if (action === 'prev') {
                    this.practiceManager.currentIndex--;
                    this.questionManager.startEditing(this.practiceManager.questions[this.practiceManager.currentIndex]);
                } else if (action === 'setDescription') {
                    this.exitEntireEditMode();
                    this.pageState = action;
                } else if (action === 'home') {
                    this.exitEntireEditMode();
                    this.pageState = action;
                }
                
                // 更新URL参数
                if (action === 'next' || action === 'prev') {
                    this.$nextTick(() => {
                        this.updateUrlParams('quiz', {
                            mode: this.getCurrentMode(),
                            qid: this.practiceManager.questions[this.practiceManager.currentIndex].uniqueId
                        });
                    });
                }
            },

            goBack() {
                if (this.pageState === 'quiz') {
                    // 如果有完成的题目，显示确认对话框
                    if (this.currentSessionCompleted.size > 0) {
                        if (!confirm('确定要退出练习吗？当前进度将不会保存。')) {
                            return;
                        }
                    }
                }
                
                // 重置状态
                this.resetAllState();
                this.updatePageState('home');
            },

            async getBankStats(fileName) {
                try {
                    // 确保题库已加载
                    if (!this.jsonLoader.loadedBanks.has(fileName)) {
                        console.log(`[getBankStats] Loading bank first: ${fileName}`);
                        await this.jsonLoader.loadFile(fileName);
                    }
                    
                    const bankData = await this.storageManager.getBankStats(fileName, this.jsonLoader);
                    console.log(`[getBankStats] Stats for ${fileName}:`, bankData);
                    if (!bankData) return null;
                    
                    const stats = {
                        completed: bankData.completed || 0,
                        total: bankData.total || 0,
                        accuracy: bankData.attempts > 0 
                            ? Math.round((bankData.correct / bankData.attempts) * 100)
                            : 0
                    };
                    console.log(`[getBankStats] Processed stats for ${fileName}:`, stats);
                    return stats;
                } catch (e) {
                    console.error('获取题库统计失败:', e);
                    return {
                        completed: 0,
                        total: 0,
                        accuracy: 0
                    };
                }
            },

            renderMarkdown(text) {
                if (!text) return '';
                return marked.parse(text);
            },

            renderMarkdownWithLatex(text) {
                if (!text) return '';
                
                // 先处理多行公式，避免被markdown解析器破坏格式
                let content = text;
                
                // 保存多行公式
                const formulas = [];
                content = content.replace(/\$\$([\s\S]+?)\$\$/g, (match, formula) => {
                    // 保持原始换行，不进行任何替换
                    formulas.push(formula.trim());
                    return `<div class="katex-display">${katex.renderToString(formula.trim(), {
                        displayMode: true,
                        throwOnError: false,
                        strict: false,
                        trust: true,
                        output: 'html'
                    })}</div>`;
                });
                
                // 处理Markdown
                content = marked.parse(content);
                
                // 处理行内公式
                content = content.replace(/\$([^$]+?)\$/g, (match, formula) => {
                    try {
                        return katex.renderToString(formula.trim(), {
                            displayMode: false,
                            throwOnError: false,
                            strict: false
                        });
                    } catch (e) {
                        console.error('LaTeX rendering error:', e);
                        console.error('Formula:', formula);
                        return match;
                    }
                });
                
                return content;
            },

            handleOptionChange(option, isSingleChoice) {
                console.log('Option change handler:', {
                    option,
                    isSingleChoice,
                    currentValue: isSingleChoice ? this.chosenAnswer : this.chosenAnswers
                });

                if (isSingleChoice) {
                    this.chosenAnswer = option;
                } else {
                    const index = this.chosenAnswers.indexOf(option);
                    if (index === -1) {
                        this.chosenAnswers.push(option);
                    } else {
                        this.chosenAnswers.splice(index, 1);
                    }
                }

                console.log('After option change:', {
                    chosenAnswer: this.chosenAnswer,
                    chosenAnswers: this.chosenAnswers
                });
            },

            isChosenOptionSingle(opt) {
                console.log('Checking single option selection:', {
                    option: opt,
                    optionType: typeof opt,
                    chosenAnswer: this.chosenAnswer,
                    chosenAnswerType: typeof this.chosenAnswer,
                    isChosen: String(this.chosenAnswer) === String(opt)
                });
                return this.chosenAnswer !== null && 
                       this.chosenAnswer !== undefined && 
                       this.chosenAnswer !== '' && 
                       String(this.chosenAnswer) === String(opt);
            },

            isCorrectOptionMulti(opt) {
                const ans = this.currentQuestion?.correct_answer || [];
                const isCorrect = ans.some(a => String(a) === String(opt));
                console.log('Checking multi option correctness:', {
                    option: opt,
                    correctAnswers: ans,
                    isCorrect: isCorrect
                });
                return isCorrect;
            },

            isCorrectOptionSingle(opt) {
                const ans = this.currentQuestion?.correct_answer || [];
                const isCorrect = ans.length > 0 && String(ans[0]) === String(opt);
                console.log('Checking single option correctness:', {
                    option: opt,
                    optionType: typeof opt,
                    correctAnswer: ans[0],
                    correctAnswerType: ans.length > 0 ? typeof ans[0] : 'undefined',
                    isCorrect: isCorrect
                });
                return isCorrect;
            },

            // 检查是否已选择或输入答案
            hasAnswer() {
                const q = this.currentQuestion;
                if (!q) return false;

                switch (q.type) {
                    case 'single-choice':
                        return this.chosenAnswer !== null && 
                               this.chosenAnswer !== undefined && 
                               this.chosenAnswer !== '';
                    case 'multiple-choice':
                        return Array.isArray(this.chosenAnswers) && 
                               this.chosenAnswers.length > 0;
                    case 'fill-in-blank':
                        return Array.isArray(this.fillInAnswers) && 
                               this.fillInAnswers.some(ans => ans && ans.trim() !== '');
                    case 'short-answer':
                        return this.shortAnswerText && this.shortAnswerText.trim() !== '';
                    default:
                        return false;
                }
            },

            async submitAnswer() {
                const q = this.currentQuestion;
                if (!q) return;

                // 检查是否已选择或输入答案
                if (!this.hasAnswer()) {
                    // 根据题目类型显示不同的提示
                    let message;
                    switch (q.type) {
                        case 'single-choice':
                            message = '请选择一个选项';
                            break;
                        case 'multiple-choice':
                            message = '请至少选择一个选项';
                            break;
                        case 'fill-in-blank':
                            message = '请填写答案';
                            break;
                        case 'short-answer':
                            message = '请输入答案';
                            break;
                        default:
                            message = '请输入答案';
                    }
                    // 显示提示信息
                    this.showBanner(message, 'warning');
                    return;
                }

                let answer;
                let isCorrect = false;

                switch (q.type) {
                    case 'single-choice':
                        answer = this.chosenAnswer;
                        isCorrect = q.correct_answer.includes(answer);
                        break;
                    case 'multiple-choice':
                        answer = [...this.chosenAnswers].sort();
                        isCorrect = this.compareArrays(answer, q.correct_answer);
                        break;
                    case 'fill-in-blank':
                        answer = this.fillInAnswers;
                        isCorrect = this.compareArrays(answer, q.correct_answer);
                        break;
                    case 'short-answer':
                        answer = this.shortAnswerText;
                        isCorrect = q.correct_answer.some(ans => 
                            answer.toLowerCase().includes(ans.toLowerCase())
                        );
                        break;
                }

                // 记录完成状态
                const questionIndex = this.practiceManager.currentIndex + 1;
                this.currentSessionCompleted.add(questionIndex);
                
                // 只有在未显示答案时才更新题目完成状态
                if (!this.showAnswer) {
                    if (this.chosenSet.isCrossPractice) {
                        // 对于跨题练习，找到原题库并更新记录
                        const originalBank = this.findOriginalBank(q);
                        if (originalBank) {
                            console.log('[submitAnswer] Updating cross practice record:', {
                                bank: originalBank.file,
                                questionIndex,
                                isCorrect
                            });
                            this.storageManager.updateQuestionCompletion(originalBank.file, questionIndex, isCorrect);
                        }
                    } else {
                        // 确保有题库ID和题目序号
                        const currentQuestion = this.practiceManager.getCurrentQuestion();
                        if (this.chosenSet?.id && currentQuestion) {
                            console.log('[submitAnswer] Updating completion:', {
                                setId: this.chosenSet.id,
                                questionIndex,
                                isCorrect
                            });
                            this.storageManager.updateQuestionCompletion(
                                this.chosenSet.id,
                                questionIndex,
                                isCorrect
                            );
                        } else {
                            console.error('[submitAnswer] Missing setId or currentQuestion:', {
                                setId: this.chosenSet?.id,
                                currentQuestion
                            });
                        }
                    }
                }
                
                this.showAnswer = true;

                // 更新URL以反映答案已提交
                this.updateUrlParams('quiz', {
                    mode: this.getCurrentMode(),
                    qid: this.getCurrentQuestionId()
                });
            },

            // 查找题目所属的原始题库
            findOriginalBank(question) {
                for (const bank of this.fileList) {
                    try {
                        const questions = this.jsonLoader.getQuestionsFromBank(bank.file);
                        if (questions.some(q => 
                            q.content === question.content && 
                            q.type === question.type &&
                            this.compareArrays(q.correct_answer, question.correct_answer)
                        )) {
                            return bank;
                        }
                    } catch (error) {
                        console.error(`Error checking bank ${bank.file}:`, error);
                    }
                }
                return null;
            },

            // 比较两个数组是否相等
            compareArrays(arr1, arr2) {
                if (!Array.isArray(arr1) || !Array.isArray(arr2)) return false;
                if (arr1.length !== arr2.length) return false;
                return arr1.every((item, index) => item === arr2[index]);
            },

            nextQuestion() {
                if (this.practiceManager && this.practiceManager.currentIndex < this.practiceManager.questions.length - 1) {
                    // 如果在编辑模式，自动保存当前编辑并开始编辑下一题
                    if (this.isEditing) {
                        // 如果当前有未保存的字段编辑，先保存
                        if (this.editingField) {
                            this.exitEditMode();
                        }
                        // 如果有未保存的修改，自动保存
                        if (this.questionManager.checkUnsavedChanges()) {
                            this.questionManager.saveCurrentEdit();
                        }
                        this.practiceManager.currentIndex++;
                        this.questionManager.startEditing(this.practiceManager.questions[this.practiceManager.currentIndex]);
                        this.showAnswer = true;
                    } else {
                        this.practiceManager.currentIndex++;
                        this.showAnswer = false;
                        // 重置答案状态
                        this.chosenAnswer = null;
                        this.chosenAnswers = [];
                        this.fillInAnswers = [];
                        this.shortAnswerText = '';
                    }
                    
                    // 立即更新URL参数
                    this.$nextTick(() => {
                        const currentFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                        this.updateUrlParams('quiz', {
                            mode: this.getCurrentMode(),
                            qid: this.practiceManager.currentIndex + 1,
                            bank: currentFile
                        });
                    });
                } else if (!this.practiceManager.isPreviewMode) {
                    this.updatePageState('result');
                }
            },

            prevQuestion() {
                if (this.practiceManager && this.practiceManager.currentIndex > 0) {
                    // 如果在编辑模式，自动保存当前编辑并开始编辑上一题
                    if (this.isEditing) {
                        // 如果当前有未保存的字段编辑，先保存
                        if (this.editingField) {
                            this.exitEditMode();
                        }
                        // 如果有未保存的修改，自动保存
                        if (this.questionManager.checkUnsavedChanges()) {
                            this.questionManager.saveCurrentEdit();
                        }
                        this.practiceManager.currentIndex--;
                        this.questionManager.startEditing(this.practiceManager.questions[this.practiceManager.currentIndex]);
                        this.showAnswer = true;
                    } else {
                        this.practiceManager.currentIndex--;
                        this.showAnswer = false;
                        // 重置答案状态
                        this.chosenAnswer = null;
                        this.chosenAnswers = [];
                        this.fillInAnswers = [];
                        this.shortAnswerText = '';
                    }
                    
                    // 立即更新URL参数
                    this.$nextTick(() => {
                        const currentFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                        this.updateUrlParams('quiz', {
                            mode: this.getCurrentMode(),
                            qid: this.practiceManager.currentIndex + 1,
                            bank: currentFile
                        });
                    });
                }
            },

            formatDate(isoDate) {
                if (!isoDate) return '';
                const date = new Date(isoDate);
                const today = new Date();
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);

                if (isoDate.startsWith(today.toISOString().split('T')[0])) {
                    return '今天 ' + date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                } else if (isoDate.startsWith(yesterday.toISOString().split('T')[0])) {
                    return '昨天 ' + date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                } else {
                    return date.toLocaleDateString('zh-CN') + ' ' + 
                           date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                }
            },
            closeUnsavedModal() {
                this.showUnsavedModal = false;
            },
            truncateText(text, length) {
                if (!text) return '';
                text = text.replace(/<[^>]*>/g, ''); // 移除HTML标签
                return text.length > length ? text.slice(0, length) + '...' : text;
            },
            getSetName(setId) {
                return this.jsonLoader.sets.find(s => s.id === setId)?.name || setId;
            },
            checkModifiedQuestions() {
                const modifiedQuestions = this.questionManager.getModifiedQuestions();
                if (modifiedQuestions.length > 0 && !this.dontShowExportReminder) {
                    // 只显示当前题库的修改题目
                    this.groupedModifiedQuestions = this.jsonLoader.questions
                        .filter(q => modifiedQuestions.includes(q.uniqueId));
                    
                    // 显示未导出提示模态框
                    this.showUnsavedModal = true;
                    return true;
                }
                return false;
            },
            showBanner(content, type = 'info', closeable = true) {
                this.banner = {
                    show: true,
                    content,
                    type,
                    closeable
                };
            },
            closeBanner() {
                this.banner.show = false;
            },
            formatUpdateTime(isoString) {
                const date = new Date(isoString);
                return date.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            },
            closeUnsavedModalAndContinue() {
                this.showUnsavedModal = false;
                this.questionManager.clearModifiedQuestions();
                this.modifiedCount = 0;
                this.showExportButton = false;
            },
            toggleTag(tag) {
                const index = this.selectedTags.indexOf(tag);
                if (index === -1) {
                    this.selectedTags.push(tag);
                } else {
                    this.selectedTags.splice(index, 1);
                }
            },
            clearTags() {
                this.selectedTags = [];
            },
            async loadBankStats(fileName) {
                console.log('[loadBankStats] Loading stats for:', fileName);
                try {
                    // 获取统计信息
                    const stats = this.storageManager.getBankStats(fileName, this.jsonLoader);
                    console.log('[loadBankStats] Retrieved stats:', stats);
                    this.bankStats[fileName] = stats;
                    
                    // 强制更新计算属性
                    this.$forceUpdate();
                    console.log('[loadBankStats] Stats updated and view forced to update');
                    
                    // 如果在题库详情页面，确保setStats被重新计算
                    if (this.pageState === 'setDescription') {
                        console.log('[loadBankStats] Recalculating setStats for description page');
                        // Vue会自动重新计算setStats，因为依赖的数据已经更新
                        const currentStats = this.setStats;
                        console.log('[loadBankStats] Current setStats:', currentStats);
                    }
                } catch (error) {
                    console.error('[loadBankStats] Error loading bank stats:', error);
                }
            },
            focusPrevButton(event) {
                console.log('focusPrevButton triggered', {
                    eventTarget: event.target,
                    eventType: event.type,
                    currentActiveElement: document.activeElement
                });
                
                const buttons = Array.from(document.querySelectorAll('.mode-btn'));
                console.log('Found mode buttons:', {
                    totalButtons: buttons.length,
                    buttonTexts: buttons.map(btn => btn.textContent.trim())
                });
                
                const currentIndex = buttons.indexOf(event.target);
                console.log('Current button index:', currentIndex);
                
                const prevIndex = (currentIndex - 1 + buttons.length) % buttons.length;
                console.log('Will focus on button index:', prevIndex);
                
                buttons[prevIndex].focus();
                console.log('Focus set to:', {
                    buttonText: buttons[prevIndex].textContent.trim(),
                    newActiveElement: document.activeElement
                });
            },
            focusNextButton(event) {
                console.log('focusNextButton triggered', {
                    eventTarget: event.target,
                    eventType: event.type,
                    currentActiveElement: document.activeElement
                });
                
                const buttons = Array.from(document.querySelectorAll('.mode-btn'));
                console.log('Found mode buttons:', {
                    totalButtons: buttons.length,
                    buttonTexts: buttons.map(btn => btn.textContent.trim())
                });
                
                const currentIndex = buttons.indexOf(event.target);
                console.log('Current button index:', currentIndex);
                
                const nextIndex = (currentIndex + 1) % buttons.length;
                console.log('Will focus on button index:', nextIndex);
                
                buttons[nextIndex].focus();
                console.log('Focus set to:', {
                    buttonText: buttons[nextIndex].textContent.trim(),
                    newActiveElement: document.activeElement
                });
            },
            focusUpButton(event) {
                console.log('focusUpButton triggered', {
                    eventTarget: event.target,
                    eventType: event.type,
                    currentActiveElement: document.activeElement
                });
                
                const buttons = Array.from(document.querySelectorAll('.mode-btn'));
                console.log('Found mode buttons:', {
                    totalButtons: buttons.length,
                    buttonTexts: buttons.map(btn => btn.textContent.trim())
                });
                
                const currentIndex = buttons.indexOf(event.target);
                console.log('Current button index:', currentIndex);
                
                const COLS = window.innerWidth <= 600 ? 1 : 2;
                console.log('Grid layout:', {
                    columns: COLS,
                    windowWidth: window.innerWidth
                });
                
                const prevIndex = currentIndex - COLS;
                console.log('Calculated previous index:', prevIndex);
                
                if (prevIndex >= 0) {
                    console.log('Moving up to index:', prevIndex);
                    buttons[prevIndex].focus();
                } else {
                    // 如果到达顶部，跳转到最后一行的相同列
                    const sameColBottom = currentIndex % COLS + Math.floor((buttons.length - 1) / COLS) * COLS;
                    console.log('Wrapping to bottom, calculated index:', {
                        currentCol: currentIndex % COLS,
                        lastRowStart: Math.floor((buttons.length - 1) / COLS) * COLS,
                        targetIndex: sameColBottom
                    });
                    
                    if (sameColBottom < buttons.length) {
                        buttons[sameColBottom].focus();
                    } else {
                        buttons[buttons.length - 1].focus();
                    }
                }
                
                console.log('Focus set to:', {
                    buttonText: document.activeElement.textContent.trim(),
                    newActiveElement: document.activeElement
                });
            },
            focusDownButton(event) {
                console.log('focusDownButton triggered', {
                    eventTarget: event.target,
                    eventType: event.type,
                    currentActiveElement: document.activeElement
                });
                
                const buttons = Array.from(document.querySelectorAll('.mode-btn'));
                console.log('Found mode buttons:', {
                    totalButtons: buttons.length,
                    buttonTexts: buttons.map(btn => btn.textContent.trim())
                });
                
                const currentIndex = buttons.indexOf(event.target);
                console.log('Current button index:', currentIndex);
                
                const COLS = window.innerWidth <= 600 ? 1 : 2;
                console.log('Grid layout:', {
                    columns: COLS,
                    windowWidth: window.innerWidth
                });
                
                const nextIndex = currentIndex + COLS;
                console.log('Calculated next index:', nextIndex);
                
                if (nextIndex < buttons.length) {
                    console.log('Moving down to index:', nextIndex);
                    buttons[nextIndex].focus();
                } else {
                    // 如果到达底部，跳转到第一行的相同列
                    const sameColTop = currentIndex % COLS;
                    console.log('Wrapping to top, calculated index:', {
                        currentCol: currentIndex % COLS,
                        targetIndex: sameColTop
                    });
                    buttons[sameColTop].focus();
                }
                
                console.log('Focus set to:', {
                    buttonText: document.activeElement.textContent.trim(),
                    newActiveElement: document.activeElement
                });
            },

            getFocusableElements() {
                // 获取当前页面中所有可聚焦的元素
                if (this.pageState === 'setDescription') {
                    // 在题库详情页中，只获取模式按钮
                    return Array.from(document.querySelectorAll('.mode-btn'))
                        .filter(el => {
                            const style = window.getComputedStyle(el);
                            return style.display !== 'none' && style.visibility !== 'hidden';
                        });
                }
                
                const selector = 'button, [tabindex="0"], a[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled])';
                return Array.from(this.$el.querySelectorAll(selector))
                    .filter(el => {
                        // 确保元素是可见的
                        const style = window.getComputedStyle(el);
                        return style.display !== 'none' && style.visibility !== 'hidden';
                    });
            },
            initModeButtonsFocus() {
                // 确保第一个按钮获得焦点
                if (this.pageState === 'setDescription') {
                    this.$nextTick(() => {
                        const firstBtn = this.$refs.firstModeBtn;
                        if (firstBtn) {
                            firstBtn.focus();
                        }
                    });
                }
            },
            // URL参数处理
            async handleUrlParams() {
                const urlParams = new URLSearchParams(window.location.search);
                const bankParam = urlParams.get('bank');
                const stateParam = urlParams.get('state');
                const modeParam = urlParams.get('mode');
                const qidParam = urlParams.get('qid');
                
                console.log('[handleUrlParams] Processing URL parameters:', {
                    bank: bankParam,
                    state: stateParam,
                    mode: modeParam,
                    qid: qidParam
                });
                
                if (!bankParam) {
                    console.log('[handleUrlParams] No bank parameter, staying on home page');
                    return;
                }

                // 确保题库列表已加载
                if (this.fileList.length === 0) {
                    console.log('[handleUrlParams] File list not loaded yet, waiting...');
                    await this.loadBankList();
                }

                // 验证题库是否存在
                const bankExists = this.fileList.some(f => f.file === bankParam);
                if (!bankExists) {
                    console.error('[handleUrlParams] Bank not found:', bankParam);
                    alert('找不到指定的题库');
                    this.resetAllState();
                    return;
                }
                
                try {
                    this.isLoading = true;
                    // 加载题库数据
                    console.log('[handleUrlParams] Loading bank data:', bankParam);
                    const data = await this.jsonLoader.loadFile(bankParam);
                    console.log('[handleUrlParams] Bank data loaded:', {
                        setName: data.sets[0]?.name,
                        questionCount: data.questions?.length
                    });
                    
                    // Set chosenSet with proper id
                    this.chosenSet = {
                        ...data.sets[0],
                        id: bankParam.replace('.json', '') // Ensure id matches the file name without extension
                    };
                    
                    // 更新统计数据
                    console.log('[handleUrlParams] Updating bank stats');
                    const stats = await this.storageManager.getBankStats(bankParam, this.jsonLoader);
                    this.bankStats[bankParam] = stats;
                    
                    // 根据state参数设置页面状态
                    if (stateParam === 'quiz' && modeParam) {
                        console.log('[handleUrlParams] Setting up quiz mode:', modeParam);
                        await this.setupQuizMode(modeParam, qidParam);
                    } else {
                        console.log('[handleUrlParams] Setting page state to:', stateParam || 'setDescription');
                        this.pageState = stateParam || 'setDescription';
                    }
                } catch (error) {
                    console.error('[handleUrlParams] Failed to process URL parameters:', error);
                    alert('加载题库失败: ' + error.message);
                    this.resetAllState();
                } finally {
                    this.isLoading = false;
                }
            },

            // 设置练习模式，支持qid跳转
            async setupQuizMode(mode, qid = null) {
                console.log('[setupQuizMode] Setting up quiz mode:', mode, {
                    currentQuestions: this.jsonLoader.questions?.length,
                    qid
                });
                try {
                    // 确保我们使用的是当前加载的题库数据
                    const questions = this.jsonLoader.questions;
                    if (!questions || questions.length === 0) {
                        throw new Error('No questions available for quiz mode');
                    }

                    switch(mode) {
                        case 'all':
                            this.practiceManager.initPractice(questions, 'sequence');
                            this.practiceManager.togglePreviewMode(false);
                            break;
                        case 'wrong':
                            this.practiceManager.initPractice(questions, 'error-rate');
                            this.practiceManager.togglePreviewMode(false);
                            break;
                        case 'random':
                            this.practiceManager.initPractice(questions, 'random');
                            this.practiceManager.togglePreviewMode(false);
                            break;
                        case 'preview':
                            this.practiceManager.initPractice(questions, 'sequence');
                            this.practiceManager.togglePreviewMode(true);
                            this.showAnswer = true;
                            break;
                    }

                    // 跳转到指定题目
                    if (qid) {
                        // 尝试通过序号定位（序号从1开始）
                        const num = parseInt(qid);
                        if (!isNaN(num) && num >= 1 && num <= this.practiceManager.questions.length) {
                            this.practiceManager.currentIndex = num - 1;
                        }
                    }

                    console.log('[setupQuizMode] Practice manager initialized with questions:', questions.length);
                    this.resetQuizState();
                    this.pageState = 'quiz';
                    
                    // 更新URL参数，确保包含当前题目序号
                    const currentFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                    this.updateUrlParams('quiz', {
                        mode: mode,
                        qid: this.practiceManager.currentIndex + 1,
                        bank: currentFile
                    });
                    
                    console.log('[setupQuizMode] Quiz mode setup completed');
                } catch (error) {
                    console.error('[setupQuizMode] Failed to setup quiz mode:', error);
                    this.resetAllState();
                }
            },

            // 处理浏览器前进/后退
            async handlePopState(event) {
                console.log('[handlePopState] Processing popstate event:', event);
                const urlParams = new URLSearchParams(window.location.search);
                const bankParam = urlParams.get('bank');
                const stateParam = urlParams.get('state');
                const modeParam = urlParams.get('mode');
                const practiceModeParam = urlParams.get('practiceMode');
                const countParam = urlParams.get('count');
                
                console.log('[handlePopState] URL parameters:', {
                    bank: bankParam,
                    state: stateParam,
                    mode: modeParam,
                    practiceMode: practiceModeParam,
                    count: countParam
                });
                
                if (!bankParam && modeParam !== 'cross') {
                    console.log('[handlePopState] No bank parameter and not cross mode, resetting state');
                    this.resetAllState();
                    return;
                }
                
                try {
                    if (modeParam === 'cross') {
                        // 跨卷练习模式
                        if (this.chosenSet?.isCrossPractice) {
                            // 已经在跨卷练习中，保持状态
                            console.log('[handlePopState] Already in cross practice mode');
                            return;
                        }
                        // 否则重置到首页
                        console.log('[handlePopState] Invalid cross practice state, resetting');
                        this.resetAllState();
                        return;
                    }

                    // 普通题库模式
                    const currentFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                    console.log('[handlePopState] Checking bank change:', {
                        current: currentFile,
                        new: bankParam
                    });
                    
                    if (bankParam !== currentFile) {
                        console.log('[handlePopState] Loading new bank data');
                        const data = await this.jsonLoader.loadFile(bankParam);
                        // Set chosenSet with proper id
                        this.chosenSet = {
                            ...data.sets[0],
                            id: bankParam.replace('.json', '') // Ensure id matches the file name without extension
                        };
                        // 更新统计数据
                        await this.loadBankStats(bankParam);
                    }
                    
                    // 根据state参数切换状态
                    if (stateParam) {
                        console.log('[handlePopState] Processing state:', stateParam);
                        switch(stateParam) {
                            case 'quiz':
                                if (modeParam) {
                                    console.log('[handlePopState] Setting up quiz mode:', modeParam);
                                    this.setupQuizMode(modeParam);
                                }
                                break;
                            case 'setDescription':
                                console.log('[handlePopState] Switching to setDescription');
                                this.pageState = 'setDescription';
                                break;
                            default:
                                console.log('[handlePopState] Invalid state, resetting');
                                this.resetAllState();
                        }
                    } else {
                        console.log('[handlePopState] No state parameter, defaulting to setDescription');
                        this.pageState = 'setDescription';
                    }
                } catch (error) {
                    console.error('[handlePopState] Failed to handle popstate:', error);
                    this.resetAllState();
                }
            },

            // 处理 URL 变化
            async handleUrlChange(event) {
                // 避免重复处理 popstate 事件
                if (event.type === 'popstate') {
                    return;
                }

                console.log('[handleUrlChange] URL changed:', {
                    oldURL: event.oldURL,
                    newURL: event.newURL || window.location.href
                });

                await this.handleUrlParams();
            },

            // 更新URL参数
            updateUrlParams(state, params = {}) {
                console.log('[updateUrlParams] Updating URL parameters:', {
                    state,
                    params,
                    isCrossPractice: this.chosenSet?.isCrossPractice
                });

                const url = new URL(window.location.href);
                const newParams = new URLSearchParams();
                
                // 设置页面状态
                newParams.set('state', state);
                
                if (state === 'quiz') {
                    if (this.chosenSet?.isCrossPractice) {
                        // 跨题练习模式
                        newParams.set('mode', 'cross');
                        newParams.set('practiceMode', this.crossPracticeMode);
                        newParams.set('count', this.crossPracticeCount);
                        
                        // 如果有当前题目，添加原题库信息
                        const currentQuestion = this.practiceManager?.getCurrentQuestion();
                        if (currentQuestion) {
                            const originalBank = this.findOriginalBank(currentQuestion);
                            if (originalBank) {
                                newParams.set('sourceBank', originalBank.file);
                            }
                        }
                    } else {
                        // 普通练习模式
                        newParams.set('mode', params.mode || this.getCurrentMode());
                        if (params.qid) {
                            newParams.set('qid', params.qid);
                        }
                        if (params.bank) {
                            newParams.set('bank', params.bank);
                        }
                    }
                } else if (state === 'setDescription' && params.bank) {
                    newParams.set('bank', params.bank);
                }
                
                // 更新URL，不刷新页面
                url.search = newParams.toString();
                window.history.pushState({
                    state,
                    params: Object.fromEntries(newParams.entries())
                }, '', url);
                
                console.log('[updateUrlParams] URL updated:', url.toString());
            },

            // 重置所有状态
            resetAllState() {
                this.pageState = 'home';
                this.chosenSet = null;
                this.practiceManager?.reset();
                this.resetQuizState();
                this.showExportButton = false;
                this.isEditing = false;
                this.editingField = null;
                this.editingContent = '';
            },

            // 重置答题状态
            resetQuizState() {
                this.chosenAnswer = '';
                this.chosenAnswers = [];
                this.shortAnswerText = '';
                this.fillInAnswers = [];
                this.currentSessionCompleted.clear();
                this.showAnswer = false;
            },

            // 全局Alt+H返回上一级快捷键
            handleGlobalBackShortcut(e) {
                const tag = document.activeElement && document.activeElement.tagName;
                if (tag === 'INPUT' || tag === 'TEXTAREA') return;

                if (e.altKey && (e.key === 'h' || e.key === 'H')) {
                    console.log('[handleGlobalBackShortcut] Alt+H detected, pageState:', this.pageState);
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    switch (this.pageState) {
                        case 'quiz':
                        case 'orderQuiz':
                        case 'randomQuiz':
                            if (!this.isEditing) {
                                console.log('[handleGlobalBackShortcut] Calling goBack() from quiz mode');
                                this.goBack();
                            }
                            break;
                        case 'setDescription':
                                            this.updatePageState('home');
                            break;
                        case 'home':
                            // 在首页不做任何操作
                            break;
                    }
                    return false;
                }
            },

            // 返回上一页
            goBack() {
                if (this.pageState === 'quiz') {
                    // 如果有完成的题目，显示确认对话框
                    if (this.currentSessionCompleted.size > 0) {
                        if (!confirm('确定要退出练习吗？当前进度将不会保存。')) {
                            return;
                        }
                    }
                }
                
                // 重置状态
                this.resetAllState();
                this.updatePageState('home');
            },

            // 获取题目所属的题库
            getBankByQuestion(question) {
                return this.filteredBankDistribution.find(
                    bank => bank.questions.some(q => q.uniqueId === question.uniqueId)
                );
            },

            // 开始跨卷练习
            async startCrossPractice() {
                if (!this.canStartCrossPractice) return;
                
                try {
                    this.isLoading = true;
                    
                    // 先加载所有需要的题库
                    const banksToLoad = this.filteredBankDistribution
                        .filter(bank => !this.jsonLoader.loadedBanks.has(bank.file))
                        .map(bank => bank.file);
                    
                    if (banksToLoad.length > 0) {
                        await this.jsonLoader.loadMultipleBanks(banksToLoad);
                    }

                    // 收集所有符合条件的题目
                    let allQuestions = [];
                    this.filteredBankDistribution.forEach(bank => {
                        const bankQuestions = this.jsonLoader.getQuestionsFromBank(bank.file)
                            .filter(q => this.selectedQuestionTypes.includes(q.type));
                        allQuestions = allQuestions.concat(bankQuestions);
                    });

                    if (allQuestions.length === 0) {
                        throw new Error('没有找到符合条件的题目');
                    }

                    if (this.crossPracticeCount > allQuestions.length) {
                        this.crossPracticeCount = allQuestions.length;
                    }

                    // 根据模式排序题目
                    if (this.crossPracticeMode === 'error-rate') {
                        allQuestions.sort((a, b) => {
                            const statsA = this.storageManager.getQuestionStats(this.getBankByQuestion(a).file, a.uniqueId);
                            const statsB = this.storageManager.getQuestionStats(this.getBankByQuestion(b).file, b.uniqueId);
                            const errorRateA = statsA ? 1 - (statsA.correct / statsA.attempts) : 1;
                            const errorRateB = statsB ? 1 - (statsB.correct / statsB.attempts) : 1;
                            return errorRateB - errorRateA;
                        });
                    } else {
                        // 随机模式
                        allQuestions = this.shuffleArray(allQuestions);
                    }

                    // 选择指定数量的题目
                    const selectedQuestions = allQuestions.slice(0, this.crossPracticeCount);

                    // 为每个题目添加来源题库信息并打乱选项
                    const questionsWithSource = selectedQuestions.map(q => {
                        const questionCopy = {...q};
                        // 如果是单选或多选题，打乱选项
                        if ((questionCopy.type === 'single-choice' || questionCopy.type === 'multiple-choice') && Array.isArray(questionCopy.options)) {
                            const originalOptions = [...questionCopy.options];
                            const originalCorrectAnswer = [...questionCopy.correct_answer];
                            const shuffledOptions = this.shuffleArray([...originalOptions]);
                            
                            // 更新正确答案
                            if (questionCopy.type === 'single-choice') {
                                const oldCorrectAnswer = originalCorrectAnswer[0];
                                const newIndex = shuffledOptions.indexOf(oldCorrectAnswer);
                                if (newIndex !== -1) {
                                    questionCopy.correct_answer = [shuffledOptions[newIndex]];
                                }
                            } else {
                                questionCopy.correct_answer = originalCorrectAnswer.map(ans => {
                                    const newAns = shuffledOptions[originalOptions.indexOf(ans)];
                                    return newAns;
                                });
                            }
                            questionCopy.options = shuffledOptions;
                        }
                        return {
                            ...questionCopy,
                            sourceBank: this.getBankByQuestion(q).name || '未知题库'
                        };
                    });

                    // 创建虚拟题库集合
                    const virtualSet = {
                        id: 'cross-practice-' + Date.now(),
                        name: '跨卷练习',
                        description: `从${this.filteredBankDistribution.length}个题库中选择的${this.crossPracticeCount}道题目\n\n包含题库：\n${this.filteredBankDistribution.map(bank => `- ${bank.name} (${bank.questionCount}题)`).join('\n')}`,
                        isCrossPractice: true
                    };

                    // 初始化练习
                    this.chosenSet = virtualSet;
                    this.practiceManager.initPractice(questionsWithSource, this.crossPracticeMode);
                    this.showCrossPracticeModal = false;
                    this.updatePageState('quiz', { 
                        mode: 'cross',
                        practiceMode: this.crossPracticeMode,
                        count: this.crossPracticeCount
                    });
                } catch (error) {
                    console.error('Failed to start cross practice:', error);
                    alert(error.message || '启动跨卷练习失败');
                } finally {
                    this.isLoading = false;
                }
            },

            // 数组随机打乱
            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            },

            // 验证题目数量
            handleQuestionInput(event) {
                const rawValue = event.target.value;
                console.log('[handleQuestionInput] Input event:', {
                    type: event.type,
                    rawValue: rawValue,
                    maxQuestionCount: this.maxQuestionCount
                });

                let value = parseInt(rawValue);
                
                // 允许输入框暂时为空
                if (rawValue === '') {
                    this.crossPracticeCount = '';
                    return;
                }

                // 确保输入的是数字
                if (!isNaN(value)) {
                    // 不在这里限制最大值，让用户可以输入任何数字
                    this.crossPracticeCount = value;
                    // 更新分布但不限制输入值
                    this.updateBankDistribution();
                }
            },

            // 在失去焦点时验证和更新值
            handleQuestionBlur() {
                console.log('[handleQuestionBlur] Validating value:', {
                    currentCount: this.crossPracticeCount,
                    maxCount: this.maxQuestionCount
                });
                
                let value = parseInt(this.crossPracticeCount);
                
                // 处理无效输入
                if (isNaN(value) || value < 1) {
                    value = 1;
                }
                
                // 在失去焦点时才限制最大值
                if (value > this.maxQuestionCount) {
                    value = this.maxQuestionCount;
                }
                
                this.crossPracticeCount = value;
                this.updateBankDistribution();
            },

            // 更新题库分布
            updateBankDistribution() {
                console.log('[updateBankDistribution] Updating with count:', {
                    requestedCount: this.crossPracticeCount,
                    maxAvailable: this.maxQuestionCount
                });
                
                // 确保 crossPracticeCount 是有效的数字
                let totalRequestedQuestions = Math.max(1, parseInt(this.crossPracticeCount) || 0);
                
                // 不在这里限制最大值，让分配逻辑处理超出的情况
                let remainingQuestions = totalRequestedQuestions;
                
                // 获取有可用题目的题库
                const availableBanks = this.filteredBankDistribution.filter(bank => bank.availableQuestions > 0);
                if (availableBanks.length === 0) {
                    console.log('[updateBankDistribution] No available banks found');
                    return;
                }

                // 计算总可用题目数
                const totalAvailable = availableBanks.reduce((sum, bank) => sum + bank.availableQuestions, 0);
                
                // 按比例分配题目
                availableBanks.forEach(bank => {
                    const proportion = bank.availableQuestions / totalAvailable;
                    bank.questionCount = Math.min(
                        Math.floor(remainingQuestions * proportion),
                        bank.availableQuestions
                    );
                    remainingQuestions -= bank.questionCount;
                });

                // 分配剩余的题目
                while (remainingQuestions > 0) {
                    let distributed = false;
                    for (const bank of availableBanks) {
                        if (bank.questionCount < bank.availableQuestions) {
                            bank.questionCount++;
                            remainingQuestions--;
                            distributed = true;
                            if (remainingQuestions === 0) break;
                        }
                    }
                    if (!distributed) break;
                }

                console.log('[updateBankDistribution] Final distribution:', 
                    this.filteredBankDistribution.map(bank => ({
                        name: bank.name,
                        available: bank.availableQuestions,
                        assigned: bank.questionCount,
                        percentage: this.calculateBankPercentage(bank)
                    }))
                );
            },
            backToHome() {
                if (this.showAnswer || confirm('确定要退出练习吗？当前进度将不会保存。')) {
                    this.updatePageState('home');
                }
            },

            // 复制当前题目链接
            async copyCurrentLink() {
                try {
                    const url = new URL(window.location.href);
                    const params = new URLSearchParams(url.search);
                    
                    // 获取当前题目
                    const currentQuestion = this.practiceManager.getCurrentQuestion();
                    if (!currentQuestion) return;

                    let bankFile, questionSequenceNumber;
                    
                    if (this.chosenSet.isCrossPractice) {
                        // 对于跨题练习，找到原题库
                        const originalBank = this.findOriginalBank(currentQuestion);
                        if (originalBank) {
                            bankFile = originalBank.file;
                            // 在原题库中查找题目序号
                            const originalQuestions = this.jsonLoader.getQuestionsFromBank(bankFile);
                            questionSequenceNumber = originalQuestions.findIndex(q => 
                                q.uniqueId === currentQuestion.uniqueId
                            ) + 1;
                        }
                    } else {
                        // 普通练习模式
                        bankFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                        questionSequenceNumber = this.practiceManager.currentIndex + 1;
                    }

                    if (bankFile && questionSequenceNumber > 0) {
                        // 更新URL参数
                        this.updateUrlParams('quiz', {
                            mode: 'all', // 使用普通练习模式的链接
                            qid: questionSequenceNumber,
                            bank: bankFile
                        });
                        
                        // 获取更新后的URL
                        const finalUrl = window.location.href;
                        await navigator.clipboard.writeText(finalUrl);
                        
                        // 显示成功提示
                        this.showToast('链接已复制到剪贴板');
                    } else {
                        throw new Error('无法找到原题目位置');
                    }
                } catch (error) {
                    console.error('Failed to copy link:', error);
                    this.showToast('复制链接失败', 'error');
                }
            },
            saveCurrentEdit() {
                this.questionManager.saveCurrentEdit();
                // 更新修改计数
                this.modifiedCount = this.questionManager.getModifiedQuestions().length;
                // 导出修改后的JSON
                this.exportModifiedData();
            },
            // 获取当前练习模式
            getCurrentMode() {
                if (!this.practiceManager) return 'all';
                if (this.isEditing) return 'preview';
                if (this.practiceManager.mode === 'random') return 'random';
                if (this.practiceManager.mode === 'error-rate') return 'wrong';
                return 'all';
            },
            // 获取当前题目ID
            getCurrentQuestionId() {
                if (!this.practiceManager || !this.practiceManager.questions) return null;

                const currentQuestion = this.practiceManager.getCurrentQuestion();
                if (!currentQuestion) return null;

                if (this.chosenSet.isCrossPractice) {
                    // 对于跨题练习，返回原题库中的序号
                    const originalBank = this.findOriginalBank(currentQuestion);
                    if (originalBank) {
                        const originalQuestions = this.jsonLoader.getQuestionsFromBank(originalBank.file);
                        const index = originalQuestions.findIndex(q => q.uniqueId === currentQuestion.uniqueId);
                        return index >= 0 ? index + 1 : null;
                    }
                    return null;
                }

                // 普通练习模式
                return this.practiceManager.currentIndex + 1;
            },
            // 初始化键盘事件监听
            initKeyboardEvents() {
                this.$nextTick(() => {
                    if (this.pageState === 'setDescription') {
                        console.log('Page mounted in setDescription state');
                        const buttons = document.querySelectorAll('.mode-btn');
                        console.log('Initial mode buttons state:', {
                            totalButtons: buttons.length,
                            buttonElements: Array.from(buttons).map(btn => ({
                                text: btn.textContent.trim(),
                                tabIndex: btn.tabIndex,
                                hasClickHandler: btn.onclick !== null,
                                hasKeydownHandler: btn.onkeydown !== null
                            }))
                        });
                    }
                });

                // 添加浏览器前进/后退按钮支持
                window.addEventListener('popstate', this.handlePopState);

                // 添加 URL 变化监听
                window.addEventListener('hashchange', this.handleUrlChange);
                window.addEventListener('popstate', this.handleUrlChange);

                // 添加全局Alt+H返回快捷键
                window.addEventListener('keydown', this.handleGlobalBackShortcut);
            },
            calculateBankPercentage(bank) {
                if (!bank || typeof bank.questionCount !== 'number' || typeof bank.availableQuestions !== 'number' || bank.availableQuestions === 0) {
                    return 0;
                }
                return Math.round((bank.questionCount / bank.availableQuestions) * 100) || 0;
            },
            showToast(message, type = 'success') {
                const toast = document.createElement('div');
                toast.textContent = message;
                toast.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: ${type === 'success' ? 'rgba(0, 0, 0, 0.8)' : 'rgba(255, 0, 0, 0.8)'};
                    color: white;
                    padding: 8px 16px;
                    border-radius: 4px;
                    z-index: 1000;
                `;
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 2000);
            },
            // 添加 goHome 方法
            goHome(event) {
                event.preventDefault();
                if (this.pageState === 'quiz') {
                    // 如果有完成的题目，显示确认对话框
                    if (this.currentSessionCompleted.size > 0) {
                        if (!confirm('确定要退出练习吗？当前进度将不会保存。')) {
                            return;
                        }
                    }
                }
                
                // 重置状态
                this.resetAllState();
                this.updatePageState('home');
            },
        }
    });

    app.mount('#app');
</script>

</body>
</html>