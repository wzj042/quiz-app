<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8" />
    <title>刷题</title>
    <meta name="referrer" content="no-referrer">
    <link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/katex.min.css">
    <script defer src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/katex.min.js"></script>
    <script defer
        src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/contrib/auto-render.min.js"></script>
    <script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vue/3.2.23/vue.global.prod.min.js"></script>
    <script src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/marked/4.0.2/marked.min.js"></script>
    <link rel="stylesheet" href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css">
    <!-- 添加 highlight.js -->
    <link href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/highlight.js/11.4.0/styles/qtcreator-light.min.css"
        type="text/css" rel="stylesheet" />
    <script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/highlight.js/11.4.0/highlight.min.js"
        type="application/javascript"></script>
    <!-- 添加 SQL 语言支持 -->
    <script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/highlight.js/11.4.0/languages/sql.min.js"
        type="application/javascript"></script>

    <!-- 配置 marked 和 highlight.js -->
    <script>
        // 配置 marked 的代码高亮
        marked.setOptions({
            highlight: function (code, lang) {
                if (lang) {
                    try {
                        const highlighted = hljs.highlight(code, {
                            language: lang.toLowerCase(),
                            ignoreIllegals: true
                        }).value;
                        return `<pre data-language="${lang}"><code class="hljs language-${lang}">${highlighted}</code></pre>`;
                    } catch (e) {
                        console.warn('Language highlight failed:', e);
                        return `<pre data-language="${lang}"><code class="hljs">${hljs.highlightAuto(code).value}</code></pre>`;
                    }
                }
                return `<pre><code class="hljs">${hljs.highlightAuto(code).value}</code></pre>`;
            },
            breaks: true,
            gfm: true
        });
    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/mobile.css?v=_timestamp_">
    <link rel="icon" href="favicon.ico?v=_timestamp_" type="image/x-icon">
    <script>
        // 动态加载 JS 模块，使用时间戳防止缓存
        window.addEventListener('DOMContentLoaded', function () {
            const timestamp = Date.now();  // 使用时间戳确保每次加载最新资源
            const modules = [
                'js/modules/DataManager.js',
                'js/modules/jsonLoader.js',
                'js/modules/keyboard.js',
                'js/modules/PracticeManager.js',
                'js/modules/ProgressManager.js',
                'js/modules/QuestionManager.js',
                'js/modules/storage.js',
                'js/modules/AIManager.js'  // 添加 AI 管理器
            ];

            // 更新 CSS 和 favicon 的时间戳
            document.querySelector('link[href*="mobile.css"]').href = `css/mobile.css?v=${timestamp}`;
            document.querySelector('link[rel="icon"]').href = `favicon.ico?v=${timestamp}`;

            // 动态加载 JS 模块
            modules.forEach(module => {
                const script = document.createElement('script');
                script.type = 'module';
                script.src = `${module}?v=${timestamp}`;
                document.head.appendChild(script);
            });

            // 添加键盘快捷键支持
            const handleKeydown = (e) => {
                // 如果正在输入，不处理快捷键
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }

                // T: 打开标签筛选
                if (e.key === 't' && !e.ctrlKey && !e.altKey && !e.shiftKey) {
                    e.preventDefault();
                    const tagsButton = document.querySelector('.tags-button');
                    if (tagsButton) tagsButton.click();
                }

                // Esc: 关闭模态窗口
                if (e.key === 'Escape') {
                    const modalOverlay = document.querySelector('.modal-overlay');
                    if (modalOverlay) {
                        const closeBtn = modalOverlay.querySelector('.close-btn');
                        if (closeBtn) closeBtn.click();
                    }
                }

                // Ctrl + S: 导出修改
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    const exportBtn = document.querySelector('.export-btn');
                    if (exportBtn) exportBtn.click();
                }
            };

            document.addEventListener('keydown', handleKeydown);

            // 初始化焦点管理
            initFocusManagement();
        });

        function initFocusManagement() {
            // 模态窗口焦点管理
            const modalOverlay = document.querySelector('.modal-overlay');
            if (modalOverlay) {
                const focusableElements = modalOverlay.querySelectorAll(
                    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                );
                const firstFocusable = focusableElements[0];
                const lastFocusable = focusableElements[focusableElements.length - 1];
                // 焦点循环
                modalOverlay.addEventListener('keydown', function (e) {
                    if (e.key === 'Tab') {
                        if (e.shiftKey) {
                            if (document.activeElement === firstFocusable) {
                                e.preventDefault();
                                lastFocusable.focus();
                            }
                        } else {
                            if (document.activeElement === lastFocusable) {
                                e.preventDefault();
                                firstFocusable.focus();
                            }
                        }
                    }
                });
            }
        }
    </script>
    <style>
        /* 移除之前的工具栏和顶部导航样式 */
        .toolbar,
        .toolbar-right,
        .nav-right,
        .nav-left {
            display: none;
        }

        /* 导航栏图标按钮样式 */
        .nav-icon-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 4px;
            color: #B8C7AB;
            background: transparent;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }

        .nav-icon-btn:hover {
            opacity: 0.8;
        }

        .nav-icon-btn svg {
            width: 24px;
            height: 24px;
        }

        /* 调整导航栏布局 */
        .nav {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-title-link {
            margin-right: auto;
        }

        /* AI 测试模态窗口样式 */
        .ai-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1000;
        }

        .ai-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ai-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .ai-modal-title {
            margin: 0;
            font-size: 1.2em;
            font-weight: 600;
        }

        .ai-modal-close {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            padding: 0;
            color: #666;
        }

        .ai-modal-close:hover {
            color: #333;
        }

        .ai-model-select {
            margin-bottom: 20px;
        }

        .ai-model-select select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
            font-size: 14px;
        }

        .ai-input-group {
            margin-bottom: 20px;
        }

        .ai-input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #333;
        }

        .ai-input-group input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        /* 自动评分开关样式 */
        .custom-switch {
            padding-left: 2.25rem;
            padding-bottom: 1rem;
            position: relative;
            display: inline-block;
        }

        .custom-control-input {
            position: absolute;
            left: 0;
            z-index: -1;
            width: 1.5rem;
            height: 1.5rem;
            opacity: 0;
        }

        .custom-control-label {
            position: relative;
            margin-bottom: 0;
            vertical-align: top;
            cursor: pointer;
            padding-left: 0.5rem;
        }

        .custom-control-label::before {
            position: absolute;
            top: 0.25rem;
            left: -2.25rem;
            display: block;
            width: 1.75rem;
            height: 1rem;
            pointer-events: none;
            content: "";
            background-color: #fff;
            border: 1px solid #adb5bd;
            border-radius: 0.5rem;
            transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }

        .custom-control-label::after {
            position: absolute;
            top: calc(0.25rem + 2px);
            left: calc(-2.25rem + 2px);
            display: block;
            width: calc(1rem - 4px);
            height: calc(1rem - 4px);
            content: "";
            background: #adb5bd;
            border-radius: 0.5rem;
            transition: transform 0.15s ease-in-out, background-color 0.15s ease-in-out;
        }

        .custom-control-input:checked ~ .custom-control-label::before {
            color: #fff;
            border-color: #B8C7AB;
            background-color: #B8C7AB;
        }

        .custom-control-input:checked ~ .custom-control-label::after {
            background-color: #fff;
            transform: translateX(0.75rem);
        }

        .custom-control-input:focus ~ .custom-control-label::before {
            box-shadow: 0 0 0 0.2rem rgba(184, 199, 171, 0.25);
        }

        .ai-chat-area {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            margin-bottom: 15px;
            background: #f9f9f9;
            font-size: 14px;
            line-height: 1.5;
        }

        .ai-input-area {
            display: flex;
            gap: 10px;
        }

        .ai-input-area textarea {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            min-height: 80px;
            font-size: 14px;
        }

        .ai-input-area button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            align-self: flex-end;
        }

        .ai-input-area button:hover {
            background: #0056b3;
        }

        .ai-input-area button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* 测试区域样式 */
        .ai-test-area {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 10px 0;
            border: 1px solid #eee;
        }

        .test-prompt {
            width: 100%;
            min-height: 80px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            font-family: inherit;
            font-size: 14px;
        }

        .test-btn {
            width: 100%;
            background: #A5B596;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
            align-self: flex-end;
            min-width: 120px;
        }

        .test-btn:hover:not(:disabled) {
            background: #2d3748;
        }

        .test-btn:disabled {
            background: #718096;
            cursor: not-allowed;
        }

        .test-result {
            margin-top: 10px;
            padding: 15px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.5;
            min-height: 100px;
            max-height: 300px;
            overflow-y: auto;
        }

        .custom-preset-form {
            background: #f8f9fa;
            border: 1px solid #eee;
            padding: 20px;
            border-radius: 4px;
            margin-top: 20px;
        }

        .custom-preset-form h4 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #333;
        }

        .form-row {
            margin-bottom: 15px;
        }

        .form-row label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #333;
        }

        .form-row input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .preset-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .preset-actions button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        .preset-actions .save-btn {
            background: #B8C7AB;
            color: white;
        }

        .preset-actions .save-btn:hover {
            background: #218838;
        }

        .preset-actions .cancel-btn {
            background: #dc3545;
            color: white;
        }

        .preset-actions .cancel-btn:hover {
            background: #c82333;
        }

        .custom-preset-trigger {
            display: block;
            width: 100%;
            padding: 12px;
            background: #f8f9fa;
            border: 1px dashed #ddd;
            border-radius: 4px;
            text-align: center;
            cursor: pointer;
            margin-top: 15px;
            color: #666;
            font-size: 14px;
        }

        .custom-preset-trigger:hover {
            background: #e9ecef;
            color: #333;
        }

        .model-description {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            padding-left: 2px;
        }

        /* 日志查看器样式 */
        .log-viewer {
            margin-top: 15px;
            border-top: 1px solid #eee;
            padding-top: 15px;
        }

        .log-viewer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .log-viewer-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .log-controls {
            display: flex;
            gap: 10px;
        }

        .log-controls select,
        .log-controls button {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            background: white;
        }

        .log-controls button {
            cursor: pointer;
        }

        .log-controls button:hover {
            background: #f8f9fa;
        }

        .log-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            background: #f8f9fa;
        }

        .log-entry {
            padding: 6px 8px;
            border-bottom: 1px solid #eee;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-entry.debug {
            color: #6c757d;
        }

        .log-entry.info {
            color: #17a2b8;
        }

        .log-entry.warn {
            color: #ffc107;
        }

        .log-entry.error {
            color: #dc3545;
        }

        .log-timestamp {
            color: #666;
            margin-right: 8px;
        }

        .log-level {
            font-weight: bold;
            margin-right: 8px;
        }

        .log-message {
            white-space: pre-wrap;
            word-break: break-all;
        }

        .log-data {
            margin-top: 4px;
            padding-left: 16px;
            color: #666;
            font-style: italic;
        }

        /* Markdown 渲染样式 */
        .markdown-content {
            font-size: 14px;
            line-height: 1.6;
        }

        .markdown-content h1,
        .markdown-content h2,
        .markdown-content h3,
        .markdown-content h4,
        .markdown-content h5,
        .markdown-content h6 {
            margin-top: 16px;
            margin-bottom: 8px;
            line-height: 1.25;
        }

        .markdown-content h1 {
            font-size: 2em;
        }

        .markdown-content h2 {
            font-size: 1.5em;
        }

        .markdown-content h3 {
            font-size: 1.25em;
        }

        .markdown-content h4 {
            font-size: 1em;
        }

        .markdown-content p {
            margin: 8px 0;
        }

        .markdown-content pre {
            background-color: #f6f8fa;
            border-radius: 4px;
            padding: 16px;
            overflow: auto;
            margin: 8px 0;
        }

        .markdown-content code {
            font-family: monospace;
            background-color: #f6f8fa;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }

        .markdown-content pre code {
            padding: 0;
            background-color: transparent;
        }

        .markdown-content blockquote {
            margin: 8px 0;
            padding: 0 16px;
            color: #666;
            border-left: 4px solid #ddd;
        }

        .markdown-content ul,
        .markdown-content ol {
            margin: 8px 0;
            padding-left: 24px;
        }

        .markdown-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 8px 0;
        }

        .markdown-content table th,
        .markdown-content table td {
            padding: 6px 12px;
            border: 1px solid #ddd;
        }

        .markdown-content table th {
            background-color: #f6f8fa;
        }

        .markdown-content img {
            max-width: 100%;
            height: auto;
        }

        .markdown-content hr {
            margin: 16px 0;
            border: none;
            border-top: 1px solid #ddd;
        }

        .markdown-content a {
            color: #0366d6;
            text-decoration: none;
        }

        .markdown-content a:hover {
            text-decoration: underline;
        }

        /* 预览区域样式 */
        .preview-area {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            background: #fff;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
        }

        .preview-area:empty::before {
            content: '预览区域';
            color: #999;
            font-style: italic;
        }

        /* 标签页样式 */
        .tabs {
            display: flex;
            margin-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }

        .tab {
            padding: 8px 16px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-bottom: -1px;
            background: transparent;
        }

        .tab.active {
            border-color: #ddd;
            border-radius: 4px 4px 0 0;
            background: white;
            border-bottom-color: white;
        }

        .tab:hover:not(.active) {
            background: #f8f9fa;
        }

        /* 思维链内容样式 */
        .reasoning-content {
            background-color: #f8f9fa;
            border-left: 4px solid #6c757d;
            padding: 12px;
            margin: 8px 0;
            font-size: 0.95em;
            color: #495057;
        }

        .reasoning-content::before {
            content: "思维过程";
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #6c757d;
        }

        .final-answer {
            border-left: 4px solid #B8C7AB;
            padding: 12px;
            margin: 8px 0;
        }

        .final-answer::before {
            content: "最终回答";
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #B8C7AB;
        }

        /* 按钮基础样式 */
        .ai-modal button {
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            border: none;
            outline: none;
        }

        /* 主要按钮样式 */
        .ai-modal button.primary {
            background-color: #B8C7AB;
            color: white;
            border: 1px solid #B8C7AB;
        }

        .ai-modal button.primary:hover {
            background-color: #B8C7AB;
        }

        .ai-modal button.primary:disabled {
            background-color: #A5D6A7;
            border-color: #A5D6A7;
            cursor: not-allowed;
        }

        /* 次要按钮样式 */
        .ai-modal button.secondary {
            background-color: #F5F5F5;
            color: #333;
            border: 1px solid #DDD;
        }

        .ai-modal button.secondary:hover {
            background-color: #EEEEEE;
            border-color: #CCCCCC;
        }

        /* 标签页按钮样式 */
        .ai-modal .tab {
            background-color: transparent;
            border: 1px solid transparent;
            color: #666;
            padding: 8px 16px;
            margin-right: 4px;
        }

        .ai-modal .tab:hover:not(.active) {
            background-color: #F5F5F5;
            color: #333;
        }

        .ai-modal .tab.active {
            background-color: white;
            border-color: #DDD;
            border-bottom-color: white;
            color: #B8C7AB;
            font-weight: 500;
        }

        /* 发送按钮样式 */
        .ai-modal .ai-input-area button {
            background-color: #B8C7AB;
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 4px;
            margin-left: 8px;
            transition: all 0.3s ease;
        }

        .ai-modal .ai-input-area button:hover:not(:disabled) {
            background-color: #B8C7AB;
            transform: translateY(-1px);
        }

        .ai-modal .ai-input-area button:disabled {
            background-color: #A5D6A7;
            cursor: not-allowed;
        }

        /* 关闭按钮样式 */
        .ai-modal .ai-modal-close {
            background-color: transparent;
            border: none;
            color: #666;
            font-size: 24px;
            padding: 4px 8px;
            position: absolute;
            right: 16px;
            top: 12px;
            transition: color 0.3s ease;
        }

        .ai-modal .ai-modal-close:hover {
            color: #333;
        }

        /* 自定义预设表单按钮 */
        .ai-modal .custom-preset-form .preset-actions {
            display: flex;
            gap: 8px;
            margin-top: 16px;
        }

        .ai-modal .custom-preset-form .save-btn {
            background-color: #B8C7AB;
            color: white;
        }

        .ai-modal .custom-preset-form .save-btn:hover {
            background-color: #B8C7AB;
        }

        .ai-modal .custom-preset-form .cancel-btn {
            background-color: #F5F5F5;
            color: #666;
        }

        .ai-modal .custom-preset-form .cancel-btn:hover {
            background-color: #EEEEEE;
            color: #333;
        }

        /* 添加自定义预设按钮 */
        .ai-modal .custom-preset-trigger {
            background-color: #F5F5F5;
            color: #666;
            border: 1px dashed #DDD;
            padding: 8px 16px;
            margin-top: 16px;
            width: 100%;
            text-align: center;
            transition: all 0.3s ease;
        }

        .ai-modal .custom-preset-trigger:hover {
            background-color: #EEEEEE;
            border-color: #B8C7AB;
            color: #B8C7AB;
        }

        /* 计分显示和计时器样式 */
        .score-display {
            text-align: center;
            margin: 20px 0;
            font-size: 24px;
        }

        .timer-bar {
            width: 100%;
            height: 6px;
            background: #eee;
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }

        .timer-progress {
            height: 100%;
            background: #B8C7AB;
            width: 100%;
            transition: width 0.1s linear;
        }

        .score-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .score-button {
            font-size: 20px;
            padding: 10px 25px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .score-button.positive {
            background: #B8C7AB;
            color: white;
        }

        .score-button.negative {
            background: #ff6b6b;
            color: white;
        }

        .score-button:not(.positive):not(.negative) {
            background: #f0f0f0;
            color: #666;
        }

        .score-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        /* 输入框样式统一 */
        .ai-modal input[type="text"],
        .ai-modal input[type="password"],
        .ai-modal textarea {
            border: 1px solid #DDD;
            border-radius: 4px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .ai-modal input[type="text"]:focus,
        .ai-modal input[type="password"]:focus,
        .ai-modal textarea:focus {
            border-color: #B8C7AB;
            outline: none;
        }

        /* 下拉框样式 */
        .ai-modal select {
            border: 1px solid #DDD;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 14px;
            background-color: white;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        .ai-modal select:focus {
            border-color: #B8C7AB;
            outline: none;
        }

        /* 模态框标题样式 */
        .ai-modal .ai-modal-title {
            color: #333;
            margin: 0;
            font-size: 18px;
            font-weight: 500;
        }

        /* 模态框内容区域样式 */
        .ai-modal .ai-chat-area {
            background-color: #FAFAFA;
            border: 1px solid #EEEEEE;
            border-radius: 4px;
            padding: 16px;
            margin: 16px 0;
        }

        /* AI 配置按钮样式 */
        .ai-config-trigger {
            display: inline-flex;
            align-items: center;
            padding: 6px 12px;
            background: #B8C7AB;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 8px;
            transition: all 0.3s ease;
        }

        .ai-config-trigger:hover {
            background: #A5B596;
            transform: translateY(-1px);
        }

        .ai-config-trigger svg {
            width: 16px;
            height: 16px;
            margin-right: 6px;
        }

        /* 调整顶部工具栏布局 */
        .toolbar {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 8px 16px;
            background: #fff;
            border-bottom: 1px solid #eee;
        }

        .toolbar-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ai-score-section {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-left: 4px solid #B8C7AB;
            border-radius: 4px;
        }

        .ai-score-section .empty-message {
            color: #999;
            font-style: italic;
            margin-top: 8px;
        }

        .ai-score-section .markdown-content:not(:empty) {
            margin-top: 8px;
        }

        .ai-analysis-section {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-left: 4px solid #B8C7AB;
            border-radius: 4px;
        }

        .ai-analysis-section .markdown-content:empty::before {
            content: '等待 AI 解析...';
            color: #999;
            font-style: italic;
        }

        .api-key-input-container {
            display: flex;
            gap: 8px;
        }
        .api-key-input-container input {
            flex: 4;
        }
        .delete-api-key-btn {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .delete-api-key-btn:hover {
            background: #f5f5f5;
            border-color: #ccc;
        }

        /* Toast notification styles */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
        }

        .toast {
            background-color: #333;
            color: white;
            padding: 12px 24px;
            border-radius: 4px;
            margin-bottom: 10px;
            min-width: 250px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
            animation: slideIn 0.3s ease-out;
        }

        .toast.success {
            background-color: #4caf50;
        }

        .toast.error {
            background-color: #f44336;
        }

        .toast.info {
            background-color: #2196f3;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
    </style>
</head>

<body>
    <div id="app" class="container">
        <!-- Toast container -->
        <div class="toast-container">
            <div v-for="toast in toasts" :key="toast.id" :class="['toast', toast.type]" :data-toast-id="toast.id">
                {{ toast.message }}
            </div>
        </div>

        <!-- 音效配置模态窗口 -->
        <div v-if="showSoundModal" class="ai-modal-overlay" @click.self="closeSoundModal">
            <div class="ai-modal">
                <div class="ai-modal-header">
                    <h3 class="ai-modal-title">音效配置</h3>
                    <button class="ai-modal-close" @click="closeSoundModal">&times;</button>
                </div>

                <!-- 音效启用控制 -->
                <div class="control-group">
                    <label>
                        <input type="checkbox" v-model="audioEnabled">
                        启用音效
                    </label>
                </div>

                <!-- 音量控制 -->
                <div class="control-group">
                    <label>
                        音量控制: <span>{{ volumeValue }}%</span>
                        <input type="range" v-model="volumeValue" min="0" max="100">
                    </label>
                </div>

                <!-- 时间设置 -->
                <div class="settings-group">
                    <h3>时间设置</h3>
                    <label>
                        连击窗口时间(ms):
                        <input type="number" v-model="comboWindowMs" min="1000" step="500">
                    </label>
                    <label>
                        重置时间(ms):
                        <input type="number" v-model="resetTimeoutMs" min="1000" step="500">
                    </label>
                </div>

                <!-- 计分显示和操作区域 -->
                <div class="settings-group">
                    <h3>连续评分反馈测试</h3>
                    <div class="score-display">
                        <div>连续数: <span>{{ currentScore }}</span></div>
                        <div class="timer-bar">
                            <div class="timer-progress" :style="{ width: timerProgress + '%' }"></div>
                        </div>
                        <div>剩余时间: <span>{{ timeLeft.toFixed(1) }}</span>s</div>
                    </div>
                    <div class="score-buttons">
                        <button class="score-button positive" @click="addScore">+1</button>
                        <button class="score-button negative" @click="subtractScore">-1</button>
                        <button class="score-button" @click="resetScore">重置</button>
                    </div>
                </div>

                <!-- 音效测试区域 -->
                <div class="settings-group">
                    <h3>音效测试</h3>
                    <div class="button-group">
                        <button class="positive" @click="testSound('positive', 1)">播放+1</button>
                        <button class="positive" @click="testSound('positive', 2)">播放+2</button>
                        <button class="positive" @click="testSound('positive', 3)">播放+3</button>
                    </div>
                    <div class="button-group">
                        <button class="negative" @click="testSound('negative', 1)">播放-1</button>
                        <button class="negative" @click="testSound('negative', 2)">播放-2</button>
                        <button class="negative" @click="testSound('negative', 3)">播放-3</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- AI 配置模态窗口 -->
        <div v-if="showAIModal" class="ai-modal-overlay" @click.self="closeAIModal">
            <div class="ai-modal">
                <div class="ai-modal-header">
                    <h3 class="ai-modal-title">AI 配置</h3>
                    <button class="ai-modal-close" @click="closeAIModal">&times;</button>
                </div>

                <!-- 模型选择 -->
                <div class="ai-model-select">
                    <label for="modelSelect">选择模型：</label>
                    <select id="modelSelect" v-model="selectedPresetId" @change="handlePresetChange">
                        <option v-for="(preset, id) in presets" :key="id" :value="id">
                            {{ preset?.name || id }}
                        </option>
                    </select>
                    <div class="model-description" v-if="currentPreset?.name">
                        {{ getModelDescription(selectedPresetId) }}
                    </div>
                </div>

                <!-- API Key 输入 -->
                <form class="ai-input-group" @submit.prevent v-if="currentPreset?.name">
                    <label :for="'apiKey_' + currentProvider">{{ currentPreset.name }} API Key</label>
                    <div class="api-key-input-container">
                        <input type="password" :id="'apiKey_' + currentProvider" v-model="providerApiKeys[currentProvider]"
                            @input="updateApiKey" :placeholder="`请输入 ${currentPreset.name} 的 API Key，仅本地存储`">
                        <button type="button" class="delete-api-key-btn" @click="deleteProviderApiKey" title="删除 API Key">
                            <svg viewBox="0 0 24 24" width="16" height="16">
                                <path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                            </svg>
                        </button>
                    </div>
                </form>
                <div class="api-key-help">
                    <p class="help-text">
                        {{ providerApiKeys[currentProvider] ? '🐳' : '🐋' }} <strong>获取 API Key：</strong> 
                        <a href="https://platform.deepseek.com/usage" target="_blank" rel="noopener noreferrer">
                            deepseek
                        </a>
                    </p>
                </div>

                <!-- AI 自动评分设置 -->
                <div class="ai-input-group">
                    <div class="custom-control custom-switch">
                        <input type="checkbox" class="custom-control-input" id="autoScoring" 
                            v-model="autoScoring" @change="updateAutoScoring">
                        <label class="custom-control-label" for="autoScoring">自动AI评分</label>
                    </div>
                </div>

                <!-- 流式渲染测试 -->
                <div class="ai-test-area">
                    <div class="ai-input-group">
                        <label for="testPrompt">测试提示词：</label>
                        <textarea id="testPrompt" v-model="testPrompt" rows="3" 
                            placeholder="输入测试提示词" class="test-prompt"></textarea>
                        <button class="test-btn" @click="testStreaming" :disabled="isTestingStream">
                            {{ isTestingStream ? '测试中...' : '测试连通性' }}
                        </button>
                    </div>
                    <div v-if="testStreamContent" class="test-result markdown-content" v-html="renderedTestContent()"></div>
                </div>
            </div>
        </div>

        <!-- 导航栏 -->
        <nav class="nav" role="navigation">
            <a href="#" class="nav-title-link" @click="goHome" @mouseover="hoverTitle = true"
                @mouseout="hoverTitle = false">
                <span class="nav-title">Quiz App</span>
            </a>
            <button class="nav-icon-btn" @click="showAIModal = true" title="AI 配置">
                <svg fill="currentColor" fill-rule="evenodd" height="24" viewBox="0 0 24 24" width="24"
                    xmlns="http://www.w3.org/2000/svg">
                    <path
                        d="M23.748 4.482c-.254-.124-.364.113-.512.234-.051.039-.094.09-.137.136-.372.397-.806.657-1.373.626-.829-.046-1.537.214-2.163.848-.133-.782-.575-1.248-1.247-1.548-.352-.156-.708-.311-.955-.65-.172-.241-.219-.51-.305-.774-.055-.16-.11-.323-.293-.35-.2-.031-.278.136-.356.276-.313.572-.434 1.202-.422 1.84.027 1.436.633 2.58 1.838 3.393.137.093.172.187.129.323-.082.28-.18.552-.266.833-.055.179-.137.217-.329.14a5.526 5.526 0 01-1.736-1.18c-.857-.828-1.631-1.742-2.597-2.458a11.365 11.365 0 00-.689-.471c-.985-.957.13-1.743.388-1.836.27-.098.093-.432-.779-.428-.872.004-1.67.295-2.687.684a3.055 3.055 0 01-.465.137 9.597 9.597 0 00-2.883-.102c-1.885.21-3.39 1.102-4.497 2.623C.082 8.606-.231 10.684.152 12.85c.403 2.284 1.569 4.175 3.36 5.653 1.858 1.533 3.997 2.284 6.438 2.14 1.482-.085 3.133-.284 4.994-1.86.47.234.962.327 1.78.397.63.059 1.236-.03 1.705-.128.735-.156.684-.837.419-.961-2.155-1.004-1.682-.595-2.113-.926 1.096-1.296 2.746-2.642 3.392-7.003.05-.347.007-.565 0-.845-.004-.17.035-.237.23-.256a4.173 4.173 0 001.545-.475c1.396-.763 1.96-2.015 2.093-3.517.02-.23-.004-.467-.247-.588zM11.581 18c-2.089-1.642-3.102-2.183-3.52-2.16-.392.024-.321.471-.235.763.09.288.207.486.371.739.114.167.192.416-.113.603-.673.416-1.842-.14-1.897-.167-1.361-.802-2.5-1.86-3.301-3.307-.774-1.393-1.224-2.887-1.298-4.482-.02-.386.093-.522.477-.592a4.696 4.696 0 011.529-.039c2.132.312 3.946 1.265 5.468 2.774.868.86 1.525 1.887 2.202 2.891.72 1.066 1.494 2.082 2.48 2.914.348.292.625.514.891.677-.802.09-2.14.11-3.054-.614zm1-6.44a.306.306 0 01.415-.287.302.302 0 01.2.288.306.306 0 01-.31.307.303.303 0 01-.304-.308zm3.11 1.596c-.2.081-.399.151-.59.16a1.245 1.245 0 01-.798-.254c-.274-.23-.47-.358-.552-.758a1.73 1.73 0 01.016-.588c.07-.327-.008-.537-.239-.727-.187-.156-.426-.199-.688-.199a.559.559 0 01-.254-.078c-.11-.054-.2-.19-.114-.358.028-.054.16-.186.192-.21.356-.202.767-.136 1.146.016.352.144.618.408 1.001.782.391.451.462.576.685.914.176.265.336.537.445.848.067.195-.019.354-.25.452z">
                    </path>
                </svg>
            </button>
            <button class="nav-icon-btn" @click="showSoundModal = true" title="音效配置">
                <svg fill="currentColor" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                </svg>
            </button>
            <a href="https://github.com/wzj042/quiz-app" class="github-link" target="_blank" rel="noopener noreferrer"
                aria-label="在 GitHub 上查看项目" title="项目调试中，欢迎参与开发和反馈。可参考 demo.json 格式，Fork 项目后添加自己的题库。">
                <svg class="github-icon" viewBox="0 0 16 16" width="24" height="24" aria-hidden="true">
                    <path fill="currentColor"
                        d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
                    </path>
                </svg>
            </a>
        </nav>

        <!-- 未保存修改的模态窗口 -->
        <div v-if="showUnsavedModal" class="modal-overlay" @click.self="closeUnsavedModal" role="dialog"
            aria-labelledby="unsaved-modal-title" aria-modal="true" @keydown.esc="closeUnsavedModal">
            <div class="modal-content" tabindex="-1">
                <h3 id="unsaved-modal-title">未导出的修改</h3>
                <div class="modal-body">
                    <p>当前题库有未导出的修改：</p>
                    <div class="modified-questions-list" role="list">
                        <ul>
                            <li v-for="q in groupedModifiedQuestions" :key="q.uniqueId" role="listitem">
                                题目ID: {{ q.uniqueId }}
                                <br>
                                <span class="question-preview">{{ truncateText(q.content, 50) }}</span>
                            </li>
                        </ul>
                    </div>
                    <div class="modal-actions">
                        <div class="modal-actions">
                            <div class="action-buttons">
                                <button class="btn export-btn" @click="exportModifiedData" data-shortcut="Ctrl+S">
                                    导出修改
                                </button>
                                <button class="btn close-btn" @click="closeUnsavedModalAndContinue" data-shortcut="Esc">
                                    直接退出
                                </button>
                            </div>
                            <label class="dont-show-again">
                                <input type="checkbox" v-model="dontShowExportReminder"
                                    @keydown.enter="$event.target.click()">
                                <span>不再提醒</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 列出题库 -->
        <div v-if="isLoading" class="card" role="status">
            <p>正在处理，请稍后...</p>
        </div>

        <template v-else>
            <div v-if="pageState === 'home'" class="card">
                <h1 class="title">
                    选择题库
                    <span class="update-time" v-if="updateTime">更新于: {{ formatUpdateTime(updateTime) }}</span>
                </h1>

                <!-- 总体统计 -->
                <div class="overall-stats" role="region" aria-label="总体统计">
                    <h2 class="stats-title">总体统计</h2>
                    <div class="stats-grid">
                        <div class="stats-item">
                            <div class="stats-value">{{ totalStats.completedQuestions }}/{{ totalStats.totalAttempts }}
                            </div>
                            <div class="stats-label">总练习题数</div>
                        </div>
                        <div class="stats-item">
                            <div class="stats-value">{{ totalStats.averageAccuracy }}%</div>
                            <div class="stats-label">平均正确率</div>
                        </div>
                        <div class="stats-item">
                            <div class="stats-value">{{ totalStats.todayPracticed }}</div>
                            <div class="stats-label">今日已练习</div>
                        </div>
                    </div>
                    <button class="cross-practice-btn" @click="showCrossPracticeModal = true">
                        <i class="fas fa-random"></i>
                        跨卷练习设置
                    </button>
                </div>

                <!-- 题库列表 -->
                <template v-if="fileList.length > 0">
                    <ul class="horizontal-list" role="list">
                        <!-- Tags筛选器 -->
                        <div class="tags-filter" role="region" aria-label="标签筛选">
                            <div class="top-tags">
                                <button v-for="tag in topTags" :key="tag.tag"
                                    :class="['tag-chip', { active: selectedTags.includes(tag.tag) }]"
                                    @click="toggleTag(tag.tag)" :aria-pressed="selectedTags.includes(tag.tag)"
                                    :aria-label="'选择标签: ' + tag.tag">
                                    {{ tag.tag }}
                                    <span v-if="selectedTags.includes(tag.tag)" class="tag-count">({{ tag.count
                                        }})</span>
                                </button>
                            </div>
                            <button :class="['tags-button', { 'has-active': selectedTags.length > 0 }]"
                                @click="showTagsModal = true" aria-label="更多标签" data-shortcut="T">
                                <i class="fas fa-tags" aria-hidden="true"></i>
                            </button>
                        </div>

                        <template v-for="(group, groupIndex) in filteredGroupedFileList" :key="groupIndex">
                            <li class="category-header" role="separator">
                                <h2>{{ group[0] }}</h2>
                                <hr>
                            </li>
                            <li v-for="(fileObj, idx) in group[1]" :key="idx" class="quiz-item" role="button"
                                tabindex="0" @click="loadJsonFile(fileObj.file)"
                                @keydown.enter="loadJsonFile(fileObj.file)"
                                @keydown.space.prevent="loadJsonFile(fileObj.file)">
                                <div class="quiz-item-content">
                                    <div class="quiz-item-title">{{ fileObj.name }}</div>
                                    <div class="quiz-item-tags" v-if="fileObj.tags && fileObj.tags.length">
                                        <span v-for="tag in fileObj.tags.slice(0, 3)" :key="tag" class="item-tag">
                                            {{ tag }}
                                        </span>
                                    </div>
                                    <div class="quiz-item-stats" v-if="bankStats[fileObj.file]">
                                        <div class="quiz-stat">
                                            共{{ bankStats[fileObj.file].totalQuestions }}题 (已练{{
                                            bankStats[fileObj.file].uniquePracticed || 0 }}题/提交{{
                                            bankStats[fileObj.file].totalSubmissions || 0 }}次)
                                            <span class="accuracy-stat"
                                                v-if="bankStats[fileObj.file].averageAccuracy !== undefined">
                                                - 正确率: {{ bankStats[fileObj.file].averageAccuracy }}%
                                            </span>
                                        </div>
                                    </div>
                                </div>
                            </li>
                        </template>
                    </ul>
                </template>

                <!-- 如果列表为空 -->
                <template v-else>
                    <div class="empty-state" role="status">
                        没有找到可用的题库
                    </div>
                </template>
            </div>

            <!-- 题库详情页面 -->
            <div v-else-if="pageState === 'setDescription'" class="card" @keydown.prevent="handleKeyNavigation"
                tabindex="-1">
                <h1 class="title">
                    {{ chosenSet.name }}
                    <div class="time-info" v-if="chosenSet.createTime || chosenSet.updateTime">
                        <div v-if="chosenSet.updateTime" class="update-time">
                            更新于：{{ formatDate(chosenSet.updateTime) }}
                        </div>
                        <div v-else-if="chosenSet.createTime" class="create-time">
                            创建于：{{ formatDate(chosenSet.createTime) }}
                        </div>
                    </div>
                </h1>
                <p v-if="chosenSet.description" class="pre-wrap" v-html="renderMarkdown(chosenSet.description)"></p>

                <!-- 练习模式选择 -->
                <div class="mode-selection" role="group" aria-label="练习模式选择">
                    <button class="mode-btn" @click="enterQuizMode" @keydown.enter.prevent="enterQuizMode"
                        @keydown.space.prevent="enterQuizMode" @keydown.left.prevent="focusPrevButton($event)"
                        @keydown.right.prevent="focusNextButton($event)" @keydown.up.prevent="focusUpButton($event)"
                        @keydown.down.prevent="focusDownButton($event)" tabindex="0" role="button" data-nav="mode-btn">
                        全部练习
                        <span class="mode-description">按顺序练习所有题目</span>
                    </button>
                    <button class="mode-btn" @click="enterOrderQuizMode" @keydown.enter.prevent="enterOrderQuizMode"
                        @keydown.space.prevent="enterOrderQuizMode" @keydown.left.prevent="focusPrevButton($event)"
                        @keydown.right.prevent="focusNextButton($event)" @keydown.up.prevent="focusUpButton($event)"
                        @keydown.down.prevent="focusDownButton($event)" tabindex="0" role="button" data-nav="mode-btn">
                        错题练习
                        <span class="mode-description">专注于之前答错的题目</span>
                    </button>
                    <button class="mode-btn" @click="enterRandomQuizMode" @keydown.enter.prevent="enterRandomQuizMode"
                        @keydown.space.prevent="enterRandomQuizMode" @keydown.left.prevent="focusPrevButton($event)"
                        @keydown.right.prevent="focusNextButton($event)" @keydown.up.prevent="focusUpButton($event)"
                        @keydown.down.prevent="focusDownButton($event)" tabindex="0" role="button" data-nav="mode-btn">
                        随机练习
                        <span class="mode-description">随机顺序练习题目</span>
                    </button>
                    <button class="mode-btn" @click="enterPreviewMode" @keydown.enter.prevent="enterPreviewMode"
                        @keydown.space.prevent="enterPreviewMode" @keydown.left.prevent="focusPrevButton($event)"
                        @keydown.right.prevent="focusNextButton($event)" @keydown.up.prevent="focusUpButton($event)"
                        @keydown.down.prevent="focusDownButton($event)" tabindex="0" role="button" data-nav="mode-btn">
                        预览模式
                        <span class="mode-description">查看和编辑所有题目和答案</span>
                    </button>
                </div>
            </div>

            <!-- 题目页面 -->
            <div v-else-if="['quiz', 'orderQuiz', 'randomQuiz'].includes(pageState)" class="card">
                <!-- 添加已提交数量显示 -->
                <div class="progress-info">
                    已提交：{{ currentSessionCompleted.size }}/{{ quizList.length }}
                </div>

                <div class="question-header">
                    <div class="header-row">
                        <div class="flex-center">
                            <button class="back-button" @click="backToHome">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path d="M19 12H5M12 19l-7-7 7-7" />
                                </svg>
                                返回
                            </button>
                            <span class="progress-text">
                                {{ practiceManager.currentIndex + 1 }} / {{ practiceManager.questions.length }}
                                <template v-if="chosenSet.isCrossPractice && currentQuestion">
                                    · 来自：{{ currentQuestion.sourceBank }}
                                </template>
                            </span>
                        </div>
                        <div class="action-buttons">
                            <button class="action-button" @click="copyCurrentLink" title="复制当前题目链接">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" />
                                    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" />
                                </svg>
                                复制链接
                            </button>
                            <button class="action-button" @click="saveCurrentEdit"
                                v-if="isEditing && questionManager.checkUnsavedChanges()" title="保存并导出修改">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                                    <polyline points="17 21 17 13 7 13 7 21" />
                                    <polyline points="7 3 7 8 15 8" />
                                </svg>
                                保存并导出
                            </button>
                            <button class="action-button" @click="togglePreviewMode" v-if="isAdmin">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" />
                                    <circle cx="12" cy="12" r="3" />
                                </svg>
                                {{ isPreviewMode ? '退出预览' : '预览模式' }}
                            </button>
                            <button class="action-button" @click="editCurrentQuestion" v-if="isAdmin && !isPreviewMode">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" />
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" />
                                </svg>
                                编辑
                            </button>
                        </div>
                    </div>
                </div>

                <!-- 题目内容 -->
                <div v-if="!isEditing || editingField !== 'content'"
                    @click="isEditing && !isPreviewMode ? enterEditMode('content', currentQuestion.content) : null"
                    class="question-content" :class="{ 'editable': !isPreviewMode && isEditing }">
                    <span v-html="renderedContent"></span>
                    <span v-if="currentQuestion.type === 'multiple-choice'" class="question-type-label">多选题</span>
                </div>
                <textarea v-else-if="editingField === 'content'" v-model="editingContent" @blur="exitEditMode"
                    class="edit-textarea" rows="8"></textarea>

                <!-- 选项 -->
                <div v-if="currentQuestion.type === 'single-choice' || currentQuestion.type === 'multiple-choice'">
                    <label v-for="(opt, idx) in currentQuestion.options" :key="idx" class="option-item" :class="{
                        'green': showAnswer && (currentQuestion.type === 'single-choice' ? isCorrectOptionSingle(opt) : isCorrectOptionMulti(opt)),
                        'red': showAnswer && (currentQuestion.type === 'single-choice' ? 
                            (isChosenOptionSingle(opt) && !isCorrectOptionSingle(opt)) : 
                            (chosenAnswers.includes(opt) && !isCorrectOptionMulti(opt))),
                        'editable': !isPreviewMode
                    }">
                        <input :type="currentQuestion.type === 'single-choice' ? 'radio' : 'checkbox'"
                            :name="currentQuestion.type === 'single-choice' ? 'single-choice-' + currentQuestion.uniqueId : ''"
                            :value="opt"
                            :checked="currentQuestion.type === 'single-choice' ? chosenAnswer === opt : chosenAnswers.includes(opt)"
                            @change="handleOptionChange(opt, currentQuestion.type === 'single-choice')"
                            :disabled="showAnswer || isEditing || isPreviewMode" class="margin-right-6">
                        <div class="option-content" v-if="!isEditing || editingField !== `option-${idx}`">
                            <strong>{{ letterMap[idx] }}. </strong>
                            <span v-html="renderMarkdownWithLatex(opt)"
                                @click="isEditing && !isPreviewMode ? enterEditMode(`option-${idx}`, opt) : null"></span>
                        </div>
                        <div v-else class="option-edit">
                            <strong>{{ letterMap[idx] }}. </strong>
                            <input type="text" v-model="editingContent" @blur="exitEditMode" class="edit-input">
                        </div>
                    </label>
                </div>

                <div v-else-if="currentQuestion.type === 'short-answer'">
                    <!-- 简答题 -->
                    <textarea v-model="shortAnswerText" :disabled="showAnswer" rows="4" class="full-width-input"
                        placeholder="请输入你的答案"></textarea>
                </div>

                <div v-else-if="currentQuestion.type === 'fill-in-blank'">
                    <!-- 填空题 -->
                    <div v-for="(blank, idx) in currentQuestion.blanks" :key="idx" class="fill-blank-item">
                        <label :for="'blank-'+idx">空{{idx + 1}}：</label>
                        <input :id="'blank-'+idx" type="text" v-model="fillInAnswers[idx]" :disabled="showAnswer"
                            class="medium-input" :placeholder="'请填写空'+(idx+1)">
                    </div>
                </div>

                <!-- 提交答案 / 下一题 按钮 -->
                <div class="flex-gap-12">
                    <button type="button" v-if="practiceManager?.currentIndex > 0" class="btn" @click="prevQuestion"
                        title="快捷键：q">
                        <i class="fas fa-chevron-left"></i> 上一题
                    </button>
                    <button type="button" v-if="!showAnswer" class="btn" @click="submitAnswer" title="快捷键：空格">
                        提交答案
                    </button>
                    <button type="button" v-else class="btn" @click="nextQuestion"
                        :disabled="practiceManager?.currentIndex === quizList.length - 1 && isPreviewMode"
                        title="快捷键：空格">
                        下一题 <i class="fas fa-chevron-right"></i>
                    </button>
                    <button type="button" v-if="practiceManager?.currentIndex < quizList.length - 1" class="btn"
                        @click="nextQuestion" title="快捷键：e">
                        跳过 <i class="fas fa-forward"></i>
                    </button>
                </div>

                <!-- 显示正确答案和AI评分 -->
                <div v-if="showAnswer" class="answer-section">
                    <!-- 显示正确答案 -->
                    <div class="correct-answer">
                        <h4>参考答案：</h4>
                        <template v-if="currentQuestion.type === 'short-answer'">
                            <div v-for="(answer, index) in currentQuestion.correct_answer" :key="index"
                                v-html="renderMarkdownWithLatex(answer)" class="short-answer-content">
                            </div>
                        </template>
                        <template v-else-if="currentQuestion.type === 'fill-in-blank'">
                            <div v-for="(answer, idx) in currentQuestion.correct_answer" :key="idx" class="fill-blank-answer">
                                空{{idx + 1}}：{{ answer }}
                            </div>
                        </template>
                    </div>

                    <!-- AI评分区域 -->
                    <div v-if="currentQuestion.type === 'fill-in-blank' || currentQuestion.type === 'short-answer'" class="ai-score-section">
                        <h4>AI评分</h4>
                        <div v-if="currentQuestion.aiScoreExplanation" class="markdown-content" v-html="renderMarkdownWithLatex(currentQuestion.aiScoreExplanation)"></div>
                        <div v-else class="empty-message">
                            <template v-if="!practiceManager.aiManager?.getAutoScoring()">
                                <button @click="triggerAIScoring" class="btn btn-primary">AI评分</button>
                            </template>
                            <template v-else>
                                等待 AI 评分...
                            </template>
                        </div>
                    </div>

                    <!-- 解析 -->
                    <div class="analysis">
                        <!-- 默认解析 -->
                        <div class="default-analysis-section">
                            <div class="analysis-header">
                                <h3>题目解析</h3>
                            </div>
                            
                            <div v-if="(!isEditing || editingField !== 'analysis') && currentQuestion.analysis"
                                @click="isEditing && !isPreviewMode ? enterEditMode('analysis', currentQuestion.analysis) : null"
                                v-html="renderedAnalysis" :class="{ 'editable': isEditing && !isPreviewMode }"></div>
                            <div v-if="(!isEditing || editingField !== 'analysis') && !currentQuestion.analysis"
                                @click="isEditing && !isPreviewMode ? enterEditMode('analysis', '') : null"
                                class="empty-analysis" :class="{ 'editable': isEditing && !isPreviewMode }">
                                暂无解析
                            </div>
                            <textarea v-else-if="editingField === 'analysis'" v-model="editingContent" @blur="exitEditMode"
                                class="edit-textarea" rows="6" placeholder="请输入解析内容..."></textarea>
                        </div>

                        <!-- AI解析区域 -->
                        <div class="ai-analysis-section">
                            <div class="analysis-header">
                                <h3>AI解析</h3>
                                <button class="ai-analysis-btn" @click="generateAIAnalysis" :disabled="isGeneratingAnalysis">
                                    <span v-if="!aiAnalysis">生成解析</span>
                                    <span v-else>重新生成</span>
                                </button>
                            </div>
                            <div v-if="isGeneratingAnalysis" class="generating-message">
                                <div v-if="aiAnalysisExplanation" class="markdown-content" v-html="renderMarkdownWithLatex(aiAnalysisExplanation)"></div>
                                <div v-else>正在生成解析...</div>
                            </div>
                            <div v-else-if="aiAnalysis" class="markdown-content" v-html="renderMarkdownWithLatex(aiAnalysis)"></div>
                            <div v-else class="empty-message">
                                点击按钮生成 AI 解析
                            </div>
                        </div>
                    </div>
                </div>

                <p class="small-text">
                    键盘：1~4 选项，空格提交/下一题，Shift+C切换解析，q/e切换上一题/下一题
                </p>
            </div>

            <!-- 5) result: 最终结果 -->
            <div v-else-if="pageState === 'result'" class="card">
                <h1 class="title">答题完成</h1>
                <p>本轮共 {{ quizList.length }} 题，已完成：{{ completedCount }}。</p>
                <button type="button" class="btn" @click="pageState = 'home'">
                    返回题目选择 
                </button>
            </div>
        </template>

        <!-- Tags Modal -->
        <div v-if="showTagsModal" class="modal-overlay" @click="showTagsModal = false">
            <div class="modal-content" @click.stop>
                <h2>选择标签</h2>
                <div class="tags-grid">
                    <span v-for="tagInfo in allTags" :key="tagInfo.tag"
                        :class="['tag-chip', { active: selectedTags.includes(tagInfo.tag) }]"
                        @click="toggleTag(tagInfo.tag)">
                        {{ tagInfo.tag }} ({{ tagInfo.count }})
                    </span>
                </div>
                <div class="modal-footer">
                    <button @click="clearTags" class="btn btn-clear">清除筛选</button>
                    <button @click="showTagsModal = false" class="btn btn-close">关闭窗口</button>
                </div>
            </div>
        </div>

        <!-- Cross Practice Modal -->
        <div v-if="showCrossPracticeModal" class="modal-overlay" @keydown.stop>
            <div class="modal-content cross-practice-modal" @click.stop @keydown.left.prevent @keydown.right.prevent
                @keydown.up.prevent @keydown.down.prevent>
                <div class="modal-header">
                    <h2>跨卷练习设置</h2>
                    <button class="modal-close" @click="showCrossPracticeModal = false">&times;</button>
                </div>

                <!-- 题型筛选 -->
                <div class="setting-section">
                    <h3>题型筛选</h3>
                    <div class="question-types">
                        <label v-for="type in questionTypes" :key="type.value" class="type-checkbox">
                            <input type="checkbox" v-model="selectedQuestionTypes" :value="type.value">
                            {{ type.label }}
                        </label>
                    </div>
                </div>

                <!-- 练习模式 -->
                <div class="setting-section">
                    <h3>练习模式</h3>
                    <div class="practice-mode">
                        <label class="mode-radio">
                            <input type="radio" v-model="crossPracticeMode" value="random">
                            随机抽题
                        </label>
                        <label class="mode-radio">
                            <input type="radio" v-model="crossPracticeMode" value="error-rate">
                            错误率优先
                        </label>
                    </div>
                </div>

                <!-- 题目数量 -->
                <div class="setting-section">
                    <h3>练习题数</h3>
                    <div class="question-count">
                        <input type="number" :value="crossPracticeCount" min="1" :max="maxQuestionCount"
                            class="count-input" @input="handleQuestionInput" @blur="handleQuestionBlur" @keydown.stop
                            @keydown.left.prevent @keydown.right.prevent @keydown.up.prevent @keydown.down.prevent
                            ref="countInput">
                        <span class="max-count" :class="{ 'error': crossPracticeCount > maxQuestionCount }">
                            当前可选 {{ maxQuestionCount }} 题
                            <template v-if="crossPracticeCount > maxQuestionCount">
                                (超出限制)
                            </template>
                        </span>
                    </div>
                </div>

                <!-- 参与题库及占比 -->
                <div class="setting-section">
                    <h3>参与题库及占比</h3>
                    <div class="bank-distribution">
                        <div v-for="bank in filteredBankDistribution" :key="bank.file" class="bank-item">
                            <div class="bank-name">{{ bank.name }}</div>
                            <div class="bank-count">
                                {{ bank.questionCount }}/{{ bank.availableQuestions }}题
                                ({{ calculateBankPercentage(bank) }}%)
                            </div>
                            <div class="bank-progress">
                                <div class="progress-bar" :style="{ width: calculateBankPercentage(bank) + '%' }"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="modal-footer">
                    <button @click="showCrossPracticeModal = false" class="btn btn-clear">取消</button>
                    <button @click="startCrossPractice" class="btn btn-primary" :disabled="!canStartCrossPractice">
                        开始练习
                    </button>
                </div>
            </div>
        </div>

        <!-- 在 template 中更新 banner 的 HTML 结构 -->
        <div v-if="banner.show" :class="['banner', banner.type]" role="alert">
            <div class="banner-content">{{ banner.content }}</div>
            <button v-if="banner.closeable" 
                    class="banner-close" 
                    @click="closeBanner"
                    aria-label="关闭提示">
                ×
            </button>
        </div>
    </div>

    <script type="module">
        import StorageManager from './js/modules/storage.js';
        import JsonLoader from './js/modules/jsonLoader.js';
        import KeyboardManager from './js/modules/keyboard.js';
        import QuestionManager from './js/modules/QuestionManager.js';
        import PracticeManager from './js/modules/PracticeManager.js';
        // 导入 AI 管理器
        import { aiManager } from './js/modules/AIManager.js';

        // 扩展 Vue 应用配置
        const appConfig = {
            data() {
                return {
                    storageManager: new StorageManager(),
                    jsonLoader: null,
                    keyboardManager: null,
                    questionManager: null,
                    practiceManager: null,
                    pageState: 'home',
                    isLoading: false,
                    loadError: null,
                    fileList: [],
                    groupedFileList: [],
                    chosenSet: null,
                    showAnswer: false,
                    isEditing: false,
                    editingField: null,
                    editingContent: '',
                    showExportButton: false,
                    chosenAnswer: null,
                    chosenAnswers: [],
                    shortAnswerText: '',
                    fillInAnswers: [],
                    currentSessionCompleted: new Set(),
                    modifiedCount: 0,
                    showUnsavedModal: false,
                    dontShowExportReminder: false,
                    groupedModifiedQuestions: {},
                    lastExportTimestamp: null,
                    updateTime: null,
                    showTagsModal: false,
                    selectedTags: [],
                    topTags: [],
                    allTags: [],
                    bankStats: {},
                    _altHPressed: false,
                    hoverTitle: false,  // 添加 hoverTitle 数据属性
                    // 跨卷练习相关
                    _showCrossPracticeModal: false,
                    selectedQuestionTypes: ['single-choice', 'multiple-choice', 'fill-in-blank', 'short-answer'],
                    crossPracticeMode: 'random',
                    crossPracticeCount: 30,
                    questionTypes: [
                        { value: 'single-choice', label: '单选题' },
                        { value: 'multiple-choice', label: '多选题' },
                        { value: 'fill-in-blank', label: '填空题' },
                        { value: 'short-answer', label: '简答题' }
                    ],
                    showAIModal: false, // 默认不显示 AI 配置窗口
                    showSoundModal: false, // 默认不显示音效配置窗口
                    providerApiKeys: {},
                    autoScoring: aiManager.getAutoScoring(), // AI 自动评分设置
                    userMessage: '',
                    aiResponse: '',
                    isProcessing: false,
                    selectedPresetId: aiManager.selectedPresetId,
                    presets: aiManager.getPresets(),
                    activeTab: 'edit',
                    reasoningContent: '',
                    currentResponseType: null,
                    // AI 解析相关
                    aiAnalysis: null,
                    testStreamContent: '',
                    isTestingStream: false,
                    testPrompt: '请解释TCP三次握手的过程。',
                    isGeneratingAnalysis: false,
                    aiAnalysisExplanation: '', // 添加用于流式渲染的状态
                    // 音效配置相关
                    audioEnabled: false,
                    volumeValue: 100,
                    comboWindowMs: 3000,
                    resetTimeoutMs: 5000,
                    audioManager: null,
                    // 计分和计时相关
                    currentScore: 0,
                    timerProgress: 0,
                    timeLeft: 0,
                    timerInterval: null,
                    toasts: [], // Array to store active toasts
                    banner: {
                        show: false,
                        content: '',
                        type: 'info',
                        closeable: true
                    },
                    bannerTimer: null,
                }
            },
            mounted() {
                // 初始化 AI 配置
                this.initAIConfig();

                // 初始化音效配置
                this.initSoundConfig();

                // 每秒更新一次日志显示
                setInterval(() => {
                    this.logs = [...aiManager.getLogs()];
                }, 1000);

                // 初始化键盘事件监听
                this.initKeyboardEvents();
            },
            beforeUnmount() {
                // 清理事件监听器
                window.removeEventListener('popstate', this.handlePopState);
                window.removeEventListener('hashchange', this.handleUrlChange);
                window.removeEventListener('popstate', this.handleUrlChange);
                window.removeEventListener('keydown', this.handleGlobalBackShortcut);
            },
            watch: {
                // 音效配置相关的监听器
                showSoundModal: {
                    handler(newValue) {
                        if (newValue) {
                            // 打开模态时，开始计时器并同步分数
                            if (this.audioManager) {
                                this.currentScore = this.audioManager.getScore();
                                this.startTimer();
                            }
                        } else {
                            // 关闭模态时，停止计时器
                            this.stopTimer();
                        }
                    }
                },
                audioEnabled: {
                    handler(newValue) {
                        if (this.audioManager) {
                            this.audioManager.positiveAudios.forEach(audio => audio.muted = !newValue);
                            this.audioManager.negativeAudios.forEach(audio => audio.muted = !newValue);
                            this.updateAudioConfig();
                        }
                    }
                },
                volumeValue: {
                    handler(newValue) {
                        if (this.audioManager) {
                            const volume = newValue / 100;
                            this.audioManager.positiveAudios.forEach(audio => audio.volume = volume);
                            this.audioManager.negativeAudios.forEach(audio => audio.volume = volume);
                            this.updateAudioConfig();
                        }
                    }
                },
                comboWindowMs: {
                    handler() {
                        this.updateAudioConfig();
                    }
                },
                resetTimeoutMs: {
                    handler() {
                        this.updateAudioConfig();
                    }
                },
                selectedQuestionTypes: {
                    handler() {
                        console.log('[selectedQuestionTypes] Question types changed, updating distribution');
                        this.updateBankDistribution();
                    },
                    deep: true
                },
                pageState: {
                    handler(newState, oldState) {
                        console.log('Page state changed:', {
                            from: oldState,
                            to: newState
                        });
                        if (newState === 'setDescription') {
                            this.$nextTick(() => {
                                const buttons = document.querySelectorAll('.mode-btn');
                                console.log('Mode buttons after state change:', {
                                    totalButtons: buttons.length,
                                    buttonElements: Array.from(buttons).map(btn => ({
                                        text: btn.textContent.trim(),
                                        tabIndex: btn.tabIndex,
                                        hasClickHandler: btn.onclick !== null,
                                        hasKeydownHandler: btn.onkeydown !== null
                                    }))
                                });
                            });
                        }
                    },
                    immediate: true
                },
                'practiceManager.currentIndex': {
                    handler(newIndex) {
                        console.log('[watch] currentIndex changed:', newIndex);
                        if (this.practiceManager && this.practiceManager.questions) {
                            const currentQuestion = this.practiceManager.questions[newIndex];
                            console.log('[watch] Current question:', currentQuestion);
                            if (currentQuestion) {
                                // 确保保持 bank 参数
                                const currentFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                                this.updateUrlParams('quiz', {
                                    mode: this.getCurrentMode(),
                                    qid: newIndex + 1, // 使用题目序号（从1开始）
                                    bank: currentFile
                                });
                            }
                        }
                    },
                    immediate: true
                },
                // 监听 AI 响应变化，自动渲染数学公式
                renderedResponse() {
                    this.$nextTick(() => {
                        if (window.renderMathInElement) {
                            window.renderMathInElement(this.$refs.chatArea, {
                                delimiters: [
                                    { left: '$$', right: '$$', display: true },
                                    { left: '$', right: '$', display: false }
                                ]
                            });
                        }
                    });
                },
                // 监听思维链内容变化，实时渲染数学公式
                reasoningContent() {
                    this.$nextTick(() => {
                        if (window.renderMathInElement && this.$refs.chatArea) {
                            window.renderMathInElement(this.$refs.chatArea, {
                                delimiters: [
                                    { left: '$$', right: '$$', display: true },
                                    { left: '$', right: '$', display: false }
                                ]
                            });
                        }
                    });
                },
                // 监听显示答案状态
                showAnswer(newVal) {
                    // 不再在这里触发 AI 评分，因为已经在 submitAnswer 中处理了
                }
            },
            async created() {
                // 初始化各个管理器
                this.jsonLoader = new JsonLoader();
                this.keyboardManager = new KeyboardManager(this);
                this.questionManager = new QuestionManager(this.storageManager);
                this.practiceManager = new PracticeManager(this.storageManager);
                this.practiceManager.setAIManager(aiManager);

                // 先加载题库列表
                await this.loadBankList();

                // 然后处理URL参数
                await this.handleUrlParams();

                // 设置初始日志级别为 debug，以便查看详细信息
                aiManager.setLogLevel('debug');

                // 配置 marked 选项
                marked.setOptions({
                    breaks: true, // 支持 GitHub 风格的换行
                    gfm: true,    // 启用 GitHub 风格的 Markdown
                    highlight: function (code, lang) {
                        if (window.hljs && lang) {
                            try {
                                return hljs.highlight(code, {
                                    language: lang,
                                    ignoreIllegals: true
                                }).value;
                            } catch (e) {
                                return hljs.highlightAuto(code).value;
                            }
                        }
                        return code;
                    }
                });

                // 初始化选中的预设
                this.selectedPresetId = aiManager.selectedPresetId;

                // 初始化各个 provider 的 API Key
                Object.values(this.presets).forEach(preset => {
                    if (preset.provider) {
                        this.providerApiKeys[preset.provider] = aiManager.getApiKey(preset.provider);
                    }
                });
            },
            computed: {
                currentQuestion() {
                    return this.practiceManager?.getCurrentQuestion() || null;
                },
                currentIndex() {
                    return this.practiceManager?.currentIndex || 0;
                },
                quizList() {
                    return this.practiceManager?.questions || [];
                },
                isPreviewMode() {
                    return this.practiceManager?.isPreviewMode || false;
                },
                totalStats() {
                    const stats = this.storageManager.getAllBanksStats();
                    console.log('[totalStats computed] Raw stats from storage:', stats);
                    return {
                        completedQuestions: stats.completedQuestions || 0,
                        totalAttempts: stats.totalAttempts || 0,
                        averageAccuracy: stats.averageAccuracy || 0,
                        todayPracticed: stats.todayPracticed || 0,
                    };
                },
                setStats() {
                    if (!this.chosenSet) return null;
                    const stats = this.storageManager.getSetStats(this.chosenSet.id, this.jsonLoader.questions);
                    const today = new Date().toISOString().split('T')[0];

                    // 获取今日练习题数
                    const todayCount = this.jsonLoader.questions.reduce((count, q) => {
                        const completion = this.storageManager.getQuestionCompletion(this.chosenSet.id, q.uniqueId);
                        if (completion && completion.lastAttemptDate === today) {
                            return count + 1;
                        }
                        return count;
                    }, 0);

                    return {
                        ...stats,
                        todayCount,
                        averageAccuracy: stats.totalAttempts > 0
                            ? Math.round((stats.totalCorrect / stats.totalAttempts) * 100)
                            : 0
                    };
                },
                renderedContent() {
                    if (!this.currentQuestion.content) return '';
                    return this.renderMarkdownWithLatex(this.currentQuestion.content);
                },
                renderedAnalysis() {
                    if (!this.currentQuestion.analysis) return '';
                    return this.renderMarkdownWithLatex(this.currentQuestion.analysis);
                },
                progressText() {
                    return `本次练习完成度：${this.currentSessionCompleted.size}/${this.quizList.length}`;
                },
                completedCount() {
                    return this.currentSessionCompleted.size;
                },
                letterMap() {
                    return ['A', 'B', 'C', 'D', 'E', 'F'];
                },
                hoverTitle() {
                    return false;
                },
                hasChanges() {
                    return false;
                },
                changesExported() {
                    return false;
                },
                questionStats() {
                    if (!this.chosenSet || !this.currentQuestion) return null;
                    return this.storageManager.getQuestionStats(
                        this.chosenSet.id,
                        this.currentQuestion.uniqueId
                    );
                },
                filteredGroupedFileList() {
                    if (this.selectedTags.length === 0) return this.groupedFileList;

                    return this.groupedFileList.map(([category, items]) => {
                        const filteredItems = items.filter(item =>
                            this.selectedTags.every(tag => item.tags && item.tags.includes(tag))
                        );
                        return [category, filteredItems];
                    }).filter(([_, items]) => items.length > 0);
                },
                // 跨卷练习相关的计算属性
                filteredBankDistribution() {
                    // 获取符合当前标签和题型筛选的题库及题目数
                    const distribution = [];

                    // 遍历所有题库
                    this.fileList.forEach(bank => {
                        // 检查标签筛选
                        if (this.selectedTags.length > 0 &&
                            !this.selectedTags.every(tag => bank.tags && bank.tags.includes(tag))) {
                            return;
                        }

                        // 获取题库中符合题型的题目数量
                        const questions = this.jsonLoader.getQuestionsFromBank(bank.file);
                        const filteredQuestions = questions.filter(q =>
                            this.selectedQuestionTypes.includes(q.type)
                        );

                        if (filteredQuestions.length > 0) {
                            distribution.push({
                                file: bank.file,
                                name: bank.name,
                                questionCount: 0, // 初始化为0，实际分配由updateBankDistribution处理
                                availableQuestions: filteredQuestions.length,
                                questions: filteredQuestions
                            });
                        }
                    });

                    return distribution;
                },

                maxQuestionCount() {
                    // 计算所有可用题目的总数
                    return this.filteredBankDistribution.reduce(
                        (sum, bank) => sum + bank.availableQuestions,
                        0
                    );
                },

                canStartCrossPractice() {
                    return this.selectedQuestionTypes.length > 0 &&
                        this.crossPracticeCount > 0 &&
                        this.crossPracticeCount <= this.maxQuestionCount &&
                        this.filteredBankDistribution.length > 0;
                },
                showCrossPracticeModal: {
                    get() {
                        return this._showCrossPracticeModal;
                    },
                    set(value) {
                        this._showCrossPracticeModal = value;
                        if (value) {
                            // 打开模态框时初始化
                            this.$nextTick(() => {
                                // 先更新题库分布
                                this.updateBankDistribution();
                                // 如果当前选择的题目数大于最大可选数，自动调整
                                if (this.crossPracticeCount > this.maxQuestionCount) {
                                    console.log(`[showCrossPracticeModal] Adjusting initial count from ${this.crossPracticeCount} to ${this.maxQuestionCount}`);
                                    this.crossPracticeCount = this.maxQuestionCount;
                                }
                                // 再次更新分布以确保百分比正确
                                this.updateBankDistribution();
                            });
                        }
                    }
                },
                currentPreset() {
                    return this.presets[this.selectedPresetId];
                },
                currentProvider() {
                    return this.currentPreset?.provider;
                },
                hasValidApiKey() {
                    return this.currentProvider && this.providerApiKeys[this.currentProvider];
                },
                filteredLogs() {
                    return aiManager.getLogs(this.logLevel);
                },
                // 渲染 Markdown 预览
                renderedPreview() {
                    return this.userMessage ? marked.parse(this.userMessage) : '';
                },
                // 渲染 AI 响应
                renderedResponse() {
                    return this.aiResponse ? marked.parse(this.aiResponse) : '';
                },
                // 渲染思维链内容
                renderedReasoningContent() {
                    return this.reasoningContent ? marked.parse(this.reasoningContent) : '';
                }
            },
            methods: {
                // 加载题库列表
                async loadBankList() {
                    this.isLoading = true;
                    this.loadError = null;
                    try {
                        const response = await fetch('assets/list.json');
                        const data = await response.json();
                        this.fileList = data.banks || [];
                        this.updateTime = data.updateTime;

                        // 初始化 jsonLoader
                        if (!this.jsonLoader) {
                            this.jsonLoader = new JsonLoader();
                        }

                        // 加载每个题库的统计信息
                        for (const bank of this.fileList) {
                            try {
                                // 先加载题库数据
                                await this.jsonLoader.loadFile(bank.file);
                                // 然后获取统计信息
                                const stats = await this.storageManager.getBankStats(bank.file, this.jsonLoader);
                                this.bankStats[bank.file] = stats;
                            } catch (error) {
                                console.error(`Error loading bank ${bank.file}:`, error);
                                this.bankStats[bank.file] = {
                                    totalQuestions: 0,
                                    uniquePracticed: 0,
                                    totalSubmissions: 0
                                };
                            }
                        }

                        // 加载每个题库的sets信息以获取category和tags
                        const fileCategories = {};
                        const fileTags = {};
                        const tagsCount = new Map();

                        for (const bank of this.fileList) {
                            try {
                                const bankData = await this.jsonLoader.loadFile(bank.file);
                                const category = bankData.sets[0]?.category || '未分类';
                                const tags = bankData.sets[0]?.tags || [];

                                fileCategories[bank.file] = category;
                                fileTags[bank.file] = tags;

                                // 统计tags
                                tags.forEach(tag => {
                                    tagsCount.set(tag, (tagsCount.get(tag) || 0) + 1);
                                });
                            } catch (error) {
                                console.error(`Error loading bank ${bank.file}:`, error);
                                fileCategories[bank.file] = '未分类';
                                fileTags[bank.file] = [];
                            }
                        }

                        // 更新fileList添加tags信息
                        this.fileList = this.fileList.map(bank => ({
                            ...bank,
                            tags: fileTags[bank.file] || []
                        }));

                        // 获取前三个最常用的tags
                        this.topTags = Array.from(tagsCount.entries())
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 3)
                            .map(([tag, count]) => ({ tag, count }));

                        // 获取所有tags
                        this.allTags = Array.from(tagsCount.entries())
                            .sort((a, b) => b[1] - a[1])
                            .map(([tag, count]) => ({ tag, count }));

                        // 按category对题库进行分组
                        const groups = {};
                        this.fileList.forEach(bank => {
                            const category = fileCategories[bank.file] || '未分类';
                            if (!groups[category]) {
                                groups[category] = [];
                            }
                            groups[category].push(bank);
                        });

                        // 对每个分类内的题库按名称排序
                        for (const category in groups) {
                            groups[category].sort((a, b) => a.name.localeCompare(b.name));
                        }

                        // 转换为数组并按分类名排序，确保"未分类"永远在最后
                        this.groupedFileList = Object.entries(groups)
                            .sort((a, b) => {
                                if (a[0] === '未分类') return 1;
                                if (b[0] === '未分类') return -1;
                                return a[0].localeCompare(b[0]);
                            });
                    } catch (error) {
                        console.error('Error loading file list:', error);
                        this.loadError = error.message;
                    }
                    this.isLoading = false;
                },

                // 加载题库文件
                async loadJsonFile(fileName) {
                    console.log('[loadJsonFile] Starting to load file:', fileName);
                    if (this.isLoading) {
                        console.log('[loadJsonFile] Already loading, skipping');
                        return;
                    }
                    this.isLoading = true;
                    try {
                        console.log('[loadJsonFile] Loading data from file');
                        const data = await this.jsonLoader.loadFile(fileName);
                        console.log('[loadJsonFile] Data loaded:', {
                            setName: data.sets[0]?.name,
                            questionCount: data.questions?.length
                        });

                        // Set chosenSet with proper id
                        this.chosenSet = {
                            ...data.sets[0],
                            id: fileName.replace('.json', '') // Ensure id matches the file name without extension
                        };

                        // 更新统计数据
                        console.log('[loadJsonFile] Updating bank stats');
                        const stats = await this.storageManager.getBankStats(fileName, this.jsonLoader);
                        this.bankStats[fileName] = stats;

                        // 更新URL并切换到题库详情页
                        console.log('[loadJsonFile] Updating page state to setDescription');
                        this.updatePageState('setDescription');
                    } catch (error) {
                        console.error('[loadJsonFile] Failed to load bank:', error);
                        alert('加载题库失败: ' + error.message);
                    } finally {
                        this.isLoading = false;
                        console.log('[loadJsonFile] Loading completed');
                    }
                },

                // 开始练习
                startQuiz(mode) {
                    switch (mode) {
                        case 'all':
                            this.enterQuizMode();
                            break;
                        case 'wrong':
                            this.enterOrderQuizMode();
                            break;
                        case 'random':
                            this.enterRandomQuizMode();
                            break;
                        case 'preview':
                            this.enterPreviewMode();
                            break;
                    }
                },

                // 进入练习模式
                enterQuizMode() {
                    this.practiceManager.initPractice(this.jsonLoader.questions, 'sequence');
                    this.practiceManager.togglePreviewMode(false);
                    this.showAnswer = false;
                    this.currentSessionCompleted.clear();
                    this.updatePageState('quiz', {
                        mode: 'all',
                        qid: 1 // 从第一题开始
                    });
                },

                enterOrderQuizMode() {
                    this.practiceManager.initPractice(this.jsonLoader.questions, 'error-rate');
                    this.practiceManager.togglePreviewMode(false);
                    this.showAnswer = false;
                    this.currentSessionCompleted.clear();
                    this.updatePageState('quiz', {
                        mode: 'wrong',
                        qid: 1 // 从第一题开始
                    });
                },

                enterRandomQuizMode() {
                    this.practiceManager.initPractice(this.jsonLoader.questions, 'random');
                    this.practiceManager.togglePreviewMode(false);
                    this.showAnswer = false;
                    this.currentSessionCompleted.clear();
                    this.updatePageState('quiz', {
                        mode: 'random',
                        qid: 1 // 从第一题开始
                    });
                },

                enterPreviewMode() {
                    this.practiceManager.initPractice(this.jsonLoader.questions, 'sequence');
                    this.practiceManager.togglePreviewMode(false); // 关闭预览模式
                    this.showAnswer = true; // 显示解析
                    this.isEditing = true; // 启用编辑模式
                    this.questionManager.startEditing(this.jsonLoader.questions[0]); // 开始编辑第一题
                    this.showExportButton = true; // 显示导出按钮
                    this.updatePageState('quiz', {
                        mode: 'preview',
                        qid: 1 // 从第一题开始
                    });
                },

                // 编辑相关方法
                editQuestion() {
                    if (this.isPreviewMode) return;
                    console.log('Starting edit mode for question:', this.currentQuestion);
                    this.questionManager.startEditing(this.currentQuestion);
                    this.isEditing = true;
                    this.showExportButton = true;
                    // 自动切换到解析模式
                    this.showAnswer = true;
                },

                enterEditMode(field, content) {
                    if (this.isPreviewMode) return;
                    console.log('Entering edit mode:', {
                        field,
                        content,
                        currentContent: content || '点击编辑'
                    });
                    this.editingField = field;
                    this.editingContent = content || '';
                },

                exitEditMode() {
                    console.log('Exiting edit mode:', {
                        field: this.editingField,
                        content: this.editingContent,
                        question: this.currentQuestion
                    });

                    if (this.editingField && this.editingContent !== undefined) {
                        const question = this.currentQuestion;
                        if (this.editingField === 'content') {
                            question.content = this.editingContent;
                        } else if (this.editingField === 'analysis') {
                            question.analysis = this.editingContent;
                        } else if (this.editingField.startsWith('option-')) {
                            const idx = parseInt(this.editingField.split('-')[1]);
                            question.options[idx] = this.editingContent;
                        }
                        this.questionManager.saveCurrentEdit();
                        // 更新修改计数
                        this.modifiedCount = this.questionManager.getModifiedQuestions().length;
                    }
                    this.editingField = null;
                    this.editingContent = '';
                },

                // 退出整个编辑模式
                exitEntireEditMode() {
                    if (this.editingField) {
                        this.exitEditMode();
                    }
                    this.isEditing = false;
                    this.showAnswer = false;
                    this.showExportButton = false;
                    this.questionManager.cancelEditing();
                },

                // 导出相关方法
                handleExport(questions) {
                    const exportData = {
                        questions: questions,
                        sets: [this.chosenSet]
                    };

                    const blob = new Blob([JSON.stringify(exportData, null, 4)],
                        { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    // 从fileList中获取当前题库的文件名
                    const currentFile = this.fileList.find(f => f.name === this.chosenSet.name)?.file;
                    a.download = this.questionManager.generateExportFileName(currentFile || 'export');
                    a.click();
                    URL.revokeObjectURL(url);

                    // 更新导出状态
                    this.lastExportTimestamp = Date.now();
                    this.modifiedCount = 0;
                    this.questionManager.clearModifiedQuestions();
                    this.showExportButton = false;
                    this.isEditing = false;
                    this.showUnsavedModal = false;
                },

                // 导出修改
                exportModifiedData() {
                    const modifiedQuestions = this.questionManager.getModifiedQuestions();
                    const questions = this.jsonLoader.questions.map(q => {
                        if (modifiedQuestions.includes(q.uniqueId)) {
                            return { ...q };
                        }
                        return q;
                    });
                    this.handleExport(questions);
                },

                // 状态更新
                updatePageState(newState, params = {}) {
                    console.log('[updatePageState] from:', this.pageState, 'to:', newState, 'params:', params);
                    // 如果有未导出的修改，且不是刚刚导出的，且不是在编辑模式中
                    if (this.modifiedCount > 0 && !this.dontShowExportReminder &&
                        (!this.lastExportTimestamp || Date.now() - this.lastExportTimestamp > 1000) &&
                        !this.isEditing) {
                        const hasUnsaved = this.checkModifiedQuestions();
                        if (hasUnsaved) {
                            return;
                        }
                    }

                    if (this.isEditing && this.questionManager.checkUnsavedChanges()) {
                        this.showUnsavedDialog(newState);
                        return;
                    }

                    this.pageState = newState;

                    // 如果是返回题库详情页，确保传递当前题库参数
                    if (newState === 'setDescription' && this.chosenSet) {
                        const currentFile = this.fileList.find(f => f.name === this.chosenSet.name)?.file;
                        if (currentFile) {
                            params.bank = currentFile;
                        }
                    }

                    // 如果是进入答题页面，确保传递当前题目序号
                    if (newState === 'quiz' && this.practiceManager) {
                        params.qid = params.qid || (this.practiceManager.currentIndex + 1);
                    }

                    // 更新URL参数
                    this.updateUrlParams(newState, params);

                    if (newState === 'home') {
                        this.questionManager.clearEditHistory();
                        this.showExportButton = false;
                    }
                },

                showUnsavedDialog(action) {
                    const dialog = document.createElement('div');
                    dialog.className = 'modal-overlay';
                    dialog.innerHTML = `
                    <div class="modal-content modal-btn">
                        <h3>未保存的修改</h3>
                        <p>当前题目有未保存的修改，请选择操作：</p>
                        <div class="modal-btn-group">
                            <button class="btn btn-continue-edit" id="continueEdit">继续编辑</button>
                            <button class="btn btn-save-export" id="saveAndExport">保存导出</button>
                            <button class="btn btn-discard" id="discardAndContinue">放弃修改</button>
                        </div>
                    </div>
                `;

                    document.body.appendChild(dialog);

                    // 确保元素已经添加到DOM后再添加事件监听器
                    const continueEditBtn = dialog.querySelector('#continueEdit');
                    const saveAndExportBtn = dialog.querySelector('#saveAndExport');
                    const discardBtn = dialog.querySelector('#discardAndContinue');

                    if (continueEditBtn && saveAndExportBtn && discardBtn) {
                        // 点击遮罩层关闭对话框（继续编辑）
                        dialog.addEventListener('click', (e) => {
                            if (e.target === dialog) {
                                document.body.removeChild(dialog);
                            }
                        });

                        // 继续编辑
                        continueEditBtn.addEventListener('click', () => {
                            document.body.removeChild(dialog);
                        });

                        // 保存并导出
                        saveAndExportBtn.addEventListener('click', () => {
                            this.questionManager.saveCurrentEdit();
                            this.exportModifiedData();
                            document.body.removeChild(dialog);

                            // 根据action执行相应操作
                            this.handleActionAfterSave(action);
                        });

                        // 放弃修改并继续
                        discardBtn.addEventListener('click', () => {
                            this.questionManager.cancelEditing();
                            document.body.removeChild(dialog);

                            // 根据action执行相应操作
                            this.handleActionAfterSave(action);
                        });
                    } else {
                        console.error('Failed to find dialog buttons');
                        document.body.removeChild(dialog);
                    }
                },

                // 处理保存后的操作
                handleActionAfterSave(action) {
                    if (action === 'next') {
                        this.practiceManager.currentIndex++;
                        this.questionManager.startEditing(this.practiceManager.questions[this.practiceManager.currentIndex]);
                    } else if (action === 'prev') {
                        this.practiceManager.currentIndex--;
                        this.questionManager.startEditing(this.practiceManager.questions[this.practiceManager.currentIndex]);
                    } else if (action === 'setDescription') {
                        this.exitEntireEditMode();
                        this.pageState = action;
                    } else if (action === 'home') {
                        this.exitEntireEditMode();
                        this.pageState = action;
                    }

                    // 更新URL参数
                    if (action === 'next' || action === 'prev') {
                        this.$nextTick(() => {
                            this.updateUrlParams('quiz', {
                                mode: this.getCurrentMode(),
                                qid: this.practiceManager.questions[this.practiceManager.currentIndex].uniqueId
                            });
                        });
                    }
                },

                goBack() {
                    if (this.pageState === 'quiz') {
                        // 如果有完成的题目，显示确认对话框
                        if (this.currentSessionCompleted.size > 0) {
                            if (!confirm('确定要退出练习吗？当前进度将不会保存。')) {
                                return;
                            }
                        }
                    }

                    // 重置状态
                    this.resetAllState();
                    this.updatePageState('home');
                },

                async getBankStats(fileName) {
                    try {
                        // 确保题库已加载
                        if (!this.jsonLoader.loadedBanks.has(fileName)) {
                            console.log(`[getBankStats] Loading bank first: ${fileName}`);
                            await this.jsonLoader.loadFile(fileName);
                        }

                        const bankData = await this.storageManager.getBankStats(fileName, this.jsonLoader);
                        console.log(`[getBankStats] Stats for ${fileName}:`, bankData);
                        if (!bankData) return null;

                        const stats = {
                            completed: bankData.completed || 0,
                            total: bankData.total || 0,
                            accuracy: bankData.attempts > 0
                                ? Math.round((bankData.correct / bankData.attempts) * 100)
                                : 0
                        };
                        console.log(`[getBankStats] Processed stats for ${fileName}:`, stats);
                        return stats;
                    } catch (e) {
                        console.error('获取题库统计失败:', e);
                        return {
                            completed: 0,
                            total: 0,
                            accuracy: 0
                        };
                    }
                },

                renderMarkdown(text) {
                    if (!text) return '';
                    return marked.parse(text);
                },

                renderMarkdownWithLatex(text) {
                    if (!text) return '';

                    // 先处理多行公式，避免被markdown解析器破坏格式
                    let content = text;

                    // 保存多行公式
                    const formulas = [];
                    content = content.replace(/\$\$([\s\S]+?)\$\$/g, (match, formula) => {
                        // 保持原始换行，不进行任何替换
                        formulas.push(formula.trim());
                        return `<div class="katex-display">${katex.renderToString(formula.trim(), {
                            displayMode: true,
                            throwOnError: false,
                            strict: false,
                            trust: true,
                            output: 'html'
                        })}</div>`;
                    });

                    // 处理Markdown
                    content = marked.parse(content);

                    // 处理行内公式
                    content = content.replace(/\$([^$]+?)\$/g, (match, formula) => {
                        try {
                            return katex.renderToString(formula.trim(), {
                                displayMode: false,
                                throwOnError: false,
                                strict: false
                            });
                        } catch (e) {
                            console.error('LaTeX rendering error:', e);
                            console.error('Formula:', formula);
                            return match;
                        }
                    });

                    return content;
                },

                handleOptionChange(option, isSingleChoice) {
                    console.log('Option change handler:', {
                        option,
                        isSingleChoice,
                        currentValue: isSingleChoice ? this.chosenAnswer : this.chosenAnswers
                    });

                    if (isSingleChoice) {
                        this.chosenAnswer = option;
                    } else {
                        const index = this.chosenAnswers.indexOf(option);
                        if (index === -1) {
                            this.chosenAnswers.push(option);
                        } else {
                            this.chosenAnswers.splice(index, 1);
                        }
                    }

                    console.log('After option change:', {
                        chosenAnswer: this.chosenAnswer,
                        chosenAnswers: this.chosenAnswers
                    });
                },

                isChosenOptionSingle(opt) {
                    console.log('Checking single option selection:', {
                        option: opt,
                        optionType: typeof opt,
                        chosenAnswer: this.chosenAnswer,
                        chosenAnswerType: typeof this.chosenAnswer,
                        isChosen: String(this.chosenAnswer) === String(opt)
                    });
                    return this.chosenAnswer !== null &&
                        this.chosenAnswer !== undefined &&
                        this.chosenAnswer !== '' &&
                        String(this.chosenAnswer) === String(opt);
                },

                isCorrectOptionMulti(opt) {
                    const ans = this.currentQuestion?.correct_answer || [];
                    // 使用选项的索引来判断是否正确
                    const optIndex = this.currentQuestion?.options.indexOf(opt);
                    const isCorrect = optIndex !== -1 && ans.includes(this.currentQuestion.options[optIndex]);
                    console.log('Checking multi option correctness:', {
                        option: opt,
                        correctAnswers: ans,
                        isCorrect: isCorrect
                    });
                    return isCorrect;
                },

                isCorrectOptionSingle(opt) {
                    const ans = this.currentQuestion?.correct_answer || [];
                    const isCorrect = ans.length > 0 && String(ans[0]) === String(opt);
                    console.log('Checking single option correctness:', {
                        option: opt,
                        optionType: typeof opt,
                        correctAnswer: ans[0],
                        correctAnswerType: ans.length > 0 ? typeof ans[0] : 'undefined',
                        isCorrect: isCorrect
                    });
                    return isCorrect;
                },

                // 检查是否已选择或输入答案
                hasAnswer() {
                    const q = this.currentQuestion;
                    if (!q) return false;

                    switch (q.type) {
                        case 'single-choice':
                            return this.chosenAnswer !== null &&
                                this.chosenAnswer !== undefined &&
                                this.chosenAnswer !== '';
                        case 'multiple-choice':
                            return Array.isArray(this.chosenAnswers) &&
                                this.chosenAnswers.length > 0;
                        case 'fill-in-blank':
                            return Array.isArray(this.fillInAnswers) &&
                                this.fillInAnswers.some(ans => ans && ans.trim() !== '');
                        case 'short-answer':
                            return this.shortAnswerText && this.shortAnswerText.trim() !== '';
                        default:
                            return false;
                    }
                },

                async submitAnswer() {
                    const q = this.currentQuestion;
                    if (!q) return;

                    // 检查是否已选择或输入答案
                    if (!this.hasAnswer()) {
                        // 根据题目类型显示不同的提示
                        let message;
                        switch (q.type) {
                            case 'single-choice':
                                message = '请选择一个选项';
                                break;
                            case 'multiple-choice':
                                message = '请至少选择一个选项';
                                break;
                            case 'fill-in-blank':
                                message = '请填写答案';
                                break;
                            case 'short-answer':
                                message = '请输入答案';
                                break;
                            default:
                                message = '请输入答案';
                        }
                        // 显示提示信息
                        this.showBanner(message, 'warning');
                        return;
                    }

                    let answer;
                    let isCorrect = false;

                    switch (q.type) {
                        case 'single-choice':
                            answer = this.chosenAnswer;
                            isCorrect = q.correct_answer.includes(answer);
                            break;
                        case 'multiple-choice':
                            answer = [...this.chosenAnswers].sort();
                            // For multiple choice, we need to compare the actual option texts
                            const sortedCorrectAnswer = [...q.correct_answer].sort();
                            isCorrect = answer.length === sortedCorrectAnswer.length && 
                                answer.every((ans, idx) => ans === sortedCorrectAnswer[idx]);
                            break;
                        case 'fill-in-blank':
                            answer = this.fillInAnswers;
                            // 对填空题使用 AI 评分
                            if (this.practiceManager.aiManager) {
                                console.log('[submitAnswer] Using AI scoring for fill-in-blank question');
                                // 先显示答案
                                this.showAnswer = true;
                                // 检查是否启用自动评分
                                if (this.practiceManager.aiManager.getAutoScoring()) {
                                    // 自动进行 AI 评分
                                    isCorrect = await this.practiceManager.checkAnswerWithAI(answer.join('\n'), q);
                                } else {
                                    // 等待手动触发评分
                                    isCorrect = false;
                                }
                            } else {
                                console.log('[submitAnswer] AI not available, using basic comparison');
                                isCorrect = this.compareArrays(answer, q.correct_answer);
                            }
                            break;
                        case 'short-answer':
                            answer = this.shortAnswerText;
                            // 对简答题使用 AI 评分
                            if (this.practiceManager.aiManager) {
                                console.log('[submitAnswer] Using AI scoring for short-answer question');
                                // 先显示答案
                                this.showAnswer = true;
                                // 检查是否启用自动评分
                                if (this.practiceManager.aiManager.getAutoScoring()) {
                                    // 自动进行 AI 评分
                                    isCorrect = await this.practiceManager.checkAnswerWithAI(answer, q);
                                } else {
                                    // 等待手动触发评分
                                    isCorrect = false;
                                }
                            } else {
                                console.log('[submitAnswer] AI not available, using basic comparison');
                                isCorrect = q.correct_answer.some(ans =>
                                    answer.toLowerCase().includes(ans.toLowerCase())
                                );
                            }
                            break;
                    }

                    // 更新连杀状态
                    if (this.audioManager) {
                        if (q.type === 'fill-in-blank' || q.type === 'short-answer') {
                            return;
                        }
                        if (isCorrect) {
                            this.audioManager.addPoints(1);
                        } else {
                            this.audioManager.subtractPoints(1);
                        }
                    }

                    // 记录完成状态
                    const questionIndex = this.practiceManager.currentIndex + 1;
                    this.currentSessionCompleted.add(questionIndex);

                    // 如果不是 AI 评分的题目，显示答案
                    if (!(this.practiceManager.aiManager && (q.type === 'fill-in-blank' || q.type === 'short-answer'))) {
                        this.showAnswer = true;
                    }

                    // 更新题目完成状态
                    if (this.chosenSet.isCrossPractice) {
                        // 对于跨题练习，找到原题库并更新记录
                        const originalBank = this.findOriginalBank(q);
                        if (originalBank) {
                            console.log('[submitAnswer] Updating cross practice record:', {
                                bank: originalBank.file,
                                questionIndex,
                                isCorrect
                            });
                            this.storageManager.updateQuestionCompletion(originalBank.file, questionIndex, isCorrect);
                        }
                    } else {
                        // 确保有题库ID和题目序号
                        const currentQuestion = this.practiceManager.getCurrentQuestion();
                        if (this.chosenSet?.id && currentQuestion) {
                            console.log('[submitAnswer] Updating completion:', {
                                setId: this.chosenSet.id,
                                questionIndex,
                                isCorrect
                            });
                            this.storageManager.updateQuestionCompletion(
                                this.chosenSet.id,
                                questionIndex,
                                isCorrect
                            );
                        } else {
                            console.error('[submitAnswer] Missing setId or currentQuestion:', {
                                setId: this.chosenSet?.id,
                                currentQuestion
                            });
                        }
                    }

                    // 更新URL以反映答案已提交
                    this.updateUrlParams('quiz', {
                        mode: this.getCurrentMode(),
                        qid: this.getCurrentQuestionId()
                    });
                },

                // 查找题目所属的原始题库
                findOriginalBank(question) {
                    for (const bank of this.fileList) {
                        try {
                            const questions = this.jsonLoader.getQuestionsFromBank(bank.file);
                            if (questions.some(q =>
                                q.content === question.content &&
                                q.type === question.type &&
                                this.compareArrays(q.correct_answer, question.correct_answer)
                            )) {
                                return bank;
                            }
                        } catch (error) {
                            console.error(`Error checking bank ${bank.file}:`, error);
                        }
                    }
                    return null;
                },

                // 比较两个数组是否相等
                compareArrays(arr1, arr2) {
                    if (!Array.isArray(arr1) || !Array.isArray(arr2)) return false;
                    if (arr1.length !== arr2.length) return false;
                    return arr1.every((item, index) => item === arr2[index]);
                },

                nextQuestion() {
                    if (this.practiceManager && this.practiceManager.currentIndex < this.practiceManager.questions.length - 1) {
                        // 如果在编辑模式，自动保存当前编辑并开始编辑下一题
                        if (this.isEditing) {
                            // 如果当前有未保存的字段编辑，先保存
                            if (this.editingField) {
                                this.exitEditMode();
                            }
                            // 如果有未保存的修改，自动保存
                            if (this.questionManager.checkUnsavedChanges()) {
                                this.questionManager.saveCurrentEdit();
                            }
                            this.practiceManager.currentIndex++;
                            this.questionManager.startEditing(this.practiceManager.questions[this.practiceManager.currentIndex]);
                            this.showAnswer = true;
                        } else {
                            this.practiceManager.currentIndex++;
                            this.showAnswer = false;
                            // 重置答案状态
                            this.chosenAnswer = null;
                            this.chosenAnswers = [];
                            this.fillInAnswers = [];
                            this.shortAnswerText = '';
                        }

                        // 立即更新URL参数
                        this.$nextTick(() => {
                            const currentFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                            this.updateUrlParams('quiz', {
                                mode: this.getCurrentMode(),
                                qid: this.practiceManager.currentIndex + 1,
                                bank: currentFile
                            });
                        });
                    } else if (!this.practiceManager.isPreviewMode) {
                        this.updatePageState('result');
                    }
                },

                prevQuestion() {
                    if (this.practiceManager && this.practiceManager.currentIndex > 0) {
                        // 如果在编辑模式，自动保存当前编辑并开始编辑上一题
                        if (this.isEditing) {
                            // 如果当前有未保存的字段编辑，先保存
                            if (this.editingField) {
                                this.exitEditMode();
                            }
                            // 如果有未保存的修改，自动保存
                            if (this.questionManager.checkUnsavedChanges()) {
                                this.questionManager.saveCurrentEdit();
                            }
                            this.practiceManager.currentIndex--;
                            this.questionManager.startEditing(this.practiceManager.questions[this.practiceManager.currentIndex]);
                            this.showAnswer = true;
                        } else {
                            this.practiceManager.currentIndex--;
                            this.showAnswer = false;
                            // 重置答案状态
                            this.chosenAnswer = null;
                            this.chosenAnswers = [];
                            this.fillInAnswers = [];
                            this.shortAnswerText = '';
                        }

                        // 立即更新URL参数
                        this.$nextTick(() => {
                            const currentFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                            this.updateUrlParams('quiz', {
                                mode: this.getCurrentMode(),
                                qid: this.practiceManager.currentIndex + 1,
                                bank: currentFile
                            });
                        });
                    }
                },

                formatDate(isoDate) {
                    if (!isoDate) return '';
                    const date = new Date(isoDate);
                    const today = new Date();
                    const yesterday = new Date(today);
                    yesterday.setDate(yesterday.getDate() - 1);

                    if (isoDate.startsWith(today.toISOString().split('T')[0])) {
                        return '今天 ' + date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                    } else if (isoDate.startsWith(yesterday.toISOString().split('T')[0])) {
                        return '昨天 ' + date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                    } else {
                        return date.toLocaleDateString('zh-CN') + ' ' +
                            date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                    }
                },
                closeUnsavedModal() {
                    this.showUnsavedModal = false;
                },
                truncateText(text, length) {
                    if (!text) return '';
                    text = text.replace(/<[^>]*>/g, ''); // 移除HTML标签
                    return text.length > length ? text.slice(0, length) + '...' : text;
                },
                getSetName(setId) {
                    return this.jsonLoader.sets.find(s => s.id === setId)?.name || setId;
                },
                checkModifiedQuestions() {
                    const modifiedQuestions = this.questionManager.getModifiedQuestions();
                    if (modifiedQuestions.length > 0 && !this.dontShowExportReminder) {
                        // 只显示当前题库的修改题目
                        this.groupedModifiedQuestions = this.jsonLoader.questions
                            .filter(q => modifiedQuestions.includes(q.uniqueId));

                        // 显示未导出提示模态框
                        this.showUnsavedModal = true;
                        return true;
                    }
                    return false;
                },
                showBanner(content, type = 'info', closeable = true) {
                    // 如果已有定时器，先清除
                    if (this.bannerTimer) {
                        clearTimeout(this.bannerTimer);
                        this.bannerTimer = null;
                    }
                    
                    this.banner = {
                        show: true,
                        content,
                        type,
                        closeable
                    };

                    // 3秒后自动隐藏
                    this.bannerTimer = setTimeout(() => {
                        this.closeBanner();
                    }, 3000);
                },
                closeBanner() {
                    if (this.bannerTimer) {
                        clearTimeout(this.bannerTimer);
                        this.bannerTimer = null;
                    }
                    this.banner.show = false;
                },
                formatUpdateTime(isoString) {
                    const date = new Date(isoString);
                    return date.toLocaleString('zh-CN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                },
                closeUnsavedModalAndContinue() {
                    this.showUnsavedModal = false;
                    this.questionManager.clearModifiedQuestions();
                    this.modifiedCount = 0;
                    this.showExportButton = false;
                },
                toggleTag(tag) {
                    const index = this.selectedTags.indexOf(tag);
                    if (index === -1) {
                        this.selectedTags.push(tag);
                    } else {
                        this.selectedTags.splice(index, 1);
                    }
                },
                clearTags() {
                    this.selectedTags = [];
                },
                async loadBankStats(fileName) {
                    console.log('[loadBankStats] Loading stats for:', fileName);
                    try {
                        // 获取统计信息
                        const stats = this.storageManager.getBankStats(fileName, this.jsonLoader);
                        console.log('[loadBankStats] Retrieved stats:', stats);
                        this.bankStats[fileName] = stats;

                        // 强制更新计算属性
                        this.$forceUpdate();
                        console.log('[loadBankStats] Stats updated and view forced to update');

                        // 如果在题库详情页面，确保setStats被重新计算
                        if (this.pageState === 'setDescription') {
                            console.log('[loadBankStats] Recalculating setStats for description page');
                            // Vue会自动重新计算setStats，因为依赖的数据已经更新
                            const currentStats = this.setStats;
                            console.log('[loadBankStats] Current setStats:', currentStats);
                        }
                    } catch (error) {
                        console.error('[loadBankStats] Error loading bank stats:', error);
                    }
                },
                focusPrevButton(event) {
                    console.log('focusPrevButton triggered', {
                        eventTarget: event.target,
                        eventType: event.type,
                        currentActiveElement: document.activeElement
                    });

                    const buttons = Array.from(document.querySelectorAll('.mode-btn'));
                    console.log('Found mode buttons:', {
                        totalButtons: buttons.length,
                        buttonTexts: buttons.map(btn => btn.textContent.trim())
                    });

                    const currentIndex = buttons.indexOf(event.target);
                    console.log('Current button index:', currentIndex);

                    const prevIndex = (currentIndex - 1 + buttons.length) % buttons.length;
                    console.log('Will focus on button index:', prevIndex);

                    buttons[prevIndex].focus();
                    console.log('Focus set to:', {
                        buttonText: buttons[prevIndex].textContent.trim(),
                        newActiveElement: document.activeElement
                    });
                },
                focusNextButton(event) {
                    console.log('focusNextButton triggered', {
                        eventTarget: event.target,
                        eventType: event.type,
                        currentActiveElement: document.activeElement
                    });

                    const buttons = Array.from(document.querySelectorAll('.mode-btn'));
                    console.log('Found mode buttons:', {
                        totalButtons: buttons.length,
                        buttonTexts: buttons.map(btn => btn.textContent.trim())
                    });

                    const currentIndex = buttons.indexOf(event.target);
                    console.log('Current button index:', currentIndex);

                    const nextIndex = (currentIndex + 1) % buttons.length;
                    console.log('Will focus on button index:', nextIndex);

                    buttons[nextIndex].focus();
                    console.log('Focus set to:', {
                        buttonText: buttons[nextIndex].textContent.trim(),
                        newActiveElement: document.activeElement
                    });
                },
                focusUpButton(event) {
                    console.log('focusUpButton triggered', {
                        eventTarget: event.target,
                        eventType: event.type,
                        currentActiveElement: document.activeElement
                    });

                    const buttons = Array.from(document.querySelectorAll('.mode-btn'));
                    console.log('Found mode buttons:', {
                        totalButtons: buttons.length,
                        buttonTexts: buttons.map(btn => btn.textContent.trim())
                    });

                    const currentIndex = buttons.indexOf(event.target);
                    console.log('Current button index:', currentIndex);

                    const COLS = window.innerWidth <= 600 ? 1 : 2;
                    console.log('Grid layout:', {
                        columns: COLS,
                        windowWidth: window.innerWidth
                    });

                    const prevIndex = currentIndex - COLS;
                    console.log('Calculated previous index:', prevIndex);

                    if (prevIndex >= 0) {
                        console.log('Moving up to index:', prevIndex);
                        buttons[prevIndex].focus();
                    } else {
                        // 如果到达顶部，跳转到最后一行的相同列
                        const sameColBottom = currentIndex % COLS + Math.floor((buttons.length - 1) / COLS) * COLS;
                        console.log('Wrapping to bottom, calculated index:', {
                            currentCol: currentIndex % COLS,
                            lastRowStart: Math.floor((buttons.length - 1) / COLS) * COLS,
                            targetIndex: sameColBottom
                        });

                        if (sameColBottom < buttons.length) {
                            buttons[sameColBottom].focus();
                        } else {
                            buttons[buttons.length - 1].focus();
                        }
                    }

                    console.log('Focus set to:', {
                        buttonText: document.activeElement.textContent.trim(),
                        newActiveElement: document.activeElement
                    });
                },
                focusDownButton(event) {
                    console.log('focusDownButton triggered', {
                        eventTarget: event.target,
                        eventType: event.type,
                        currentActiveElement: document.activeElement
                    });

                    const buttons = Array.from(document.querySelectorAll('.mode-btn'));
                    console.log('Found mode buttons:', {
                        totalButtons: buttons.length,
                        buttonTexts: buttons.map(btn => btn.textContent.trim())
                    });

                    const currentIndex = buttons.indexOf(event.target);
                    console.log('Current button index:', currentIndex);

                    const COLS = window.innerWidth <= 600 ? 1 : 2;
                    console.log('Grid layout:', {
                        columns: COLS,
                        windowWidth: window.innerWidth
                    });

                    const nextIndex = currentIndex + COLS;
                    console.log('Calculated next index:', nextIndex);

                    if (nextIndex < buttons.length) {
                        console.log('Moving down to index:', nextIndex);
                        buttons[nextIndex].focus();
                    } else {
                        // 如果到达底部，跳转到第一行的相同列
                        const sameColTop = currentIndex % COLS;
                        console.log('Wrapping to top, calculated index:', {
                            currentCol: currentIndex % COLS,
                            targetIndex: sameColTop
                        });
                        buttons[sameColTop].focus();
                    }

                    console.log('Focus set to:', {
                        buttonText: document.activeElement.textContent.trim(),
                        newActiveElement: document.activeElement
                    });
                },

                getFocusableElements() {
                    // 获取当前页面中所有可聚焦的元素
                    if (this.pageState === 'setDescription') {
                        // 在题库详情页中，只获取模式按钮
                        return Array.from(document.querySelectorAll('.mode-btn'))
                            .filter(el => {
                                const style = window.getComputedStyle(el);
                                return style.display !== 'none' && style.visibility !== 'hidden';
                            });
                    }

                    const selector = 'button, [tabindex="0"], a[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled])';
                    return Array.from(this.$el.querySelectorAll(selector))
                        .filter(el => {
                            // 确保元素是可见的
                            const style = window.getComputedStyle(el);
                            return style.display !== 'none' && style.visibility !== 'hidden';
                        });
                },
                initModeButtonsFocus() {
                    // 确保第一个按钮获得焦点
                    if (this.pageState === 'setDescription') {
                        this.$nextTick(() => {
                            const firstBtn = this.$refs.firstModeBtn;
                            if (firstBtn) {
                                firstBtn.focus();
                            }
                        });
                    }
                },
                // URL参数处理
                async handleUrlParams() {
                    const urlParams = new URLSearchParams(window.location.search);
                    const bankParam = urlParams.get('bank');
                    const stateParam = urlParams.get('state');
                    const modeParam = urlParams.get('mode');
                    const qidParam = urlParams.get('qid');

                    console.log('[handleUrlParams] Processing URL parameters:', {
                        bank: bankParam,
                        state: stateParam,
                        mode: modeParam,
                        qid: qidParam
                    });

                    if (!bankParam) {
                        console.log('[handleUrlParams] No bank parameter, staying on home page');
                        return;
                    }

                    // 确保题库列表已加载
                    if (this.fileList.length === 0) {
                        console.log('[handleUrlParams] File list not loaded yet, waiting...');
                        await this.loadBankList();
                    }

                    // 验证题库是否存在
                    const bankExists = this.fileList.some(f => f.file === bankParam);
                    if (!bankExists) {
                        console.error('[handleUrlParams] Bank not found:', bankParam);
                        alert('找不到指定的题库');
                        this.resetAllState();
                        return;
                    }

                    try {
                        this.isLoading = true;
                        // 加载题库数据
                        console.log('[handleUrlParams] Loading bank data:', bankParam);
                        const data = await this.jsonLoader.loadFile(bankParam);
                        console.log('[handleUrlParams] Bank data loaded:', {
                            setName: data.sets[0]?.name,
                            questionCount: data.questions?.length
                        });

                        // Set chosenSet with proper id
                        this.chosenSet = {
                            ...data.sets[0],
                            id: bankParam.replace('.json', '') // Ensure id matches the file name without extension
                        };

                        // 更新统计数据
                        console.log('[handleUrlParams] Updating bank stats');
                        const stats = await this.storageManager.getBankStats(bankParam, this.jsonLoader);
                        this.bankStats[bankParam] = stats;

                        // 根据state参数设置页面状态
                        if (stateParam === 'quiz' && modeParam) {
                            console.log('[handleUrlParams] Setting up quiz mode:', modeParam);
                            await this.setupQuizMode(modeParam, qidParam);
                        } else {
                            console.log('[handleUrlParams] Setting page state to:', stateParam || 'setDescription');
                            this.pageState = stateParam || 'setDescription';
                        }
                    } catch (error) {
                        console.error('[handleUrlParams] Failed to process URL parameters:', error);
                        alert('加载题库失败: ' + error.message);
                        this.resetAllState();
                    } finally {
                        this.isLoading = false;
                    }
                },

                // 设置练习模式，支持qid跳转
                async setupQuizMode(mode, qid = null) {
                    console.log('[setupQuizMode] Setting up quiz mode:', mode, {
                        currentQuestions: this.jsonLoader.questions?.length,
                        qid
                    });
                    try {
                        // 确保我们使用的是当前加载的题库数据
                        const questions = this.jsonLoader.questions;
                        if (!questions || questions.length === 0) {
                            throw new Error('No questions available for quiz mode');
                        }

                        switch (mode) {
                            case 'all':
                                this.practiceManager.initPractice(questions, 'sequence');
                                this.practiceManager.togglePreviewMode(false);
                                break;
                            case 'wrong':
                                this.practiceManager.initPractice(questions, 'error-rate');
                                this.practiceManager.togglePreviewMode(false);
                                break;
                            case 'random':
                                this.practiceManager.initPractice(questions, 'random');
                                this.practiceManager.togglePreviewMode(false);
                                break;
                            case 'preview':
                                this.practiceManager.initPractice(questions, 'sequence');
                                this.practiceManager.togglePreviewMode(true);
                                this.showAnswer = true;
                                break;
                        }

                        // 跳转到指定题目
                        if (qid) {
                            // 尝试通过序号定位（序号从1开始）
                            const num = parseInt(qid);
                            if (!isNaN(num) && num >= 1 && num <= this.practiceManager.questions.length) {
                                this.practiceManager.currentIndex = num - 1;
                            }
                        }

                        console.log('[setupQuizMode] Practice manager initialized with questions:', questions.length);
                        this.resetQuizState();
                        this.pageState = 'quiz';

                        // 更新URL参数，确保包含当前题目序号
                        const currentFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                        this.updateUrlParams('quiz', {
                            mode: mode,
                            qid: this.practiceManager.currentIndex + 1,
                            bank: currentFile
                        });

                        console.log('[setupQuizMode] Quiz mode setup completed');
                    } catch (error) {
                        console.error('[setupQuizMode] Failed to setup quiz mode:', error);
                        this.resetAllState();
                    }
                },

                // 处理浏览器前进/后退
                async handlePopState(event) {
                    console.log('[handlePopState] Processing popstate event:', event);
                    const urlParams = new URLSearchParams(window.location.search);
                    const bankParam = urlParams.get('bank');
                    const stateParam = urlParams.get('state');
                    const modeParam = urlParams.get('mode');
                    const practiceModeParam = urlParams.get('practiceMode');
                    const countParam = urlParams.get('count');

                    console.log('[handlePopState] URL parameters:', {
                        bank: bankParam,
                        state: stateParam,
                        mode: modeParam,
                        practiceMode: practiceModeParam,
                        count: countParam
                    });

                    if (!bankParam && modeParam !== 'cross') {
                        console.log('[handlePopState] No bank parameter and not cross mode, resetting state');
                        this.resetAllState();
                        return;
                    }

                    try {
                        if (modeParam === 'cross') {
                            // 跨卷练习模式
                            if (this.chosenSet?.isCrossPractice) {
                                // 已经在跨卷练习中，保持状态
                                console.log('[handlePopState] Already in cross practice mode');
                                return;
                            }
                            // 否则重置到首页
                            console.log('[handlePopState] Invalid cross practice state, resetting');
                            this.resetAllState();
                            return;
                        }

                        // 普通题库模式
                        const currentFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                        console.log('[handlePopState] Checking bank change:', {
                            current: currentFile,
                            new: bankParam
                        });

                        if (bankParam !== currentFile) {
                            console.log('[handlePopState] Loading new bank data');
                            const data = await this.jsonLoader.loadFile(bankParam);
                            // Set chosenSet with proper id
                            this.chosenSet = {
                                ...data.sets[0],
                                id: bankParam.replace('.json', '') // Ensure id matches the file name without extension
                            };
                            // 更新统计数据
                            await this.loadBankStats(bankParam);
                        }

                        // 根据state参数切换状态
                        if (stateParam) {
                            console.log('[handlePopState] Processing state:', stateParam);
                            switch (stateParam) {
                                case 'quiz':
                                    if (modeParam) {
                                        console.log('[handlePopState] Setting up quiz mode:', modeParam);
                                        this.setupQuizMode(modeParam);
                                    }
                                    break;
                                case 'setDescription':
                                    console.log('[handlePopState] Switching to setDescription');
                                    this.pageState = 'setDescription';
                                    break;
                                default:
                                    console.log('[handlePopState] Invalid state, resetting');
                                    this.resetAllState();
                            }
                        } else {
                            console.log('[handlePopState] No state parameter, defaulting to setDescription');
                            this.pageState = 'setDescription';
                        }
                    } catch (error) {
                        console.error('[handlePopState] Failed to handle popstate:', error);
                        this.resetAllState();
                    }
                },

                // 处理 URL 变化
                async handleUrlChange(event) {
                    // 避免重复处理 popstate 事件
                    if (event.type === 'popstate') {
                        return;
                    }

                    console.log('[handleUrlChange] URL changed:', {
                        oldURL: event.oldURL,
                        newURL: event.newURL || window.location.href
                    });

                    await this.handleUrlParams();
                },

                // 更新URL参数
                updateUrlParams(state, params = {}) {
                    console.log('[updateUrlParams] Updating URL parameters:', {
                        state,
                        params,
                        isCrossPractice: this.chosenSet?.isCrossPractice
                    });

                    const url = new URL(window.location.href);
                    const newParams = new URLSearchParams();

                    // 设置页面状态
                    newParams.set('state', state);

                    if (state === 'quiz') {
                        if (this.chosenSet?.isCrossPractice) {
                            // 跨题练习模式
                            newParams.set('mode', 'cross');
                            newParams.set('practiceMode', this.crossPracticeMode);
                            newParams.set('count', this.crossPracticeCount);

                            // 如果有当前题目，添加原题库信息
                            const currentQuestion = this.practiceManager?.getCurrentQuestion();
                            if (currentQuestion) {
                                const originalBank = this.findOriginalBank(currentQuestion);
                                if (originalBank) {
                                    newParams.set('sourceBank', originalBank.file);
                                }
                            }
                        } else {
                            // 普通练习模式
                            newParams.set('mode', params.mode || this.getCurrentMode());
                            if (params.qid) {
                                newParams.set('qid', params.qid);
                            }
                            if (params.bank) {
                                newParams.set('bank', params.bank);
                            }
                        }
                    } else if (state === 'setDescription' && params.bank) {
                        newParams.set('bank', params.bank);
                    }

                    // 更新URL，不刷新页面
                    url.search = newParams.toString();
                    window.history.pushState({
                        state,
                        params: Object.fromEntries(newParams.entries())
                    }, '', url);

                    console.log('[updateUrlParams] URL updated:', url.toString());
                },

                // 重置所有状态
                resetAllState() {
                    this.pageState = 'home';
                    this.chosenSet = null;
                    this.practiceManager?.reset();
                    this.resetQuizState();
                    this.showExportButton = false;
                    this.isEditing = false;
                    this.editingField = null;
                    this.editingContent = '';
                },

                // 重置答题状态
                resetQuizState() {
                    this.chosenAnswer = '';
                    this.chosenAnswers = [];
                    this.shortAnswerText = '';
                    this.fillInAnswers = [];
                    this.currentSessionCompleted.clear();
                    this.showAnswer = false;
                },

                // 全局Alt+H返回上一级快捷键
                handleGlobalBackShortcut(e) {
                    const tag = document.activeElement && document.activeElement.tagName;
                    if (tag === 'INPUT' || tag === 'TEXTAREA') return;

                    if (e.altKey && (e.key === 'h' || e.key === 'H')) {
                        console.log('[handleGlobalBackShortcut] Alt+H detected, pageState:', this.pageState);
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();

                        switch (this.pageState) {
                            case 'quiz':
                            case 'orderQuiz':
                            case 'randomQuiz':
                                if (!this.isEditing) {
                                    console.log('[handleGlobalBackShortcut] Calling goBack() from quiz mode');
                                    this.goBack();
                                }
                                break;
                            case 'setDescription':
                                this.updatePageState('home');
                                break;
                            case 'home':
                                // 在首页不做任何操作
                                break;
                        }
                        return false;
                    }
                },

                // 返回上一页
                goBack() {
                    if (this.pageState === 'quiz') {
                        // 如果有完成的题目，显示确认对话框
                        if (this.currentSessionCompleted.size > 0) {
                            if (!confirm('确定要退出练习吗？当前进度将不会保存。')) {
                                return;
                            }
                        }
                    }

                    // 重置状态
                    this.resetAllState();
                    this.updatePageState('home');
                },

                // 获取题目所属的题库
                getBankByQuestion(question) {
                    return this.filteredBankDistribution.find(
                        bank => bank.questions.some(q => q.uniqueId === question.uniqueId)
                    );
                },

                // 开始跨卷练习
                async startCrossPractice() {
                    if (!this.canStartCrossPractice) return;

                    try {
                        this.isLoading = true;

                        // 先加载所有需要的题库
                        const banksToLoad = this.filteredBankDistribution
                            .filter(bank => !this.jsonLoader.loadedBanks.has(bank.file))
                            .map(bank => bank.file);

                        if (banksToLoad.length > 0) {
                            await this.jsonLoader.loadMultipleBanks(banksToLoad);
                        }

                        // 收集所有符合条件的题目
                        let allQuestions = [];
                        this.filteredBankDistribution.forEach(bank => {
                            const bankQuestions = this.jsonLoader.getQuestionsFromBank(bank.file)
                                .filter(q => this.selectedQuestionTypes.includes(q.type));
                            allQuestions = allQuestions.concat(bankQuestions);
                        });

                        if (allQuestions.length === 0) {
                            throw new Error('没有找到符合条件的题目');
                        }

                        if (this.crossPracticeCount > allQuestions.length) {
                            this.crossPracticeCount = allQuestions.length;
                        }

                        // 根据模式排序题目
                        if (this.crossPracticeMode === 'error-rate') {
                            allQuestions.sort((a, b) => {
                                const statsA = this.storageManager.getQuestionStats(this.getBankByQuestion(a).file, a.uniqueId);
                                const statsB = this.storageManager.getQuestionStats(this.getBankByQuestion(b).file, b.uniqueId);
                                const errorRateA = statsA ? 1 - (statsA.correct / statsA.attempts) : 1;
                                const errorRateB = statsB ? 1 - (statsB.correct / statsB.attempts) : 1;
                                return errorRateB - errorRateA;
                            });
                        } else {
                            // 随机模式
                            allQuestions = this.shuffleArray(allQuestions);
                        }

                        // 选择指定数量的题目
                        const selectedQuestions = allQuestions.slice(0, this.crossPracticeCount);

                        // 为每个题目添加来源题库信息并打乱选项
                        const questionsWithSource = selectedQuestions.map(q => {
                            const questionCopy = { ...q };
                            // 如果是单选或多选题，打乱选项
                            if ((questionCopy.type === 'single-choice' || questionCopy.type === 'multiple-choice') && Array.isArray(questionCopy.options)) {
                                const originalOptions = [...questionCopy.options];
                                const originalCorrectAnswer = [...questionCopy.correct_answer];
                                const shuffledOptions = this.shuffleArray([...originalOptions]);

                                // 更新正确答案
                                if (questionCopy.type === 'single-choice') {
                                    const oldCorrectAnswer = originalCorrectAnswer[0];
                                    const newIndex = shuffledOptions.indexOf(oldCorrectAnswer);
                                    if (newIndex !== -1) {
                                        questionCopy.correct_answer = [shuffledOptions[newIndex]];
                                    }
                                } else {
                                    questionCopy.correct_answer = originalCorrectAnswer.map(ans => {
                                        const newAns = shuffledOptions[originalOptions.indexOf(ans)];
                                        return newAns;
                                    });
                                }
                                questionCopy.options = shuffledOptions;
                            }
                            return {
                                ...questionCopy,
                                sourceBank: this.getBankByQuestion(q).name || '未知题库'
                            };
                        });

                        // 创建虚拟题库集合
                        const virtualSet = {
                            id: 'cross-practice-' + Date.now(),
                            name: '跨卷练习',
                            description: `从${this.filteredBankDistribution.length}个题库中选择的${this.crossPracticeCount}道题目\n\n包含题库：\n${this.filteredBankDistribution.map(bank => `- ${bank.name} (${bank.questionCount}题)`).join('\n')}`,
                            isCrossPractice: true
                        };

                        // 初始化练习
                        this.chosenSet = virtualSet;
                        this.practiceManager.initPractice(questionsWithSource, this.crossPracticeMode);
                        this.showCrossPracticeModal = false;
                        this.updatePageState('quiz', {
                            mode: 'cross',
                            practiceMode: this.crossPracticeMode,
                            count: this.crossPracticeCount
                        });
                    } catch (error) {
                        console.error('Failed to start cross practice:', error);
                        alert(error.message || '启动跨卷练习失败');
                    } finally {
                        this.isLoading = false;
                    }
                },

                // 数组随机打乱
                shuffleArray(array) {
                    for (let i = array.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [array[i], array[j]] = [array[j], array[i]];
                    }
                    return array;
                },

                // 验证题目数量
                handleQuestionInput(event) {
                    const rawValue = event.target.value;
                    console.log('[handleQuestionInput] Input event:', {
                        type: event.type,
                        rawValue: rawValue,
                        maxQuestionCount: this.maxQuestionCount
                    });

                    let value = parseInt(rawValue);

                    // 允许输入框暂时为空
                    if (rawValue === '') {
                        this.crossPracticeCount = '';
                        return;
                    }

                    // 确保输入的是数字
                    if (!isNaN(value)) {
                        // 不在这里限制最大值，让用户可以输入任何数字
                        this.crossPracticeCount = value;
                        // 更新分布但不限制输入值
                        this.updateBankDistribution();
                    }
                },

                // 在失去焦点时验证和更新值
                handleQuestionBlur() {
                    console.log('[handleQuestionBlur] Validating value:', {
                        currentCount: this.crossPracticeCount,
                        maxCount: this.maxQuestionCount
                    });

                    let value = parseInt(this.crossPracticeCount);

                    // 处理无效输入
                    if (isNaN(value) || value < 1) {
                        value = 1;
                    }

                    // 在失去焦点时才限制最大值
                    if (value > this.maxQuestionCount) {
                        value = this.maxQuestionCount;
                    }

                    this.crossPracticeCount = value;
                    this.updateBankDistribution();
                },

                // 更新题库分布
                updateBankDistribution() {
                    console.log('[updateBankDistribution] Updating with count:', {
                        requestedCount: this.crossPracticeCount,
                        maxAvailable: this.maxQuestionCount
                    });

                    // 确保 crossPracticeCount 是有效的数字
                    let totalRequestedQuestions = Math.max(1, parseInt(this.crossPracticeCount) || 0);

                    // 不在这里限制最大值，让分配逻辑处理超出的情况
                    let remainingQuestions = totalRequestedQuestions;

                    // 获取有可用题目的题库
                    const availableBanks = this.filteredBankDistribution.filter(bank => bank.availableQuestions > 0);
                    if (availableBanks.length === 0) {
                        console.log('[updateBankDistribution] No available banks found');
                        return;
                    }

                    // 计算总可用题目数
                    const totalAvailable = availableBanks.reduce((sum, bank) => sum + bank.availableQuestions, 0);

                    // 按比例分配题目
                    availableBanks.forEach(bank => {
                        const proportion = bank.availableQuestions / totalAvailable;
                        bank.questionCount = Math.min(
                            Math.floor(remainingQuestions * proportion),
                            bank.availableQuestions
                        );
                        remainingQuestions -= bank.questionCount;
                    });

                    // 分配剩余的题目
                    while (remainingQuestions > 0) {
                        let distributed = false;
                        for (const bank of availableBanks) {
                            if (bank.questionCount < bank.availableQuestions) {
                                bank.questionCount++;
                                remainingQuestions--;
                                distributed = true;
                                if (remainingQuestions === 0) break;
                            }
                        }
                        if (!distributed) break;
                    }

                    console.log('[updateBankDistribution] Final distribution:',
                        this.filteredBankDistribution.map(bank => ({
                            name: bank.name,
                            available: bank.availableQuestions,
                            assigned: bank.questionCount,
                            percentage: this.calculateBankPercentage(bank)
                        }))
                    );
                },
                backToHome() {
                    if (this.showAnswer || confirm('确定要退出练习吗？当前进度将不会保存。')) {
                        this.updatePageState('home');
                    }
                },

                // 复制当前题目链接
                async copyCurrentLink() {
                    try {
                        const url = new URL(window.location.href);
                        const params = new URLSearchParams(url.search);

                        // 获取当前题目
                        const currentQuestion = this.practiceManager.getCurrentQuestion();
                        if (!currentQuestion) return;

                        let bankFile, questionSequenceNumber;

                        if (this.chosenSet.isCrossPractice) {
                            // 对于跨题练习，找到原题库
                            const originalBank = this.findOriginalBank(currentQuestion);
                            if (originalBank) {
                                bankFile = originalBank.file;
                                // 在原题库中查找题目序号
                                const originalQuestions = this.jsonLoader.getQuestionsFromBank(bankFile);
                                questionSequenceNumber = originalQuestions.findIndex(q =>
                                    q.uniqueId === currentQuestion.uniqueId
                                ) + 1;
                            }
                        } else {
                            // 普通练习模式
                            bankFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                            questionSequenceNumber = this.practiceManager.currentIndex + 1;
                        }

                        if (bankFile && questionSequenceNumber > 0) {
                            // 更新URL参数
                            this.updateUrlParams('quiz', {
                                mode: 'all', // 使用普通练习模式的链接
                                qid: questionSequenceNumber,
                                bank: bankFile
                            });

                            // 获取更新后的URL
                            const finalUrl = window.location.href;
                            await navigator.clipboard.writeText(finalUrl);

                            // 显示成功提示
                            this.showToast('链接已复制到剪贴板');
                        } else {
                            throw new Error('无法找到原题目位置');
                        }
                    } catch (error) {
                        console.error('Failed to copy link:', error);
                        this.showToast('复制链接失败', 'error');
                    }
                },
                saveCurrentEdit() {
                    this.questionManager.saveCurrentEdit();
                    // 更新修改计数
                    this.modifiedCount = this.questionManager.getModifiedQuestions().length;
                    // 导出修改后的JSON
                    this.exportModifiedData();
                },
                // 获取当前练习模式
                getCurrentMode() {
                    if (!this.practiceManager) return 'all';
                    if (this.isEditing) return 'preview';
                    if (this.practiceManager.mode === 'random') return 'random';
                    if (this.practiceManager.mode === 'error-rate') return 'wrong';
                    return 'all';
                },
                // 获取当前题目ID
                getCurrentQuestionId() {
                    if (!this.practiceManager || !this.practiceManager.questions) return null;

                    const currentQuestion = this.practiceManager.getCurrentQuestion();
                    if (!currentQuestion) return null;

                    if (this.chosenSet.isCrossPractice) {
                        // 对于跨题练习，返回原题库中的序号
                        const originalBank = this.findOriginalBank(currentQuestion);
                        if (originalBank) {
                            const originalQuestions = this.jsonLoader.getQuestionsFromBank(originalBank.file);
                            const index = originalQuestions.findIndex(q => q.uniqueId === currentQuestion.uniqueId);
                            return index >= 0 ? index + 1 : null;
                        }
                        return null;
                    }

                    // 普通练习模式
                    return this.practiceManager.currentIndex + 1;
                },

                // 生成AI解析
                async generateAIAnalysis() {
                    if (!this.practiceManager || !this.currentQuestion || this.isGeneratingAnalysis) return;

                    try {
                        this.isGeneratingAnalysis = true;
                        this.aiAnalysisExplanation = '正在生成解析...\n';
                        console.log('[generateAIAnalysis] Starting AI analysis');

                        // 获取当前答案
                        let answer;
                        switch (this.currentQuestion.type) {
                            case 'single-choice':
                                answer = this.chosenAnswer;
                                break;
                            case 'multiple-choice':
                                answer = this.chosenAnswers;
                                break;
                            case 'fill-in-blank':
                                answer = this.fillInAnswers;
                                break;
                            case 'short-answer':
                                answer = this.shortAnswerText;
                                break;
                        }

                        // 调用AI解析
                        const response = await this.practiceManager.getAIAnalysis(answer, this.currentQuestion);
                        
                        let fullContent = '';
                        let partialContent = '';
                        let result = null;
                        let isReasoningPhase = false;

                        for await (const chunk of response) {
                            console.log('[generateAIAnalysis] Received chunk:', chunk);
                            
                            switch (chunk.type) {
                                case 'reasoning': {
                                    isReasoningPhase = true;
                                    this.aiAnalysisExplanation = '正在生成解析...\n' + chunk.content;
                                    break;
                                }
                                case 'answer': {
                                    fullContent += chunk.content;
                                    
                                    try {
                                        // 尝试解析完整的 JSON
                                        const parsed = JSON.parse(fullContent);
                                        if (parsed.analysis) {
                                            result = parsed;
                                            this.aiAnalysis = result.analysis;
                                            this.aiAnalysisExplanation = result.analysis;
                                        }
                                    } catch (error) {
                                        // JSON 还不完整，继续累积内容
                                        if (!isReasoningPhase) {
                                            partialContent += chunk.content;
                                            
                                            // 尝试从部分内容中提取有意义的文本
                                            let cleanContent = partialContent
                                                .replace(/^{?\s*"analysis":\s*"?/, '')
                                                .replace(/\\"/, '"')
                                                .replace(/"}$/, '')
                                                .replace(/,$/, '')
                                                .trim();
                                            
                                            if (cleanContent) {
                                                this.aiAnalysisExplanation = '正在生成解析...\n' + cleanContent;
                                            }
                                        }
                                    }
                                    break;
                                }
                            }
                        }

                        // 最后一次尝试解析
                        if (!result && fullContent) {
                            try {
                                const parsed = JSON.parse(fullContent);
                                if (parsed.analysis) {
                                    this.aiAnalysis = parsed.analysis;
                                    this.aiAnalysisExplanation = parsed.analysis;
                                }
                            } catch (error) {
                                console.error('[generateAIAnalysis] Failed to parse final content:', error);
                            }
                        }

                    } catch (error) {
                        console.error('[generateAIAnalysis] Failed to generate AI analysis:', error);
                        this.showToast('生成AI解析失败，点击右上角鲸鱼图标检查配置，或稍后重试', 'error');
                    } finally {
                        this.isGeneratingAnalysis = false;
                        this.aiAnalysisExplanation = '';
                    }
                },

                // 渲染AI解析
                renderedAIAnalysis() {
                    try {
                        if (!this.aiAnalysis) return '';
                        
                        // 尝试解析内容
                        let content = '';
                        if (typeof this.aiAnalysis === 'object') {
                            content = this.aiAnalysis.analysis || '';
                        } else if (typeof this.aiAnalysis === 'string') {
                            try {
                                const parsed = JSON.parse(this.aiAnalysis);
                                content = parsed.analysis || this.aiAnalysis;
                            } catch (e) {
                                content = this.aiAnalysis;
                            }
                        }
                        
                        // 如果内容是空字符串，返回空
                        if (!content || !content.trim()) return '';
                        
                        // 渲染 Markdown 和 LaTeX
                        return this.renderMarkdownWithLatex(content);
                    } catch (error) {
                        console.error('[renderedAIAnalysis] Error rendering analysis:', error, {
                            aiAnalysis: this.aiAnalysis,
                            type: typeof this.aiAnalysis
                        });
                        return '';
                    }
                },

                // AI 相关方法
                initAIConfig() {
                    try {
                        console.log('[initAIConfig] Starting AI configuration initialization');
                        
                        // 确保 aiManager 已经被正确导入
                        if (!aiManager) {
                            throw new Error('AIManager instance not available');
                        }
                        
                        this.presets = aiManager.getPresets();
                        this.aiApiKey = aiManager.getApiKey();

                        console.log('[initAIConfig] Current configuration', {
                            presets: this.presets,
                            selectedPresetId: this.selectedPresetId,
                            hasApiKey: !!this.aiApiKey
                        });

                        // 设置默认预设
                        if (this.presets[this.selectedPresetId]) {
                            aiManager.setSelectedPreset(this.selectedPresetId);
                            console.log('[initAIConfig] Set default preset:', this.selectedPresetId);
                        }

                        // 确保将 aiManager 实例传递给 practiceManager
                        if (this.practiceManager) {
                            this.practiceManager.setAIManager(aiManager);
                            console.log('[initAIConfig] AIManager instance set to PracticeManager');
                        }

                        // 初始化自动评分设置
                        this.autoScoring = aiManager.getAutoScoring();
                        console.log('[initAIConfig] Auto scoring initialized:', this.autoScoring);
                    } catch (error) {
                        console.error('[initAIConfig] Failed to initialize AI config:', error);
                    }
                },

                updateApiKey() {
                    if (this.currentProvider) {
                        console.log('[updateApiKey] Updating API key for provider:', this.currentProvider);
                        const key = this.providerApiKeys[this.currentProvider];
                        aiManager.setApiKey(this.currentProvider, key);
                        console.log('[updateApiKey] API key updated successfully');
                    }
                },

                calculateBankPercentage(bank) {
                    if (!bank || typeof bank.questionCount !== 'number' || typeof bank.availableQuestions !== 'number' || bank.availableQuestions === 0) {
                        return 0;
                    }
                    return Math.round((bank.questionCount / bank.availableQuestions) * 100) || 0;
                },
                showToast(message, type = 'success') {
                    const toast = document.createElement('div');
                    toast.textContent = message;
                    toast.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: ${type === 'success' ? 'rgba(0, 0, 0, 0.8)' : 'rgba(255, 0, 0, 0.8)'};
                    color: white;
                    padding: 8px 16px;
                    border-radius: 4px;
                    z-index: 1000;
                `;
                    document.body.appendChild(toast);
                    setTimeout(() => toast.remove(), 2000);
                },

                // 音效配置相关方法
                initSoundConfig() {
                    import('./js/modules/ComboAudioManager.js').then(module => {
                        const ComboAudioManager = module.default;
                        
                        // 从本地存储加载配置
                        const savedConfig = JSON.parse(localStorage.getItem('SOUND_CONFIG') || '{}');
                        this.audioEnabled = savedConfig.audioEnabled ?? true;
                        this.volumeValue = savedConfig.volumeValue ?? 100;
                        this.comboWindowMs = savedConfig.comboWindowMs ?? 3000;
                        this.resetTimeoutMs = savedConfig.resetTimeoutMs ?? 5000;

                        // 创建音频管理器并应用配置
                        this.audioManager = new ComboAudioManager({
                            comboWindowMs: this.comboWindowMs,
                            comboResetTimeoutMs: this.resetTimeoutMs,
                            minScoreForSound: 1
                        });

                        // 应用音量和静音设置
                        const volume = this.volumeValue / 100;
                        this.audioManager.positiveAudios.forEach(audio => {
                            audio.volume = volume;
                            audio.muted = !this.audioEnabled;
                        });
                        this.audioManager.negativeAudios.forEach(audio => {
                            audio.volume = volume;
                            audio.muted = !this.audioEnabled;
                        });

                        console.log('[initSoundConfig] Loaded sound config:', {
                            audioEnabled: this.audioEnabled,
                            volumeValue: this.volumeValue,
                            comboWindowMs: this.comboWindowMs,
                            resetTimeoutMs: this.resetTimeoutMs
                        });
                    });
                },

                updateAudioConfig() {
                    if (!this.audioManager) return;

                    // 更新音频管理器配置
                    Object.assign(this.audioManager, {
                        comboWindowMs: this.comboWindowMs,
                        comboResetTimeoutMs: this.resetTimeoutMs,
                        minScoreForSound: 1
                    });

                    // 应用音量和静音设置
                    const volume = this.volumeValue / 100;
                    this.audioManager.positiveAudios.forEach(audio => {
                        audio.volume = volume;
                        audio.muted = !this.audioEnabled;
                    });
                    this.audioManager.negativeAudios.forEach(audio => {
                        audio.volume = volume;
                        audio.muted = !this.audioEnabled;
                    });

                    // 保存配置到本地存储
                    const config = {
                        audioEnabled: this.audioEnabled,
                        volumeValue: this.volumeValue,
                        comboWindowMs: this.comboWindowMs,
                        resetTimeoutMs: this.resetTimeoutMs
                    };
                    localStorage.setItem('SOUND_CONFIG', JSON.stringify(config));
                    console.log('[updateAudioConfig] Saved sound config:', config);
                },

                testSound(type, level) {
                    if (!this.audioManager) return;
                    
                    if (type === 'positive') {
                        this.audioManager.addPoints(level);
                    } else {
                        this.audioManager.subtractPoints(level);
                    }
                },

                closeSoundModal() {
                    this.showSoundModal = false;
                    this.updateAudioConfig();
                    this.stopTimer();
                },

                // 计分和计时相关方法
                startTimer() {
                    if (this.timerInterval) {
                        clearInterval(this.timerInterval);
                    }
                    this.timerInterval = setInterval(() => {
                        if (!this.audioManager) return;
                        
                        const now = Date.now();
                        const comboEndTime = this.audioManager.comboEndTime;
                        
                        if (comboEndTime > now) {
                            this.timeLeft = (comboEndTime - now) / 1000;
                            this.timerProgress = (this.timeLeft / (this.comboWindowMs / 1000)) * 100;
                        } else {
                            this.timeLeft = 0;
                            this.timerProgress = 0;
                        }
                    }, 100);
                },

                stopTimer() {
                    if (this.timerInterval) {
                        clearInterval(this.timerInterval);
                        this.timerInterval = null;
                    }
                },

                addScore() {
                    if (!this.audioManager) return;
                    this.audioManager.addPoints(1);
                    this.currentScore = this.audioManager.getScore();
                    this.startTimer();
                },

                subtractScore() {
                    if (!this.audioManager) return;
                    this.audioManager.subtractPoints(1);
                    this.currentScore = this.audioManager.getScore();
                    this.startTimer();
                },

                resetScore() {
                    if (!this.audioManager) return;
                    this.audioManager.reset();
                    this.currentScore = 0;
                    this.timeLeft = 0;
                    this.timerProgress = 0;
                    this.stopTimer();
                },
                // 添加 goHome 方法
                goHome(event) {
                    event.preventDefault();
                    if (this.pageState === 'quiz') {
                        // 如果有完成的题目，显示确认对话框
                        if (this.currentSessionCompleted.size > 0) {
                            if (!confirm('确定要退出练习吗？当前进度将不会保存。')) {
                                return;
                            }
                        }
                    }

                    // 重置状态
                    this.resetAllState();
                    this.updatePageState('home');
                },
                // AI 相关方法
                closeAIModal() {
                    this.showAIModal = false;
                },

                updateAutoScoring() {
                    // 如果要启用自动评分，先检查是否有 API key
                    if (this.autoScoring && !aiManager.hasApiKey()) {
                        this.showBanner('请先配置 API Key 再启用自动评分', 'warning');
                        this.autoScoring = false;
                        return;
                    }
                    aiManager.setAutoScoring(this.autoScoring);
                },

                deleteProviderApiKey() {
                    if (this.currentProvider) {
                        // 清除输入框中的值
                        this.providerApiKeys[this.currentProvider] = '';
                        // 从 localStorage 中删除
                        aiManager.deleteApiKey(this.currentProvider);
                        // 显示提示
                        this.showBanner(`已删除 ${this.currentPreset.name} 的 API Key`, 'info');
                    }
                },

                handlePresetChange() {
                    try {
                        aiManager.setSelectedPreset(this.selectedPresetId);
                        this.log('info', `切换到模型: ${this.presets[this.selectedPresetId].name}`);
                    } catch (error) {
                        console.error('切换模型失败:', error);
                        this.log('error', `切换模型失败: ${error.message}`);
                    }
                },

                getModelDescription(presetId) {
                    const preset = this.presets[presetId];
                    if (!preset) return '';
                    return `${preset.name} (${preset.model})`;
                },

                formatTime(timestamp) {
                    const date = new Date(timestamp);
                    return date.toLocaleTimeString();
                },

                updateLogLevel(event) {
                    const newLevel = event.target.value;
                    this.logLevel = newLevel;
                    aiManager.setLogLevel(newLevel);
                    localStorage.setItem('AI_LOG_LEVEL', newLevel);
                },

                clearLogs() {
                    aiManager.clearLogs();
                    this.logs = [];
                },
                log(level, message) {
                    aiManager.log(level, message);
                },

                // 初始化键盘事件监听
                initKeyboardEvents() {
                    this.$nextTick(() => {
                        if (this.pageState === 'setDescription') {
                            console.log('Page mounted in setDescription state');
                            const buttons = document.querySelectorAll('.mode-btn');
                            console.log('Initial mode buttons state:', {
                                totalButtons: buttons.length,
                                buttonElements: Array.from(buttons).map(btn => ({
                                    text: btn.textContent.trim(),
                                    tabIndex: btn.tabIndex,
                                    hasClickHandler: btn.onclick !== null,
                                    hasKeydownHandler: btn.onkeydown !== null
                                }))
                            });
                        }
                    });

                    // 添加浏览器前进/后退按钮支持
                    window.addEventListener('popstate', this.handlePopState);

                    // 添加 URL 变化监听
                    window.addEventListener('hashchange', this.handleUrlChange);
                    window.addEventListener('popstate', this.handleUrlChange);

                    // 添加全局Alt+H返回快捷键
                    window.addEventListener('keydown', this.handleGlobalBackShortcut);
                },

                // AI 流式渲染测试
                async testStreaming() {
                    if (!this.checkApiKey()) return;
                    
                    this.isTestingStream = true;
                    this.testStreamContent = '正在连接...';
                    
                    try {
                        const systemPrompt = `你是一个专业的题目解析系统。你需要解释为什么给定的答案是正确的。
你必须以JSON格式返回结果，包含以下字段：
{
    "analysis": "解析内容，需要：
    1. 聚焦答案路径，说明如何最直接判断出正确答案
    2. 解释题目中带「」的概念
    3. 使用简短有力的语句
    4. 语言朴实易懂
    5. 控制篇幅"
}`;

                        const response = await this.aiManager.streamChat([
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: this.testPrompt }
                        ], {
                            response_format: { type: 'json_object' }
                        });

                        let fullContent = '';
                        let partialContent = '';
                        let isReasoningPhase = false;

                        for await (const chunk of response) {
                            switch (chunk.type) {
                                case 'reasoning': {
                                    isReasoningPhase = true;
                                    this.testStreamContent = '正在思考中...\n' + chunk.content;
                                    break;
                                }
                                case 'answer': {
                                    fullContent += chunk.content;
                                    try {
                                        // 尝试解析完整的 JSON
                                        const parsed = JSON.parse(fullContent);
                                        if (parsed.analysis) {
                                            this.testStreamContent = parsed.analysis;
                                        }
                                    } catch (error) {
                                        // JSON 还不完整，尝试提取部分内容进行渲染
                                        if (!isReasoningPhase) {
                                            partialContent += chunk.content;
                                            
                                            // 尝试从部分内容中提取有意义的文本
                                            let cleanContent = partialContent
                                                .replace(/^{?\s*"analysis":\s*"?/, '')
                                                .replace(/\\n/g, '\n')
                                                .replace(/\\"/, '"');
                                                    
                                            // 如果内容看起来是完整的JSON结尾，移除它
                                            if (cleanContent.endsWith('"}')) {
                                                cleanContent = cleanContent.slice(0, -2);
                                            }
                                            
                                            this.testStreamContent = cleanContent;
                                        }
                                    }
                                    break;
                                }
                                case 'finish': {
                                    console.log('[testStreaming] Stream finished:', chunk.reason);
                                    break;
                                }
                                case 'tool_calls': {
                                    console.log('[testStreaming] Tool calls received:', chunk.content);
                                    break;
                                }
                            }
                        }
                    } catch (error) {
                        console.error('[testStreaming] Error:', error);
                        if (error.message === 'API Key not set') {
                            this.showToast('先配置 API Key 再测试', 'info');
                        } else {
                            this.showToast('测试失败: ' + error.message, 'error');
                        }
                        this.testStreamContent = '测试失败: ' + error.message;
                    } finally {
                        this.isTestingStream = false;
                    }
                },

                // 渲染测试内容
                renderedTestContent() {
                    if (!this.testStreamContent) return '';
                    return this.renderMarkdownWithLatex(this.testStreamContent);
                },

                // 添加手动触发AI评分的方法
                async triggerAIScoring() {
                    if (!this.checkApiKey()) return;
                    
                    try {
                        const q = this.currentQuestion;
                        let answer;
                        let isCorrect;
                        
                        if (q.type === 'fill-in-blank') {
                            answer = this.fillInAnswers.join('\n');
                        } else if (q.type === 'short-answer') {
                            answer = this.shortAnswerText;
                        } else {
                            return;
                        }
                        
                        isCorrect = await this.practiceManager.checkAnswerWithAI(answer, q);
                        
                        // 更新题目状态
                        if (isCorrect !== null) {
                            await this.practiceManager.updateQuestionStatus(q.id, isCorrect);
                            this.updateLocalStats(isCorrect);
                        }
                    } catch (error) {
                        if (error.message === 'API Key not set') {
                            this.showToast('请点击右上角的鲸鱼图标设置 API Key', 'info');
                        } else {
                            this.showToast('AI 评分失败: ' + error.message, 'error');
                        }
                    }
                },

                // Show a toast notification
                showToast(message, type = 'info', duration = 3000) {
                    const toast = {
                        id: Date.now(),
                        message,
                        type
                    };
                    this.toasts.push(toast);

                    // Remove the toast after duration
                    setTimeout(() => {
                        const index = this.toasts.findIndex(t => t.id === toast.id);
                        if (index > -1) {
                            const toastElement = document.querySelector(`[data-toast-id="${toast.id}"]`);
                            if (toastElement) {
                                toastElement.style.animation = 'fadeOut 0.3s ease-out';
                                setTimeout(() => {
                                    this.toasts.splice(index, 1);
                                }, 300);
                            } else {
                                this.toasts.splice(index, 1);
                            }
                        }
                    }, duration);
                },

                // Check if API key is set before AI operations
                checkApiKey() {
                    if (!this.aiManager?.hasApiKey()) {
                        this.showToast('请点击右上角的鲸鱼图标设置 API Key', 'info');
                        return false;
                    }
                    return true;
                },
            }
        };

        // 创建 Vue 应用
        const app = Vue.createApp(appConfig);
        app.mount('#app');
    </script>

</body>

</html>