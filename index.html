<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <title>åˆ·é¢˜</title>
    <meta name="referrer" content="no-referrer">
    <link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/katex.min.css">
    <script defer src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/katex.min.js"></script>
    <script defer src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/contrib/auto-render.min.js"></script>
    <script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vue/3.2.23/vue.global.prod.min.js"></script>
    <script src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/marked/4.0.2/marked.min.js"></script>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/mobile.css">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
</head>
<body>
<div id="app" class="container">
    <!-- æœªä¿å­˜ä¿®æ”¹çš„æ¨¡æ€çª—å£ -->
    <div v-if="showUnsavedModal" class="modal-overlay" @click.self="closeUnsavedModal">
        <div class="modal-content">
            <h3>æœªå¯¼å‡ºçš„ä¿®æ”¹</h3>
            <div class="modal-body">
                <p>å½“å‰é¢˜åº“æœ‰æœªå¯¼å‡ºçš„ä¿®æ”¹ï¼š</p>
                <div class="modified-questions-list">
                    <ul>
                        <li v-for="q in groupedModifiedQuestions" :key="q.uniqueId">
                            é¢˜ç›®ID: {{ q.uniqueId }}
                            <br>
                            <span class="question-preview">{{ truncateText(q.content, 50) }}</span>
                        </li>
                    </ul>
                    <button class="btn export-btn" @click="exportModifiedData">
                        å¯¼å‡ºä¿®æ”¹
                    </button>
                </div>
                <div class="modal-actions">
                    <button class="btn" @click="closeUnsavedModal">å…³é—­</button>
                    <label class="dont-show-again">
                        <input type="checkbox" v-model="dontShowExportReminder">
                        ä¸å†æé†’
                    </label>
                </div>
            </div>
        </div>
    </div>

    <!-- å¯¼èˆªæ  -->
    <div class="nav">
        <a href="#" class="nav-title-link" @click="goHome" @mouseover="hoverTitle = true" @mouseout="hoverTitle = false">
            <span class="nav-title">Quiz App</span>
        </a>
        <a href="https://github.com/wzj042/quiz-app" class="github-link" target="_blank" rel="noopener noreferrer" title="View on GitHub">
            <svg class="github-icon" viewBox="0 0 16 16" width="24" height="24">
                <path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
            </svg>
        </a>
    </div>

    <!-- é€šçŸ¥æ¨ªå¹… -->
    <div v-if="banner.show" :class="['banner', `banner-${banner.type}`]">
        <div class="banner-content" v-html="renderMarkdown(banner.content)"></div>
        <button class="banner-close" @click="closeBanner" v-if="banner.closeable">
            <svg viewBox="0 0 24 24" width="16" height="16">
                <path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
            </svg>
        </button>
    </div>

    <!-- åˆ—å‡ºé¢˜åº“ -->
    <div v-if="pageState === 'home'" class="card">
        <h1 class="title">é€‰æ‹©é¢˜åº“</h1>
        <!-- åŠ è½½çŠ¶æ€ -->
        <div v-if="isLoading" class="loading-state">
            æ­£åœ¨åŠ è½½é¢˜åº“åˆ—è¡¨...
        </div>
        <!-- é”™è¯¯çŠ¶æ€ -->
        <div v-else-if="loadError" class="error-state">
            åŠ è½½å¤±è´¥: {{ loadError }}
            <button @click="loadBankList" class="btn">é‡è¯•</button>
        </div>
        <!-- æ€»ä½“ç»Ÿè®¡ -->
        <div v-else class="overall-stats">
            <div class="stats-title">æ€»ä½“ç»Ÿè®¡</div>
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="stats-value">{{ totalStats.totalCompleted }}/{{ totalStats.totalQuestions }}</div>
                    <div class="stats-label">æ€»å®Œæˆé¢˜æ•°</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value">{{ totalStats.averageAccuracy }}%</div>
                    <div class="stats-label">å¹³å‡æ­£ç¡®ç‡</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value">{{ totalStats.todayPracticed }}</div>
                    <div class="stats-label">ä»Šæ—¥å·²ç»ƒä¹ </div>
                </div>
            </div>
        </div>
        <!-- é¢˜åº“åˆ—è¡¨ -->
        <ul v-else class="horizontal-list">
            <li
                v-for="(fileObj, idx) in fileList"
                :key="idx"
                class="quiz-item"
                @click="loadJsonFile(fileObj.file)"
            >
                <div class="quiz-item-content">
                    <div class="quiz-item-title">{{ fileObj.name }}</div>
                    <div class="quiz-item-stats" v-if="getBankStats(fileObj.file)">
                        <div class="quiz-stat">
                            å®Œæˆï¼š{{ getBankStats(fileObj.file).completed }}/{{ getBankStats(fileObj.file).total }}
                        </div>
                        <div class="quiz-stat">
                            æ­£ç¡®ç‡ï¼š{{ getBankStats(fileObj.file).accuracy }}%
                        </div>
                    </div>
                </div>
            </li>
        </ul>
        <!-- å¦‚æœåˆ—è¡¨ä¸ºç©º -->
        <div v-if="!isLoading && !loadError && fileList.length === 0" class="empty-state">
            æ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„é¢˜åº“
        </div>
    </div>

    <!-- é¢˜åº“è¯¦æƒ…é¡µé¢ -->
    <div v-else-if="pageState === 'setDescription'" class="card">
        <h1 class="title">{{ chosenSet.name }}</h1>
        <p v-if="chosenSet.description" style="white-space: pre-wrap;" v-html="renderMarkdown(chosenSet.description)"></p>
        
        <!-- é¢˜åº“ç»Ÿè®¡ä¿¡æ¯ -->
        <div class="set-stats">
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="stats-value">{{ setStats.completedQuestions }}/{{ setStats.totalQuestions }}</div>
                    <div class="stats-label">å·²ç»ƒä¹ é¢˜æ•°</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value">{{ setStats.averageAccuracy }}%</div>
                    <div class="stats-label">å¹³å‡æ­£ç¡®ç‡</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value">{{ setStats.todayDistinctQuestions }}</div>
                    <div class="stats-label">ä»Šæ—¥ç»ƒä¹ é¢˜æ•°</div>
                    <div class="stats-sublabel">æ­£ç¡®: {{ setStats.todayCorrect }}</div>
                </div>
            </div>
            <div class="stats-details">
                <div class="stats-row">
                    <span class="stats-label">æ€»ç»ƒä¹ æ¬¡æ•°ï¼š</span>
                    <span class="stats-value">{{ setStats.totalAttempts }}æ¬¡</span>
                </div>
                <div class="stats-row">
                    <span class="stats-label">ä¸åŒé¢˜ç›®æ•°ï¼š</span>
                    <span class="stats-value">{{ setStats.distinctQuestionCount }}é¢˜</span>
                </div>
                <div class="stats-row">
                    <span class="stats-label">æ€»æ­£ç¡®æ¬¡æ•°ï¼š</span>
                    <span class="stats-value">{{ setStats.totalCorrect }}æ¬¡</span>
                </div>
                <div class="stats-row">
                    <span class="stats-label">æ€»é”™è¯¯æ¬¡æ•°ï¼š</span>
                    <span class="stats-value">{{ setStats.totalIncorrect }}æ¬¡</span>
                </div>
                <div class="stats-row">
                    <span class="stats-label">å®Œæˆç‡ï¼š</span>
                    <span class="stats-value">{{ setStats.completionRate }}%</span>
                </div>
            </div>
        </div>

        <!-- å½“å‰é¢˜ç›®ç»Ÿè®¡ -->
        <div v-if="currentQuestion && !isPreviewMode" class="question-stats">
            <h4>å½“å‰é¢˜ç›®ç»Ÿè®¡</h4>
            <div class="stats-details">
                <div class="stats-row" v-if="questionStats">
                    <span class="stats-label">ç»ƒä¹ æ¬¡æ•°ï¼š</span>
                    <span class="stats-value">{{ questionStats.totalAttempts }}æ¬¡</span>
                </div>
                <div class="stats-row" v-if="questionStats">
                    <span class="stats-label">æ­£ç¡®æ¬¡æ•°ï¼š</span>
                    <span class="stats-value">{{ questionStats.correctCount }}æ¬¡</span>
                </div>
                <div class="stats-row" v-if="questionStats">
                    <span class="stats-label">é”™è¯¯æ¬¡æ•°ï¼š</span>
                    <span class="stats-value">{{ questionStats.incorrectCount }}æ¬¡</span>
                </div>
                <div class="stats-row" v-if="questionStats">
                    <span class="stats-label">è¿ç»­æ­£ç¡®ï¼š</span>
                    <span class="stats-value">{{ questionStats.consecutiveCorrect }}æ¬¡</span>
                </div>
                <div class="stats-row" v-if="questionStats && questionStats.lastAttemptDate">
                    <span class="stats-label">ä¸Šæ¬¡ç»ƒä¹ ï¼š</span>
                    <span class="stats-value">{{ formatDate(questionStats.lastAttemptDate) }}</span>
                    <span :class="['status-indicator', questionStats.lastCorrect ? 'correct' : 'incorrect']">
                        {{ questionStats.lastCorrect ? 'æ­£ç¡®' : 'é”™è¯¯' }}
                    </span>
                </div>
            </div>
        </div>

        <div style="margin-top: 20px;">
            <button type="button" class="btn" @click="enterQuizMode">é¡ºåºç­”é¢˜</button>
            <button type="button" class="btn" @click="enterOrderQuizMode" style="margin-left: 10px;">
                æŒ‰é”™è¯¯ç‡ç­”é¢˜
            </button>
            <button type="button" class="btn" @click="enterRandomQuizMode" style="margin-left: 10px;">
                éšæœºç­”é¢˜
            </button>
            <button type="button" class="btn" @click="enterPreviewMode" style="margin-left: 10px;">
                é¢„è§ˆæ¨¡å¼
            </button>
        </div>
    </div>

    <!-- é¢˜ç›®é¡µé¢ -->
    <div v-else-if="pageState === 'quiz' || pageState === 'orderQuiz' || pageState === 'randomQuiz'" class="card">
        <div class="question-header">
            <div class="header-row">
                <button class="back-button" @click="goBack">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 12H5M12 19l-7-7 7-7"/>
                    </svg>
                    è¿”å›
                </button>
                <h1 class="title">
                    ç¬¬ {{ currentIndex + 1 }} / {{ quizList.length }} é¢˜
                    <span style="font-size: 14px; color:#888">
                        [ {{ currentQuestion.type }} ]
                    </span>
                    <span v-if="isPreviewMode" class="preview-mode">
                        [é¢„è§ˆæ¨¡å¼]
                    </span>
                </h1>
            </div>
            <div class="header-row">
                <div class="question-id">
                    é¢˜ç›® ID: {{ currentQuestion.uniqueId }}
                    <span v-if="!isPreviewMode" class="progress-text">{{ progressText }}</span>
                </div>
                <div class="action-buttons">
                    <span class="action-button" @click="editQuestion" v-if="!isEditing">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                        </svg>
                        ç¼–è¾‘{{ modifiedCount ? ` (${modifiedCount})` : '' }}
                    </span>
                    <span class="action-button" @click="exitEditMode" v-if="isEditing">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M5 13l4 4L19 7"></path>
                        </svg>
                        å®Œæˆ
                    </span>
                    <span class="action-button" @click="exportModifiedData" v-if="showExportButton">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="7 10 12 15 17 10"></polyline>
                            <line x1="12" y1="15" x2="12" y2="3"></line>
                        </svg>
                        å¯¼å‡ºé¢˜åº“
                    </span>
                </div>
            </div>
        </div>

        <!-- é¢˜ç›®å†…å®¹ -->
        <div 
            v-if="!isEditing || editingField !== 'content'"
            @click="isEditing && !isPreviewMode ? enterEditMode('content', currentQuestion.content) : null"
            class="question-content"
            :class="{ 'editable': !isPreviewMode && isEditing }"
            v-html="renderedContent"
        ></div>
        <textarea
            v-else-if="editingField === 'content'"
            v-model="editingContent"
            @blur="exitEditMode"
            class="edit-textarea"
            rows="8"
        ></textarea>

        <!-- é€‰é¡¹ -->
        <div v-if="currentQuestion.type === 'single-choice' || currentQuestion.type === 'multiple-choice'">
            <label
                v-for="(opt, idx) in currentQuestion.options"
                :key="idx"
                class="option-item"
                :class="{
                    'green': showAnswer && (currentQuestion.type === 'single-choice' ? isCorrectOptionSingle(opt) : isCorrectOptionMulti(opt)),
                    'red': showAnswer && (currentQuestion.type === 'single-choice' ? 
                        (isChosenOptionSingle(opt) && !isCorrectOptionSingle(opt)) : 
                        (chosenAnswers.includes(opt) && !isCorrectOptionMulti(opt))),
                    'editable': !isPreviewMode
                }"
            >
                <input
                    :type="currentQuestion.type === 'single-choice' ? 'radio' : 'checkbox'"
                    :name="currentQuestion.type === 'single-choice' ? 'single-choice-' + currentQuestion.uniqueId : ''"
                    :value="opt"
                    :checked="currentQuestion.type === 'single-choice' ? chosenAnswer === opt : chosenAnswers.includes(opt)"
                    @change="handleOptionChange(opt, currentQuestion.type === 'single-choice')"
                    :disabled="showAnswer || isEditing || isPreviewMode"
                    style="margin-right: 6px;"
                >
                <div class="option-content" v-if="!isEditing || editingField !== `option-${idx}`">
                    <strong>{{ letterMap[idx] }}. </strong>
                    <span 
                        v-html="renderMarkdownWithLatex(opt)"
                        @click="isEditing && !isPreviewMode ? enterEditMode(`option-${idx}`, opt) : null"
                    ></span>
                </div>
                <div v-else class="option-edit">
                    <strong>{{ letterMap[idx] }}. </strong>
                    <input
                        type="text"
                        v-model="editingContent"
                        @blur="exitEditMode"
                        class="edit-input"
                    >
                </div>
            </label>
        </div>

        <div v-else-if="currentQuestion.type === 'short-answer'">
            <!-- ç®€ç­”é¢˜ -->
            <textarea
                v-model="shortAnswerText"
                :disabled="showAnswer"
                rows="4"
                style="width: 100%; padding: 8px;"
                placeholder="è¯·è¾“å…¥ä½ çš„ç­”æ¡ˆ"
            ></textarea>
        </div>

        <div v-else-if="currentQuestion.type === 'fill-in-blank'">
            <!-- å¡«ç©ºé¢˜ -->
            <div v-for="(blank, idx) in currentQuestion.blanks" :key="idx" class="fill-blank-item">
                <label :for="'blank-'+idx">ç©º{{idx + 1}}ï¼š</label>
                <input
                    :id="'blank-'+idx"
                    type="text"
                    v-model="fillInAnswers[idx]"
                    :disabled="showAnswer"
                    style="width: 200px; padding: 4px 8px; margin: 4px 0;"
                    :placeholder="'è¯·å¡«å†™ç©º'+(idx+1)"
                >
                <span v-if="showAnswer" style="margin-left: 10px; color: #666;">
                    æ­£ç¡®ç­”æ¡ˆï¼š{{ currentQuestion.correct_answer[idx] }}
                </span>
            </div>
        </div>

        <!-- æäº¤ç­”æ¡ˆ / ä¸‹ä¸€é¢˜ æŒ‰é’® -->
        <div style="margin-top: 12px;">
            <button
                type="button"
                v-if="!showAnswer"
                class="btn"
                @click="submitAnswer"
            >
                æäº¤ç­”æ¡ˆ (ç©ºæ ¼)
            </button>
            <button
                type="button"
                v-else
                class="btn"
                @click="nextQuestion"
            >
                ä¸‹ä¸€é¢˜ (ç©ºæ ¼)
            </button>
        </div>

        <!-- è§£æ -->
        <div v-if="showAnswer" class="analysis">
            <h3>è§£æ</h3>
            <div 
                v-if="(!isEditing || editingField !== 'analysis') && currentQuestion.analysis"
                @click="isEditing && !isPreviewMode ? enterEditMode('analysis', currentQuestion.analysis) : null"
                v-html="renderedAnalysis"
                :class="{ 'editable': isEditing && !isPreviewMode }"
            ></div>
            <div 
                v-if="(!isEditing || editingField !== 'analysis') && !currentQuestion.analysis"
                @click="isEditing && !isPreviewMode ? enterEditMode('analysis', '') : null"
                class="empty-analysis"
                :class="{ 'editable': isEditing && !isPreviewMode }"
            >
                ç‚¹å‡»æ·»åŠ è§£æ
            </div>
            <textarea
                v-else-if="editingField === 'analysis'"
                v-model="editingContent"
                @blur="exitEditMode"
                class="edit-textarea"
                rows="6"
                placeholder="è¯·è¾“å…¥è§£æå†…å®¹..."
            ></textarea>
        </div>

        <p style="font-size:13px; color:#666; margin-top:8px;">
            é”®ç›˜ï¼š1~4 é€‰é¡¹ï¼Œç©ºæ ¼æäº¤/ä¸‹ä¸€é¢˜ï¼ŒShift+Cåˆ‡æ¢è§£æ
        </p>
    </div>

    <!-- 5) result: æœ€ç»ˆç»“æœ -->
    <div v-else-if="pageState === 'result'" class="card">
        <h1 class="title">ç­”é¢˜å®Œæˆ</h1>
        <p>æœ¬è½®å…± {{ quizList.length }} é¢˜ï¼Œå·²å®Œæˆï¼š{{ completedCount }}ã€‚</p>
        <button type="button" class="btn" @click="pageState = 'home'">
            è¿”å›é¢˜ç›®é€‰æ‹© (ç©ºæ ¼)
        </button>
    </div>

    <!-- å…¶ä»–æƒ…å†µ -->
    <div v-else class="card">
        <p>æ­£åœ¨å¤„ç†ï¼Œè¯·ç¨å...</p>
    </div>
</div>

<script type="module">
    import StorageManager from './js/modules/storage.js';
    import JsonLoader from './js/modules/jsonLoader.js';
    import KeyboardManager from './js/modules/keyboard.js';
    import QuestionManager from './js/modules/QuestionManager.js';
    import PracticeManager from './js/modules/PracticeManager.js';

    const app = Vue.createApp({
        data() {
            return {
                storageManager: null,
                jsonLoader: null,
                keyboardManager: null,
                questionManager: null,
                practiceManager: null,
                pageState: 'home',
                isLoading: false,
                loadError: null,
                fileList: [],
                chosenSet: null,
                showAnswer: false,
                isEditing: false,
                editingField: null,
                editingContent: '',
                showExportButton: false,
                chosenAnswer: '',
                chosenAnswers: [],
                shortAnswerText: '',
                fillInAnswers: [],
                currentSessionCompleted: new Set(),
                modifiedCount: 0,
                showUnsavedModal: false,
                dontShowExportReminder: false,
                groupedModifiedQuestions: {},
                lastExportTimestamp: null,
                banner: {
                    show: false,
                    content: '',
                    type: 'info',
                    closeable: true
                }
            }
        },
        async created() {
            this.storageManager = new StorageManager();
            this.jsonLoader = new JsonLoader();
            this.keyboardManager = new KeyboardManager(this);
            this.questionManager = new QuestionManager(this.storageManager);
            this.practiceManager = new PracticeManager(this.storageManager);
            
            // æ˜¾ç¤ºé¡¹ç›®çŠ¶æ€æ¨ªå¹…ï¼ˆä»…é¦–æ¬¡è®¿é—®ï¼‰
            if (this.pageState === 'home' && !this.storageManager.getBannerShown()) {
                this.showBanner(
                    'ğŸš§ **é¡¹ç›®è°ƒè¯•ä¸­** ğŸš§\n\n' +
                    'ç›®å‰é¡¹ç›®å¤„äºè°ƒè¯•é˜¶æ®µï¼Œæ¬¢è¿å‚ä¸å¼€å‘å’Œåé¦ˆã€‚\n' +
                    'ä½ å¯ä»¥å‚è€ƒ [demo.json](https://github.com/wzj042/quiz-app/blob/main/assets/demo.json) çš„æ ¼å¼ï¼Œ' +
                    'Fork é¡¹ç›®åæ·»åŠ è‡ªå·±çš„é¢˜åº“ã€‚',
                    'info',
                    true
                );
                this.storageManager.setBannerShown(true);
            }

            // åŠ è½½é¢˜åº“åˆ—è¡¨
            await this.loadBankList();

            // æ·»åŠ é¡µé¢å…³é—­å‰çš„æç¤º
            window.addEventListener('beforeunload', (e) => {
                if (this.isEditing && this.questionManager.checkUnsavedChanges()) {
                    e.preventDefault();
                    e.returnValue = 'æœ‰æœªä¿å­˜çš„ä¿®æ”¹ï¼Œç¡®å®šè¦ç¦»å¼€å—ï¼Ÿ';
                    return e.returnValue;
                }
            });
        },
        beforeUnmount() {
            this.keyboardManager.destroy();
            // ç§»é™¤é¡µé¢å…³é—­å‰çš„æç¤º
            window.removeEventListener('beforeunload', this.handleBeforeUnload);
        },
        computed: {
            currentQuestion() {
                return this.practiceManager?.getCurrentQuestion() || null;
            },
            currentIndex() {
                return this.practiceManager?.currentIndex || 0;
            },
            quizList() {
                return this.practiceManager?.questions || [];
            },
            isPreviewMode() {
                return this.practiceManager?.isPreviewMode || false;
            },
            totalStats() {
                return this.storageManager.getAllBanksStats();
            },
            setStats() {
                if (!this.chosenSet) return null;
                const stats = this.storageManager.getSetStats(this.chosenSet.id, this.jsonLoader.questions);
                const today = new Date().toISOString().split('T')[0];
                
                // è·å–ä»Šæ—¥ç»ƒä¹ é¢˜æ•°
                const todayCount = this.jsonLoader.questions.reduce((count, q) => {
                    const completion = this.storageManager.getQuestionCompletion(this.chosenSet.id, q.uniqueId);
                    if (completion && completion.lastAttemptDate === today) {
                        return count + 1;
                    }
                    return count;
                }, 0);

                return {
                    ...stats,
                    todayCount,
                    accuracy: stats.totalAttempts > 0 
                        ? Math.round((stats.totalAttempts - stats.totalErrors) / stats.totalAttempts * 100) 
                        : 0
                };
            },
            renderedContent() {
                if (!this.currentQuestion.content) return '';
                return this.renderMarkdownWithLatex(this.currentQuestion.content);
            },
            renderedAnalysis() {
                if (!this.currentQuestion.analysis) return '';
                return this.renderMarkdownWithLatex(this.currentQuestion.analysis);
            },
            progressText() {
                return `æœ¬æ¬¡ç»ƒä¹ å®Œæˆåº¦ï¼š${this.currentSessionCompleted.size}/${this.quizList.length}`;
            },
            completedCount() {
                return this.currentSessionCompleted.size;
            },
            letterMap() {
                return ['A','B','C','D','E','F'];
            },
            hoverTitle() {
                return false;
            },
            hasChanges() {
                return false;
            },
            changesExported() {
                return false;
            },
            questionStats() {
                if (!this.chosenSet || !this.currentQuestion) return null;
                return this.storageManager.getQuestionStats(
                    this.chosenSet.id,
                    this.currentQuestion.uniqueId
                );
            }
        },
        watch: {
            chosenAnswer: {
                handler(newVal, oldVal) {
                    console.log('chosenAnswer changed:', {
                        newValue: newVal,
                        oldValue: oldVal,
                        questionId: this.currentQuestion?.uniqueId,
                        timestamp: new Date().toISOString()
                    });
                },
                immediate: true
            }
        },
        methods: {
            // åŠ è½½é¢˜åº“åˆ—è¡¨
            async loadBankList() {
                this.isLoading = true;
                this.loadError = null;
                try {
                    const response = await fetch('assets/list.json');
                    if (!response.ok) throw new Error('Failed to load bank list');
                    this.fileList = await response.json();
                } catch (error) {
                    this.loadError = error.message;
                    console.error('åŠ è½½é¢˜åº“åˆ—è¡¨å¤±è´¥:', error);
                } finally {
                    this.isLoading = false;
                }
            },

            // åŠ è½½é¢˜åº“æ–‡ä»¶
            async loadJsonFile(fileName) {
                if (this.isLoading) return;
                this.isLoading = true;
                try {
                    const data = await this.jsonLoader.loadFile(fileName);
                    this.chosenSet = data.sets[0];
                    this.updatePageState('setDescription');
                } catch (error) {
                    console.error('åŠ è½½é¢˜åº“å¤±è´¥:', error);
                    alert('åŠ è½½é¢˜åº“å¤±è´¥: ' + error.message);
                } finally {
                    this.isLoading = false;
                }
            },

            // è¿›å…¥ç»ƒä¹ æ¨¡å¼
            enterQuizMode() {
                this.practiceManager.initPractice(this.jsonLoader.questions, 'sequence');
                this.practiceManager.togglePreviewMode(false);
                this.showAnswer = false;
                this.currentSessionCompleted.clear();
                this.updatePageState('quiz');
            },

            enterOrderQuizMode() {
                this.practiceManager.initPractice(this.jsonLoader.questions, 'error-rate');
                this.practiceManager.togglePreviewMode(false);
                this.showAnswer = false;
                this.currentSessionCompleted.clear();
                this.updatePageState('orderQuiz');
            },

            enterRandomQuizMode() {
                this.practiceManager.initPractice(this.jsonLoader.questions, 'random');
                this.practiceManager.togglePreviewMode(false);
                this.showAnswer = false;
                this.currentSessionCompleted.clear();
                this.updatePageState('randomQuiz');
            },

            enterPreviewMode() {
                this.practiceManager.initPractice(this.jsonLoader.questions, 'sequence');
                this.practiceManager.togglePreviewMode(true);
                this.showAnswer = true;
                this.updatePageState('quiz');
            },

            // ç¼–è¾‘ç›¸å…³æ–¹æ³•
            editQuestion() {
                if (this.isPreviewMode) return;
                console.log('Starting edit mode for question:', this.currentQuestion);
                this.questionManager.startEditing(this.currentQuestion);
                this.isEditing = true;
                this.showExportButton = true;
                // è‡ªåŠ¨åˆ‡æ¢åˆ°è§£ææ¨¡å¼
                this.showAnswer = true;
            },

            enterEditMode(field, content) {
                if (this.isPreviewMode) return;
                console.log('Entering edit mode:', {
                    field,
                    content,
                    currentContent: content || 'ç‚¹å‡»ç¼–è¾‘'
                });
                this.editingField = field;
                this.editingContent = content || '';
            },

            exitEditMode() {
                console.log('Exiting edit mode:', {
                    field: this.editingField,
                    content: this.editingContent,
                    question: this.currentQuestion
                });
                
                if (this.editingField && this.editingContent !== undefined) {
                    const question = this.currentQuestion;
                    if (this.editingField === 'content') {
                        question.content = this.editingContent;
                    } else if (this.editingField === 'analysis') {
                        question.analysis = this.editingContent;
                    } else if (this.editingField.startsWith('option-')) {
                        const idx = parseInt(this.editingField.split('-')[1]);
                        question.options[idx] = this.editingContent;
                    }
                    this.questionManager.saveCurrentEdit();
                    // æ›´æ–°ä¿®æ”¹è®¡æ•°
                    this.modifiedCount = this.questionManager.getModifiedQuestions().length;
                }
                this.editingField = null;
                this.editingContent = '';
                this.isEditing = false;
                this.showAnswer = false; // é€€å‡ºè§£ææ¨¡å¼
            },

            // å¯¼å‡ºç›¸å…³æ–¹æ³•
            handleExport(questions) {
                const exportData = {
                    questions: questions,
                    sets: [this.chosenSet]
                };

                const blob = new Blob([JSON.stringify(exportData, null, 4)], 
                    { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                // ä»fileListä¸­è·å–å½“å‰é¢˜åº“çš„æ–‡ä»¶å
                const currentFile = this.fileList.find(f => f.name === this.chosenSet.name)?.file;
                a.download = this.questionManager.generateExportFileName(currentFile || 'export');
                a.click();
                URL.revokeObjectURL(url);

                // æ›´æ–°å¯¼å‡ºçŠ¶æ€
                this.lastExportTimestamp = Date.now();
                this.modifiedCount = 0;
                this.questionManager.clearModifiedQuestions();
                this.showExportButton = false;
                this.isEditing = false;
                this.showUnsavedModal = false;
            },

            // å¯¼å‡ºä¿®æ”¹
            exportModifiedData() {
                const modifiedQuestions = this.questionManager.getModifiedQuestions();
                const questions = this.jsonLoader.questions.map(q => {
                    if (modifiedQuestions.includes(q.uniqueId)) {
                        return { ...q };
                    }
                    return q;
                });
                this.handleExport(questions);
            },

            // çŠ¶æ€æ›´æ–°
            updatePageState(newState) {
                // å¦‚æœæœ‰æœªå¯¼å‡ºçš„ä¿®æ”¹ï¼Œä¸”ä¸æ˜¯åˆšåˆšå¯¼å‡ºçš„ï¼Œä¸”ä¸æ˜¯åœ¨ç¼–è¾‘æ¨¡å¼ä¸­
                if (this.modifiedCount > 0 && !this.dontShowExportReminder && 
                    (!this.lastExportTimestamp || Date.now() - this.lastExportTimestamp > 1000) &&
                    !this.isEditing) {
                    const hasUnsaved = this.checkModifiedQuestions();
                    if (hasUnsaved) {
                        return;
                    }
                }
                
                if (this.isEditing && this.questionManager.checkUnsavedChanges()) {
                    if (!confirm('æœ‰æœªä¿å­˜çš„ä¿®æ”¹ï¼Œç¡®å®šè¦ç¦»å¼€å—ï¼Ÿ')) {
                        return;
                    }
                    this.questionManager.cancelEditing();
                    this.isEditing = false;
                    this.showExportButton = false;
                }
                
                this.pageState = newState;
                if (newState === 'home') {
                    this.questionManager.clearEditHistory();
                    this.showExportButton = false;
                }
            },

            goBack() {
                if (this.isEditing) {
                    if (this.questionManager.checkUnsavedChanges()) {
                        if (confirm('æœ‰æœªä¿å­˜çš„ä¿®æ”¹ï¼Œç¡®å®šè¦æ”¾å¼ƒå—ï¼Ÿ')) {
                            this.questionManager.cancelEditing();
                            this.isEditing = false;
                            this.showExportButton = false;
                            this.showAnswer = false; // é€€å‡ºè§£ææ¨¡å¼
                        } else {
                            return;
                        }
                    } else {
                        this.questionManager.cancelEditing();
                        this.isEditing = false;
                        this.showExportButton = false;
                        this.showAnswer = false; // é€€å‡ºè§£ææ¨¡å¼
                    }
                }
                this.updatePageState('setDescription');
            },

            goHome() {
                this.updatePageState('home');
            },

            getBankStats(fileName) {
                try {
                    const bankData = this.storageManager.getBankStats(fileName);
                    if (!bankData) return null;
                    
                    return {
                        completed: bankData.completed,
                        total: bankData.total,
                        accuracy: bankData.attempts > 0 
                            ? Math.round((bankData.attempts - bankData.errors) / bankData.attempts * 100)
                            : 0
                    };
                } catch (e) {
                    console.error('è·å–é¢˜åº“ç»Ÿè®¡å¤±è´¥:', e);
                    return null;
                }
            },

            renderMarkdown(text) {
                if (!text) return '';
                return marked.parse(text);
            },

            renderMarkdownWithLatex(text) {
                if (!text) return '';
                
                // å…ˆå¤„ç†å¤šè¡Œå…¬å¼ï¼Œé¿å…è¢«markdownè§£æå™¨ç ´åæ ¼å¼
                let content = text;
                
                // ä¿å­˜å¤šè¡Œå…¬å¼
                const formulas = [];
                content = content.replace(/\$\$([\s\S]+?)\$\$/g, (match, formula) => {
                    // ä¿æŒåŸå§‹æ¢è¡Œï¼Œä¸è¿›è¡Œä»»ä½•æ›¿æ¢
                    formulas.push(formula.trim());
                    return `<div class="katex-display">${katex.renderToString(formula.trim(), {
                        displayMode: true,
                        throwOnError: false,
                        strict: false,
                        trust: true,
                        output: 'html'
                    })}</div>`;
                });
                
                // å¤„ç†Markdown
                content = marked.parse(content);
                
                // å¤„ç†è¡Œå†…å…¬å¼
                content = content.replace(/\$([^$]+?)\$/g, (match, formula) => {
                    try {
                        return katex.renderToString(formula.trim(), {
                            displayMode: false,
                            throwOnError: false,
                            strict: false
                        });
                    } catch (e) {
                        console.error('LaTeX rendering error:', e);
                        console.error('Formula:', formula);
                        return match;
                    }
                });
                
                return content;
            },

            handleOptionChange(option, isSingleChoice) {
                console.log('Option change handler:', {
                    option,
                    isSingleChoice,
                    currentValue: isSingleChoice ? this.chosenAnswer : this.chosenAnswers
                });

                if (isSingleChoice) {
                    this.chosenAnswer = option;
                } else {
                    const index = this.chosenAnswers.indexOf(option);
                    if (index === -1) {
                        this.chosenAnswers.push(option);
                    } else {
                        this.chosenAnswers.splice(index, 1);
                    }
                }

                console.log('After option change:', {
                    chosenAnswer: this.chosenAnswer,
                    chosenAnswers: this.chosenAnswers
                });
            },

            isChosenOptionSingle(opt) {
                console.log('Checking single option selection:', {
                    option: opt,
                    optionType: typeof opt,
                    chosenAnswer: this.chosenAnswer,
                    chosenAnswerType: typeof this.chosenAnswer,
                    isChosen: String(this.chosenAnswer) === String(opt)
                });
                return String(this.chosenAnswer) === String(opt);
            },

            isCorrectOptionMulti(opt) {
                const ans = this.currentQuestion?.correct_answer || [];
                const isCorrect = ans.some(a => String(a) === String(opt));
                console.log('Checking multi option correctness:', {
                    option: opt,
                    correctAnswers: ans,
                    isCorrect: isCorrect
                });
                return isCorrect;
            },

            isCorrectOptionSingle(opt) {
                const ans = this.currentQuestion?.correct_answer || [];
                const isCorrect = ans.length > 0 && String(ans[0]) === String(opt);
                console.log('Checking single option correctness:', {
                    option: opt,
                    optionType: typeof opt,
                    correctAnswer: ans[0],
                    correctAnswerType: ans.length > 0 ? typeof ans[0] : 'undefined',
                    isCorrect: isCorrect
                });
                return isCorrect;
            },

            submitAnswer() {
                const q = this.currentQuestion;
                console.log('Submitting answer:', {
                    questionType: q.type,
                    questionId: q.uniqueId,
                    chosenAnswer: this.chosenAnswer,
                    chosenAnswers: this.chosenAnswers,
                    correctAnswer: q.correct_answer
                });

                if (!q.uniqueId) return;

                // åœ¨é¢„è§ˆæ¨¡å¼ä¸‹ï¼Œç›´æ¥æ˜¾ç¤ºç­”æ¡ˆï¼Œä¸è¿›è¡ŒéªŒè¯å’Œè®°å½•
                if (this.isPreviewMode) {
                    this.showAnswer = true;
                    return;
                }

                // æœªé€‰æ‹©/æœªå¡«å†™æ—¶æç¤º
                if (q.type === 'single-choice' && !this.chosenAnswer) {
                    console.log('No answer chosen for single choice question');
                    alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªé€‰é¡¹');
                    return;
                }
                if (q.type === 'multiple-choice' && !this.chosenAnswers.length) {
                    alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªé€‰é¡¹');
                    return;
                }
                if (q.type === 'short-answer' && !this.shortAnswerText.trim()) {
                    alert('è¯·å…ˆå¡«å†™ä½ çš„ç­”æ¡ˆ');
                    return;
                }
                if (q.type === 'fill-in-blank') {
                    if (this.fillInAnswers.some(answer => !answer?.trim())) {
                        alert('è¯·å¡«å†™æ‰€æœ‰ç©ºæ ¼');
                        return;
                    }
                }

                // åˆ¤å®šæ­£è¯¯
                let isCorrect = false;
                if (q.type === 'single-choice') {
                    const userAnswer = String(this.chosenAnswer || '');
                    const correctAnswer = String(q.correct_answer[0] || '');
                    isCorrect = userAnswer === correctAnswer;
                    console.log('Single choice answer check:', {
                        userAnswer,
                        correctAnswer,
                        isCorrect,
                        chosenAnswerType: typeof this.chosenAnswer,
                        correctAnswerType: typeof q.correct_answer[0]
                    });
                } else if (q.type === 'multiple-choice') {
                    const c1 = [...this.chosenAnswers].map(String).sort().join('||');
                    const c2 = [...q.correct_answer].map(String).sort().join('||');
                    isCorrect = (c1 === c2);
                } else if (q.type === 'short-answer') {
                    const userAns = this.shortAnswerText.trim();
                    const correctAns = (q.correct_answer[0] || '').trim();
                    isCorrect = (userAns === correctAns);
                } else if (q.type === 'fill-in-blank') {
                    const userAns = this.fillInAnswers.map(a => a.trim()).join('||');
                    const correctAns = q.correct_answer.map(a => a.trim()).join('||');
                    isCorrect = (userAns === correctAns);
                }

                // æ›´æ–°å½“å‰ä¼šè¯çš„å®Œæˆè®°å½•
                if (isCorrect) {
                    this.currentSessionCompleted.add(q.uniqueId);
                }

                // æ›´æ–°å®ŒæˆçŠ¶æ€ï¼ˆéé¢„è§ˆæ¨¡å¼ï¼‰
                this.storageManager.updateQuestionCompletion(this.chosenSet.id, q.uniqueId, isCorrect);
                this.showAnswer = true;
            },

            nextQuestion() {
                // åœ¨é¢„è§ˆæ¨¡å¼ä¸‹ï¼Œä¸æ›´æ–°ç­”é¢˜è®°å½•
                if (this.currentIndex < this.quizList.length - 1) {
                    this.practiceManager.nextQuestion();
                    // é‡ç½®ç­”æ¡ˆçŠ¶æ€
                    this.chosenAnswer = '';
                    this.chosenAnswers = [];
                    this.shortAnswerText = '';
                    this.fillInAnswers = [];
                    this.showAnswer = false;
                    console.log('Reset answer state:', {
                        chosenAnswer: this.chosenAnswer,
                        chosenAnswers: this.chosenAnswers
                    });
                } else if (!this.isPreviewMode) {
                    this.updatePageState('result');
                }
            },
            formatDate(isoDate) {
                if (!isoDate) return '';
                const date = new Date(isoDate);
                const today = new Date();
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);

                if (isoDate.startsWith(today.toISOString().split('T')[0])) {
                    return 'ä»Šå¤© ' + date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                } else if (isoDate.startsWith(yesterday.toISOString().split('T')[0])) {
                    return 'æ˜¨å¤© ' + date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                } else {
                    return date.toLocaleDateString('zh-CN') + ' ' + 
                           date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                }
            },
            closeUnsavedModal() {
                this.showUnsavedModal = false;
            },
            truncateText(text, length) {
                if (!text) return '';
                text = text.replace(/<[^>]*>/g, ''); // ç§»é™¤HTMLæ ‡ç­¾
                return text.length > length ? text.slice(0, length) + '...' : text;
            },
            getSetName(setId) {
                return this.jsonLoader.sets.find(s => s.id === setId)?.name || setId;
            },
            checkModifiedQuestions() {
                const modifiedQuestions = this.questionManager.getModifiedQuestions();
                if (modifiedQuestions.length > 0 && !this.dontShowExportReminder) {
                    // åªæ˜¾ç¤ºå½“å‰é¢˜åº“çš„ä¿®æ”¹é¢˜ç›®
                    this.groupedModifiedQuestions = this.jsonLoader.questions
                        .filter(q => modifiedQuestions.includes(q.uniqueId));
                    
                    this.showUnsavedModal = true;
                    return true;
                }
                return false;
            },
            showBanner(content, type = 'info', closeable = true) {
                this.banner = {
                    show: true,
                    content,
                    type,
                    closeable
                };
            },
            closeBanner() {
                this.banner.show = false;
            }
        }
    });

    app.mount('#app');
</script>

<style>
.fill-blank-item {
    margin: 10px 0;
}
.question-content, .option-content, .analysis {
    cursor: pointer;
}
.question-content:hover, .option-content:hover, .analysis:hover {
    background-color: rgba(0, 0, 0, 0.05);
}
.edit-textarea {
    width: 100%;
    padding: 8px;
    font-family: monospace;
    border: 1px solid #ddd;
    border-radius: 4px;
}
.edit-input {
    width: calc(100% - 30px);
    padding: 4px 8px;
    font-family: monospace;
    border: 1px solid #ddd;
    border-radius: 4px;
}
.option-edit {
    display: flex;
    align-items: center;
    width: 100%;
}
.action-button {
    display: inline-flex;
    align-items: center;
    padding: 4px 8px;
    border-radius: 4px;
    background: #f5f5f5;
    border: 1px solid #ddd;
    cursor: pointer;
    font-size: 14px;
    color: #666;
    margin-left: 8px;
}
.action-button:hover {
    background: #e8e8e8;
}
.action-button svg {
    width: 16px;
    height: 16px;
    margin-right: 4px;
}
.preview-mode {
    color: #B0C1A2;
    font-weight: bold;
}
.header-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}
.back-button {
    display: inline-flex;
    align-items: center;
    padding: 4px 8px;
    border-radius: 4px;
    background: #f5f5f5;
    border: 1px solid #ddd;
    cursor: pointer;
    font-size: 14px;
    color: #666;
    margin-right: 12px;
}
.back-button:hover {
    background: #e8e8e8;
}
.back-button svg {
    width: 16px;
    height: 16px;
    margin-right: 4px;
}
.progress-text {
    margin-left: 16px;
    color: #666;
    font-size: 14px;
}
.action-buttons {
    display: flex;
    gap: 8px;
}
.question-header {
    margin-bottom: 16px;
}
.editable {
    cursor: pointer;
}
.editable:hover {
    background-color: rgba(0, 0, 0, 0.05);
}
.stats-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
    margin: 15px 0;
}

.stats-item {
    text-align: center;
    padding: 15px;
    background: #f5f5f5;
    border-radius: 8px;
}

.stats-value {
    font-size: 24px;
    font-weight: bold;
    color: #B0C1A2;
}

.stats-label {
    font-size: 14px;
    color: #666;
    margin-top: 5px;
}

.stats-title {
    font-size: 18px;
    font-weight: bold;
    margin: 20px 0 10px;
}

.overall-stats {
    margin-bottom: 20px;
    padding: 15px;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.quiz-item-content {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.quiz-item-title {
    font-weight: bold;
}

.quiz-item-stats {
    font-size: 13px;
    color: #666;
}

.quiz-stat {
    margin-top: 2px;
}

.stats-details {
    font-size: 14px;
    color: #666;
    margin-top: 10px;
    padding: 10px;
    background: #f9f9f9;
    border-radius: 6px;
}

.set-stats {
    margin: 20px 0;
    padding: 15px;
    background: #f5f5f5;
    border-radius: 8px;
}

.empty-analysis {
    padding: 15px;
    border: 2px dashed #ddd;
    border-radius: 4px;
    color: #999;
    text-align: center;
    margin: 10px 0;
    font-size: 14px;
}

.empty-analysis.editable:hover {
    background-color: rgba(33, 150, 243, 0.05);
    border-color: #B0C1A2;
    color: #B0C1A2;
    cursor: pointer;
}

.stats-sublabel {
    font-size: 12px;
    color: #666;
    margin-top: 2px;
}

.stats-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
}

.question-stats {
    margin: 15px 0;
    padding: 15px;
    background: #f5f5f5;
    border-radius: 8px;
}

.question-stats h4 {
    margin: 0 0 10px 0;
    color: #333;
}

.status-indicator {
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 12px;
    margin-left: 8px;
}

.status-indicator.correct {
    background-color: #4caf50;
    color: white;
}

.status-indicator.incorrect {
    background-color: #f44336;
    color: white;
}

.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.modal-content {
    background: white;
    padding: 20px;
    border-radius: 8px;
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
}

.modal-content h3 {
    margin-top: 0;
    color: #333;
    border-bottom: 1px solid #eee;
    padding-bottom: 10px;
}

.modified-questions-list {
    margin: 15px 0;
}

.modified-set {
    margin-bottom: 20px;
    padding: 15px;
    background: #f5f5f5;
    border-radius: 6px;
}

.modified-set h4 {
    margin: 0 0 10px 0;
    color: #B0C1A2;
}

.modified-set ul {
    list-style: none;
    padding: 0;
    margin: 0 0 15px 0;
}

.modified-set li {
    padding: 8px;
    margin: 5px 0;
    background: white;
    border-radius: 4px;
    font-size: 14px;
}

.question-preview {
    color: #666;
    font-size: 13px;
}

.modal-actions {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid #eee;
}

.export-btn {
    font-size: 14px;
    padding: 6px 12px;
    margin-top: 10px;
}

.dont-show-again {
    margin-left: 20px;
    font-size: 14px;
    color: #666;
    display: flex;
    align-items: center;
    gap: 5px;
}

.btn.primary {
    background-color: #B0C1A2;
    color: white;
}

.btn.primary:hover {
    background-color: #1976d2;
}

.banner {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    padding: 10px;
    background-color: #B0C1A2;
    color: white;
    display: flex;
    justify-content: space-between;
    align-items: center;
    z-index: 1000;
}

.banner-content {
    flex: 1;
}

.banner-close {
    background: none;
    border: none;
    color: white;
    font-size: 16px;
    cursor: pointer;
}
</style>
</body>
</html>