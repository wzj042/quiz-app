<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <title>刷题</title>
    <meta name="referrer" content="no-referrer">
    <link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/katex.min.css">
    <script defer src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/katex.min.js"></script>
    <script defer src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/contrib/auto-render.min.js"></script>
    <script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vue/3.2.23/vue.global.prod.min.js"></script>
    <script src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/marked/4.0.2/marked.min.js"></script>
    <link rel="stylesheet" href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/mobile.css?v=_timestamp_">
    <link rel="icon" href="favicon.ico?v=_timestamp_" type="image/x-icon">
    <script>
        // 动态加载 JS 模块，使用时间戳防止缓存
        window.addEventListener('DOMContentLoaded', function() {
            const timestamp = Date.now();  // 使用时间戳确保每次加载最新资源
            const modules = [
                'js/modules/DataManager.js',
                'js/modules/jsonLoader.js',
                'js/modules/keyboard.js',
                'js/modules/PracticeManager.js',
                'js/modules/ProgressManager.js',
                'js/modules/QuestionManager.js',
                'js/modules/storage.js'
            ];
            
            // 更新 CSS 和 favicon 的时间戳
            document.querySelector('link[href*="mobile.css"]').href = `css/mobile.css?v=${timestamp}`;
            document.querySelector('link[rel="icon"]').href = `favicon.ico?v=${timestamp}`;
            
            // 动态加载 JS 模块
            modules.forEach(module => {
                const script = document.createElement('script');
                script.type = 'module';
                script.src = `${module}?v=${timestamp}`;
                document.head.appendChild(script);
            });

            // 添加键盘快捷键支持
            const handleKeydown = (e) => {
                // 如果正在输入，不处理快捷键
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }

                // T: 打开标签筛选
                if (e.key === 't' && !e.ctrlKey && !e.altKey && !e.shiftKey) {
                    e.preventDefault();
                    const tagsButton = document.querySelector('.tags-button');
                    if (tagsButton) tagsButton.click();
                }

                // Esc: 关闭模态窗口
                if (e.key === 'Escape') {
                    const modalOverlay = document.querySelector('.modal-overlay');
                    if (modalOverlay) {
                        const closeBtn = modalOverlay.querySelector('.close-btn');
                        if (closeBtn) closeBtn.click();
                    }
                }

                // Ctrl + S: 导出修改
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    const exportBtn = document.querySelector('.export-btn');
                    if (exportBtn) exportBtn.click();
                }
            };

            document.addEventListener('keydown', handleKeydown);

            // 初始化焦点管理
            initFocusManagement();
        });

        function initFocusManagement() {
            // 模态窗口焦点管理
            const modalOverlay = document.querySelector('.modal-overlay');
            if (modalOverlay) {
                const focusableElements = modalOverlay.querySelectorAll(
                    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                );
                const firstFocusable = focusableElements[0];
                const lastFocusable = focusableElements[focusableElements.length - 1];
                // 焦点循环
                modalOverlay.addEventListener('keydown', function(e) {
                    if (e.key === 'Tab') {
                        if (e.shiftKey) {
                            if (document.activeElement === firstFocusable) {
                                e.preventDefault();
                                lastFocusable.focus();
                            }
                        } else {
                            if (document.activeElement === lastFocusable) {
                                e.preventDefault();
                                firstFocusable.focus();
                            }
                        }
                    }
                });
            }
        }
    </script>
</head>
<body>
<div id="app" class="container">
    <!-- 未保存修改的模态窗口 -->
    <div v-if="showUnsavedModal" 
         class="modal-overlay" 
         @click.self="closeUnsavedModal"
         role="dialog"
         aria-labelledby="unsaved-modal-title"
         aria-modal="true"
         @keydown.esc="closeUnsavedModal">
        <div class="modal-content" tabindex="-1">
            <h3 id="unsaved-modal-title">未导出的修改</h3>
            <div class="modal-body">
                <p>当前题库有未导出的修改：</p>
                <div class="modified-questions-list" role="list">
                    <ul>
                        <li v-for="q in groupedModifiedQuestions" 
                            :key="q.uniqueId"
                            role="listitem">
                            题目ID: {{ q.uniqueId }}
                            <br>
                            <span class="question-preview">{{ truncateText(q.content, 50) }}</span>
                        </li>
                    </ul>
                </div>
                <div class="modal-actions">
                    <div class="modal-actions">
                        <div class="action-buttons">
                            <button class="btn export-btn" 
                                    @click="exportModifiedData"
                                    data-shortcut="Ctrl+S">
                                导出修改
                            </button>
                            <button class="btn close-btn" 
                                    @click="closeUnsavedModalAndContinue"
                                    data-shortcut="Esc">
                                直接退出
                            </button>
                        </div>
                        <label class="dont-show-again">
                            <input type="checkbox" 
                                   v-model="dontShowExportReminder"
                                   @keydown.enter="$event.target.click()">
                            <span>不再提醒</span>
                        </label>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 导航栏 -->
    <nav class="nav" role="navigation">
        <a href="#" 
           class="nav-title-link" 
           @click="goHome" 
           @mouseover="hoverTitle = true" 
           @mouseout="hoverTitle = false">
            <span class="nav-title">Quiz App</span>
        </a>
        <a href="https://github.com/wzj042/quiz-app" 
           class="github-link" 
           target="_blank" 
           rel="noopener noreferrer" 
           aria-label="在 GitHub 上查看项目"
           title="项目调试中，欢迎参与开发和反馈。可参考 demo.json 格式，Fork 项目后添加自己的题库。">
            <svg class="github-icon" viewBox="0 0 16 16" width="24" height="24" aria-hidden="true">
                <path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
            </svg>
        </a>
    </nav>

    <!-- 列出题库 -->
    <div v-if="isLoading" class="card" role="status">
        <p>正在处理，请稍后...</p>
    </div>

    <template v-else>
        <div v-if="pageState === 'home'" class="card">
            <h1 class="title">
                选择题库
                <span class="update-time" v-if="updateTime">更新于: {{ formatUpdateTime(updateTime) }}</span>
            </h1>

            <!-- 总体统计 -->
            <div class="overall-stats" role="region" aria-label="总体统计">
                <h2 class="stats-title">总体统计</h2>
                <div class="stats-grid">
                    <div class="stats-item">
                        <div class="stats-value">{{ totalStats.completedQuestions }}/{{ totalStats.totalAttempts }}</div>
                        <div class="stats-label">总练习题数</div>
                    </div>
                    <div class="stats-item">
                        <div class="stats-value">{{ totalStats.averageAccuracy }}%</div>
                        <div class="stats-label">平均正确率</div>
                    </div>
                    <div class="stats-item">
                        <div class="stats-value">{{ totalStats.todayPracticed }}</div>
                        <div class="stats-label">今日已练习</div>
                    </div>
                </div>
                <button class="cross-practice-btn" @click="showCrossPracticeModal = true">
                    <i class="fas fa-random"></i>
                    跨卷练习设置
                </button>
            </div>

            <!-- 题库列表 -->
            <template v-if="fileList.length > 0">
                <ul class="horizontal-list" role="list">
                    <!-- Tags筛选器 -->
                    <div class="tags-filter" role="region" aria-label="标签筛选">
                        <div class="top-tags">
                            <button v-for="tag in topTags" 
                                    :key="tag.tag"
                                    :class="['tag-chip', { active: selectedTags.includes(tag.tag) }]"
                                    @click="toggleTag(tag.tag)"
                                    :aria-pressed="selectedTags.includes(tag.tag)"
                                    :aria-label="'选择标签: ' + tag.tag">
                                {{ tag.tag }}
                                <span v-if="selectedTags.includes(tag.tag)" class="tag-count">({{ tag.count }})</span>
                            </button>
                        </div>
                        <button :class="['tags-button', { 'has-active': selectedTags.length > 0 }]" 
                                @click="showTagsModal = true"
                                aria-label="更多标签"
                                data-shortcut="T">
                            <i class="fas fa-tags" aria-hidden="true"></i>
                        </button>
                    </div>

                    <template v-for="(group, groupIndex) in filteredGroupedFileList" :key="groupIndex">
                        <li class="category-header" role="separator">
                            <h2>{{ group[0] }}</h2>
                            <hr>
                        </li>
                        <li v-for="(fileObj, idx) in group[1]"
                            :key="idx"
                            class="quiz-item"
                            role="button"
                            tabindex="0"
                            @click="loadJsonFile(fileObj.file)"
                            @keydown.enter="loadJsonFile(fileObj.file)"
                            @keydown.space.prevent="loadJsonFile(fileObj.file)">
                            <div class="quiz-item-content">
                                <div class="quiz-item-title">{{ fileObj.name }}</div>
                                <div class="quiz-item-tags" v-if="fileObj.tags && fileObj.tags.length">
                                    <span v-for="tag in fileObj.tags.slice(0, 3)" :key="tag" class="item-tag">
                                        {{ tag }}
                                    </span>
                                </div>
                                <div class="quiz-item-stats" v-if="bankStats[fileObj.file]">
                                    <div class="quiz-stat">
                                        完成：{{ bankStats[fileObj.file].completed }}/{{ bankStats[fileObj.file].total }}
                                    </div>
                                    <div class="quiz-stat">
                                        正确率：{{ bankStats[fileObj.file].accuracy }}%
                                    </div>
                                </div>
                            </div>
                        </li>
                    </template>
                </ul>
            </template>

            <!-- 如果列表为空 -->
            <template v-else>
                <div class="empty-state" role="status">
                    没有找到可用的题库
                </div>
            </template>
        </div>

        <!-- 题库详情页面 -->
        <div v-else-if="pageState === 'setDescription'" 
            class="card"
            @keydown.prevent="handleKeyNavigation"
            tabindex="-1">
            <h1 class="title">
                {{ chosenSet.name }}
                <div class="time-info" v-if="chosenSet.createTime || chosenSet.updateTime">
                    <div v-if="chosenSet.updateTime" class="update-time">
                        更新于：{{ formatDate(chosenSet.updateTime) }}
                    </div>
                    <div v-else-if="chosenSet.createTime" class="create-time">
                        创建于：{{ formatDate(chosenSet.createTime) }}
                    </div>
                </div>
            </h1>
            <p v-if="chosenSet.description" style="white-space: pre-wrap;" v-html="renderMarkdown(chosenSet.description)"></p>
            
            <!-- 题库统计信息 -->
            <div class="set-stats">
                <div class="stats-grid">
                    <div class="stats-item" tabindex="0">
                        <div class="stats-value">{{ setStats.completedQuestions }}/{{ setStats.totalQuestions }}</div>
                        <div class="stats-label">已练习题数</div>
                    </div>
                    <div class="stats-item" tabindex="0">
                        <div class="stats-value">{{ setStats.averageAccuracy }}%</div>
                        <div class="stats-label">平均正确率</div>
                    </div>
                    <div class="stats-item" tabindex="0">
                        <div class="stats-value">{{ setStats.todayDistinctQuestions }}</div>
                        <div class="stats-label">今日练习题数</div>
                        <div class="stats-sublabel">正确: {{ setStats.todayCorrect }}</div>
                    </div>
                </div>
            </div>

            <!-- 练习模式选择 -->
            <div class="mode-selection" 
                role="group" 
                aria-label="练习模式选择">
                <button 
                    class="mode-btn" 
                    @click="enterQuizMode"
                    @keydown.enter.prevent="enterQuizMode"
                    @keydown.space.prevent="enterQuizMode"
                    @keydown.left.prevent="focusPrevButton($event)"
                    @keydown.right.prevent="focusNextButton($event)"
                    @keydown.up.prevent="focusUpButton($event)"
                    @keydown.down.prevent="focusDownButton($event)"
                    tabindex="0"
                    role="button"
                    data-nav="mode-btn">
                    全部练习
                    <span class="mode-description">按顺序练习所有题目</span>
                </button>
                <button 
                    class="mode-btn" 
                    @click="enterOrderQuizMode"
                    @keydown.enter.prevent="enterOrderQuizMode"
                    @keydown.space.prevent="enterOrderQuizMode"
                    @keydown.left.prevent="focusPrevButton($event)"
                    @keydown.right.prevent="focusNextButton($event)"
                    @keydown.up.prevent="focusUpButton($event)"
                    @keydown.down.prevent="focusDownButton($event)"
                    tabindex="0"
                    role="button"
                    data-nav="mode-btn">
                    错题练习
                    <span class="mode-description">专注于之前答错的题目</span>
                </button>
                <button 
                    class="mode-btn" 
                    @click="enterRandomQuizMode"
                    @keydown.enter.prevent="enterRandomQuizMode"
                    @keydown.space.prevent="enterRandomQuizMode"
                    @keydown.left.prevent="focusPrevButton($event)"
                    @keydown.right.prevent="focusNextButton($event)"
                    @keydown.up.prevent="focusUpButton($event)"
                    @keydown.down.prevent="focusDownButton($event)"
                    tabindex="0"
                    role="button"
                    data-nav="mode-btn">
                    随机练习
                    <span class="mode-description">随机顺序练习题目</span>
                </button>
                <button 
                    class="mode-btn" 
                    @click="enterPreviewMode"
                    @keydown.enter.prevent="enterPreviewMode"
                    @keydown.space.prevent="enterPreviewMode"
                    @keydown.left.prevent="focusPrevButton($event)"
                    @keydown.right.prevent="focusNextButton($event)"
                    @keydown.up.prevent="focusUpButton($event)"
                    @keydown.down.prevent="focusDownButton($event)"
                    tabindex="0"
                    role="button"
                    data-nav="mode-btn">
                    预览模式
                    <span class="mode-description">查看所有题目和答案</span>
                </button>
            </div>
        </div>

        <!-- 题目页面 -->
        <div v-else-if="pageState === 'quiz' || pageState === 'orderQuiz' || pageState === 'randomQuiz'" class="card">
            <div class="question-header">
                <div class="header-row">
                    <div style="display: flex; align-items: center;">
                        <button class="back-button" @click="backToHome">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M19 12H5M12 19l-7-7 7-7"/>
                            </svg>
                            返回
                        </button>
                        <span class="progress-text">
                            {{ practiceManager.currentIndex + 1 }} / {{ practiceManager.questions.length }}
                            <template v-if="chosenSet.isCrossPractice && currentQuestion">
                                · 来自：{{ currentQuestion.sourceBank }}
                            </template>
                        </span>
                    </div>
                    <div class="action-buttons">
                        <button class="action-button" @click="togglePreviewMode" v-if="isAdmin">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                                <circle cx="12" cy="12" r="3"/>
                            </svg>
                            {{ isPreviewMode ? '退出预览' : '预览模式' }}
                        </button>
                        <button class="action-button" @click="editCurrentQuestion" v-if="isAdmin && !isPreviewMode">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                            </svg>
                            编辑
                        </button>
                    </div>
                </div>
            </div>

            <!-- 题目内容 -->
            <div 
                v-if="!isEditing || editingField !== 'content'"
                @click="isEditing && !isPreviewMode ? enterEditMode('content', currentQuestion.content) : null"
                class="question-content"
                :class="{ 'editable': !isPreviewMode && isEditing }"
                v-html="renderedContent"
            ></div>
            <textarea
                v-else-if="editingField === 'content'"
                v-model="editingContent"
                @blur="exitEditMode"
                class="edit-textarea"
                rows="8"
            ></textarea>

            <!-- 选项 -->
            <div v-if="currentQuestion.type === 'single-choice' || currentQuestion.type === 'multiple-choice'">
                <label
                    v-for="(opt, idx) in currentQuestion.options"
                    :key="idx"
                    class="option-item"
                    :class="{
                        'green': showAnswer && (currentQuestion.type === 'single-choice' ? isCorrectOptionSingle(opt) : isCorrectOptionMulti(opt)),
                        'red': showAnswer && (currentQuestion.type === 'single-choice' ? 
                            (isChosenOptionSingle(opt) && !isCorrectOptionSingle(opt)) : 
                            (chosenAnswers.includes(opt) && !isCorrectOptionMulti(opt))),
                        'editable': !isPreviewMode
                    }"
                >
                    <input
                        :type="currentQuestion.type === 'single-choice' ? 'radio' : 'checkbox'"
                        :name="currentQuestion.type === 'single-choice' ? 'single-choice-' + currentQuestion.uniqueId : ''"
                        :value="opt"
                        :checked="currentQuestion.type === 'single-choice' ? chosenAnswer === opt : chosenAnswers.includes(opt)"
                        @change="handleOptionChange(opt, currentQuestion.type === 'single-choice')"
                        :disabled="showAnswer || isEditing || isPreviewMode"
                        style="margin-right: 6px;"
                    >
                    <div class="option-content" v-if="!isEditing || editingField !== `option-${idx}`">
                        <strong>{{ letterMap[idx] }}. </strong>
                        <span 
                            v-html="renderMarkdownWithLatex(opt)"
                            @click="isEditing && !isPreviewMode ? enterEditMode(`option-${idx}`, opt) : null"
                        ></span>
                    </div>
                    <div v-else class="option-edit">
                        <strong>{{ letterMap[idx] }}. </strong>
                        <input
                            type="text"
                            v-model="editingContent"
                            @blur="exitEditMode"
                            class="edit-input"
                        >
                    </div>
                </label>
            </div>

            <div v-else-if="currentQuestion.type === 'short-answer'">
                <!-- 简答题 -->
                <textarea
                    v-model="shortAnswerText"
                    :disabled="showAnswer"
                    rows="4"
                    style="width: 100%; padding: 8px;"
                    placeholder="请输入你的答案"
                ></textarea>
            </div>

            <div v-else-if="currentQuestion.type === 'fill-in-blank'">
                <!-- 填空题 -->
                <div v-for="(blank, idx) in currentQuestion.blanks" :key="idx" class="fill-blank-item">
                    <label :for="'blank-'+idx">空{{idx + 1}}：</label>
                    <input
                        :id="'blank-'+idx"
                        type="text"
                        v-model="fillInAnswers[idx]"
                        :disabled="showAnswer"
                        style="width: 200px; padding: 4px 8px; margin: 4px 0;"
                        :placeholder="'请填写空'+(idx+1)"
                    >
                    <span v-if="showAnswer" style="margin-left: 10px; color: #666;">
                        正确答案：{{ currentQuestion.correct_answer[idx] }}
                    </span>
                </div>
            </div>

            <!-- 提交答案 / 下一题 按钮 -->
            <div style="margin-top: 12px; display: flex; gap: 12px; align-items: center;">
                <button
                    type="button"
                    v-if="practiceManager?.currentIndex > 0"
                    class="btn"
                    @click="prevQuestion"
                >
                    上一题
                </button>
                <button
                    type="button"
                    v-if="!showAnswer"
                    class="btn"
                    @click="submitAnswer"
                >
                    提交答案
                </button>
                <button
                    type="button"
                    v-else
                    class="btn"
                    @click="nextQuestion"
                    :disabled="practiceManager?.currentIndex === quizList.length - 1 && isPreviewMode"
                >
                    下一题 
                </button>
            </div>

            <!-- 解析 -->
            <div v-if="showAnswer" class="analysis">
                <h3>解析</h3>
                <div 
                    v-if="(!isEditing || editingField !== 'analysis') && currentQuestion.analysis"
                    @click="isEditing && !isPreviewMode ? enterEditMode('analysis', currentQuestion.analysis) : null"
                    v-html="renderedAnalysis"
                    :class="{ 'editable': isEditing && !isPreviewMode }"
                ></div>
                <div 
                    v-if="(!isEditing || editingField !== 'analysis') && !currentQuestion.analysis"
                    @click="isEditing && !isPreviewMode ? enterEditMode('analysis', '') : null"
                    class="empty-analysis"
                    :class="{ 'editable': isEditing && !isPreviewMode }"
                >
                    点击添加解析
                </div>
                <textarea
                    v-else-if="editingField === 'analysis'"
                    v-model="editingContent"
                    @blur="exitEditMode"
                    class="edit-textarea"
                    rows="6"
                    placeholder="请输入解析内容..."
                ></textarea>
            </div>

            <p style="font-size:13px; color:#666; margin-top:8px;">
                <template v-if="!isPreviewMode">
                  键盘：1~4 选项，空格提交/下一题，Shift+C切换解析
                </template>
                <template v-else>
                  键盘：1~4 选项，Shift+C切换解析，q/e切换上一题/下一题
                </template>
            </p>
        </div>

        <!-- 5) result: 最终结果 -->
        <div v-else-if="pageState === 'result'" class="card">
            <h1 class="title">答题完成</h1>
            <p>本轮共 {{ quizList.length }} 题，已完成：{{ completedCount }}。</p>
            <button type="button" class="btn" @click="pageState = 'home'">
                返回题目选择 (空格)
            </button>
        </div>
    </template>

    <!-- Tags Modal -->
    <div v-if="showTagsModal" class="modal-overlay" @click="showTagsModal = false">
        <div class="modal-content" @click.stop>
            <h2>选择标签</h2>
            <div class="tags-grid">
                <span 
                    v-for="tagInfo in allTags" 
                    :key="tagInfo.tag"
                    :class="['tag-chip', { active: selectedTags.includes(tagInfo.tag) }]"
                    @click="toggleTag(tagInfo.tag)"
                >
                    {{ tagInfo.tag }} ({{ tagInfo.count }})
                </span>
            </div>
            <div class="modal-footer">
                <button @click="clearTags" class="btn btn-clear">清除筛选</button>
                <button @click="showTagsModal = false" class="btn btn-close">关闭窗口</button>
            </div>
        </div>
    </div>

    <!-- Cross Practice Modal -->
    <div v-if="showCrossPracticeModal" 
         class="modal-overlay" 
         @click="showCrossPracticeModal = false"
         @keydown.stop>
        <div class="modal-content cross-practice-modal" 
             @click.stop
             @keydown.left.prevent
             @keydown.right.prevent
             @keydown.up.prevent
             @keydown.down.prevent>
            <h2>跨卷练习设置</h2>
            
            <!-- 题型筛选 -->
            <div class="setting-section">
                <h3>题型筛选</h3>
                <div class="question-types">
                    <label v-for="type in questionTypes" :key="type.value" class="type-checkbox">
                        <input type="checkbox" 
                               v-model="selectedQuestionTypes" 
                               :value="type.value">
                        {{ type.label }}
                    </label>
                </div>
            </div>

            <!-- 练习模式 -->
            <div class="setting-section">
                <h3>练习模式</h3>
                <div class="practice-mode">
                    <label class="mode-radio">
                        <input type="radio" 
                               v-model="crossPracticeMode" 
                               value="random">
                        随机抽题
                    </label>
                    <label class="mode-radio">
                        <input type="radio" 
                               v-model="crossPracticeMode" 
                               value="error-rate">
                        错误率优先
                    </label>
                </div>
            </div>

            <!-- 题目数量 -->
            <div class="setting-section">
                <h3>练习题数</h3>
                <div class="question-count">
                            <input type="number" 
               :value="crossPracticeCount"
               min="1" 
               :max="maxQuestionCount"
               class="count-input"
               @input="handleQuestionInput"
               @blur="handleQuestionBlur"
               @keydown.stop
               @keydown.left.prevent
               @keydown.right.prevent
               @keydown.up.prevent
               @keydown.down.prevent
               ref="countInput">
                    <span class="max-count" :class="{ 'error': crossPracticeCount > maxQuestionCount }">
                        当前可选 {{ maxQuestionCount }} 题
                        <template v-if="crossPracticeCount > maxQuestionCount">
                            (超出限制)
                        </template>
                    </span>
                </div>
            </div>

            <!-- 参与题库及占比 -->
            <div class="setting-section">
                <h3>参与题库及占比</h3>
                <div class="bank-distribution">
                    <div v-for="bank in filteredBankDistribution" 
                         :key="bank.file" 
                         class="bank-item">
                        <div class="bank-name">{{ bank.name }}</div>
                        <div class="bank-count">
                            {{ bank.questionCount }}/{{ bank.availableQuestions }}题
                            ({{ Math.round((bank.questionCount / bank.availableQuestions) * 100) }}%)
                        </div>
                        <div class="bank-progress">
                            <div class="progress-bar" 
                                 :style="{ width: Math.round((bank.questionCount / bank.availableQuestions) * 100) + '%' }"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="modal-footer">
                <button @click="showCrossPracticeModal = false" 
                        class="btn btn-clear">取消</button>
                <button @click="startCrossPractice" 
                        class="btn btn-primary"
                        :disabled="!canStartCrossPractice">
                    开始练习
                </button>
            </div>
        </div>
    </div>
</div>

<script type="module">
    import StorageManager from './js/modules/storage.js';
    import JsonLoader from './js/modules/jsonLoader.js';
    import KeyboardManager from './js/modules/keyboard.js';
    import QuestionManager from './js/modules/QuestionManager.js';
    import PracticeManager from './js/modules/PracticeManager.js';

    const app = Vue.createApp({
        data() {
            return {
                storageManager: new StorageManager(),
                jsonLoader: null,
                keyboardManager: null,
                questionManager: null,
                practiceManager: null,
                pageState: 'home',
                isLoading: false,
                loadError: null,
                fileList: [],
                groupedFileList: [],
                chosenSet: null,
                showAnswer: false,
                isEditing: false,
                editingField: null,
                editingContent: '',
                showExportButton: false,
                chosenAnswer: '',
                chosenAnswers: [],
                shortAnswerText: '',
                fillInAnswers: [],
                currentSessionCompleted: new Set(),
                modifiedCount: 0,
                showUnsavedModal: false,
                dontShowExportReminder: false,
                groupedModifiedQuestions: {},
                lastExportTimestamp: null,
                updateTime: null,
                showTagsModal: false,
                selectedTags: [],
                topTags: [],
                allTags: [],
                bankStats: {},
                _altHPressed: false,
                // 跨卷练习相关
                _showCrossPracticeModal: false,
                selectedQuestionTypes: ['single-choice', 'multiple-choice', 'fill-in-blank', 'short-answer'],
                crossPracticeMode: 'random',
                crossPracticeCount: 30,
                questionTypes: [
                    { value: 'single-choice', label: '单选题' },
                    { value: 'multiple-choice', label: '多选题' },
                    { value: 'fill-in-blank', label: '填空题' },
                    { value: 'short-answer', label: '简答题' }
                ],
            }
        },
        mounted() {
            this.$nextTick(() => {
                if (this.pageState === 'setDescription') {
                    console.log('Page mounted in setDescription state');
                    const buttons = document.querySelectorAll('.mode-btn');
                    console.log('Initial mode buttons state:', {
                        totalButtons: buttons.length,
                        buttonElements: Array.from(buttons).map(btn => ({
                            text: btn.textContent.trim(),
                            tabIndex: btn.tabIndex,
                            hasClickHandler: btn.onclick !== null,
                            hasKeydownHandler: btn.onkeydown !== null
                        }))
                    });
                }
            });

            // 添加浏览器前进/后退按钮支持
            window.addEventListener('popstate', this.handlePopState);

            // 添加 URL 变化监听
            window.addEventListener('hashchange', this.handleUrlChange);
            window.addEventListener('popstate', this.handleUrlChange);

            // 添加全局Alt+H返回快捷键
            window.addEventListener('keydown', this.handleGlobalBackShortcut);
        },
        beforeUnmount() {
            // 清理事件监听器
            window.removeEventListener('popstate', this.handlePopState);
            window.removeEventListener('hashchange', this.handleUrlChange);
            window.removeEventListener('popstate', this.handleUrlChange);
            window.removeEventListener('keydown', this.handleGlobalBackShortcut);
        },
        watch: {
            selectedQuestionTypes: {
                handler() {
                    console.log('[selectedQuestionTypes] Question types changed, updating distribution');
                    this.updateBankDistribution();
                },
                deep: true
            },
            pageState: {
                handler(newState, oldState) {
                    console.log('Page state changed:', {
                        from: oldState,
                        to: newState
                    });
                    if (newState === 'setDescription') {
                        this.$nextTick(() => {
                            const buttons = document.querySelectorAll('.mode-btn');
                            console.log('Mode buttons after state change:', {
                                totalButtons: buttons.length,
                                buttonElements: Array.from(buttons).map(btn => ({
                                    text: btn.textContent.trim(),
                                    tabIndex: btn.tabIndex,
                                    hasClickHandler: btn.onclick !== null,
                                    hasKeydownHandler: btn.onkeydown !== null
                                }))
                            });
                        });
                    }
                },
                immediate: true
            }
        },
        async created() {
            // 初始化各个管理器
            this.jsonLoader = new JsonLoader();
            this.keyboardManager = new KeyboardManager(this);
            this.questionManager = new QuestionManager(this.storageManager);
            this.practiceManager = new PracticeManager(this.storageManager);

            // 先加载题库列表
            await this.loadBankList();
            
            // 然后处理URL参数
            await this.handleUrlParams();
        },
        computed: {
            currentQuestion() {
                return this.practiceManager?.getCurrentQuestion() || null;
            },
            currentIndex() {
                return this.practiceManager?.currentIndex || 0;
            },
            quizList() {
                return this.practiceManager?.questions || [];
            },
            isPreviewMode() {
                return this.practiceManager?.isPreviewMode || false;
            },
            totalStats() {
                const stats = this.storageManager.getAllBanksStats();
                console.log('[totalStats computed] Raw stats from storage:', stats);
                return {
                    completedQuestions: stats.completedQuestions || 0,
                    totalAttempts: stats.totalAttempts || 0,
                    averageAccuracy: stats.averageAccuracy || 0,
                    todayPracticed: stats.todayPracticed || 0,
                };
            },
            setStats() {
                if (!this.chosenSet) return null;
                const stats = this.storageManager.getSetStats(this.chosenSet.id, this.jsonLoader.questions);
                const today = new Date().toISOString().split('T')[0];
                
                // 获取今日练习题数
                const todayCount = this.jsonLoader.questions.reduce((count, q) => {
                    const completion = this.storageManager.getQuestionCompletion(this.chosenSet.id, q.uniqueId);
                    if (completion && completion.lastAttemptDate === today) {
                        return count + 1;
                    }
                    return count;
                }, 0);

                return {
                    ...stats,
                    todayCount,
                    averageAccuracy: stats.totalAttempts > 0 
                        ? Math.round((stats.totalCorrect / stats.totalAttempts) * 100)
                        : 0
                };
            },
            renderedContent() {
                if (!this.currentQuestion.content) return '';
                return this.renderMarkdownWithLatex(this.currentQuestion.content);
            },
            renderedAnalysis() {
                if (!this.currentQuestion.analysis) return '';
                return this.renderMarkdownWithLatex(this.currentQuestion.analysis);
            },
            progressText() {
                return `本次练习完成度：${this.currentSessionCompleted.size}/${this.quizList.length}`;
            },
            completedCount() {
                return this.currentSessionCompleted.size;
            },
            letterMap() {
                return ['A','B','C','D','E','F'];
            },
            hoverTitle() {
                return false;
            },
            hasChanges() {
                return false;
            },
            changesExported() {
                return false;
            },
            questionStats() {
                if (!this.chosenSet || !this.currentQuestion) return null;
                return this.storageManager.getQuestionStats(
                    this.chosenSet.id,
                    this.currentQuestion.uniqueId
                );
            },
            filteredGroupedFileList() {
                if (this.selectedTags.length === 0) return this.groupedFileList;
                
                return this.groupedFileList.map(([category, items]) => {
                    const filteredItems = items.filter(item => 
                        this.selectedTags.every(tag => item.tags && item.tags.includes(tag))
                    );
                    return [category, filteredItems];
                }).filter(([_, items]) => items.length > 0);
            },
            // 跨卷练习相关的计算属性
            filteredBankDistribution() {
                // 获取符合当前标签和题型筛选的题库及题目数
                const distribution = [];
                let totalQuestions = 0;

                // 遍历所有题库
                this.fileList.forEach(bank => {
                    // 检查标签筛选
                    if (this.selectedTags.length > 0 && 
                        !this.selectedTags.every(tag => bank.tags && bank.tags.includes(tag))) {
                        return;
                    }

                    // 获取题库中符合题型的题目数量
                    const questions = this.jsonLoader.getQuestionsFromBank(bank.file);
                    const filteredQuestions = questions.filter(q => 
                        this.selectedQuestionTypes.includes(q.type)
                    );

                    if (filteredQuestions.length > 0) {
                        totalQuestions += filteredQuestions.length;
                        distribution.push({
                            file: bank.file,
                            name: bank.name,
                            questionCount: filteredQuestions.length,
                            questions: filteredQuestions
                        });
                    }
                });

                // 计算百分比
                return distribution.map(bank => ({
                    ...bank,
                    percentage: Math.round((bank.questionCount / totalQuestions) * 100)
                }));
            },
            maxQuestionCount() {
                return this.filteredBankDistribution.reduce(
                    (sum, bank) => sum + bank.questionCount, 
                    0
                );
            },
            canStartCrossPractice() {
                return this.selectedQuestionTypes.length > 0 && 
                       this.crossPracticeCount > 0 && 
                       this.crossPracticeCount <= this.maxQuestionCount &&
                       this.filteredBankDistribution.length > 0;
            },
            showCrossPracticeModal: {
                get() {
                    return this._showCrossPracticeModal;
                },
                set(value) {
                    this._showCrossPracticeModal = value;
                    if (value) {
                        // 打开模态框时初始化
                        this.$nextTick(() => {
                            this.updateBankDistribution();
                            // 如果当前选择的题目数大于最大可选数，自动调整
                            const totalAvailable = this.filteredBankDistribution.reduce((sum, bank) => sum + bank.availableQuestions, 0);
                            if (this.crossPracticeCount > totalAvailable) {
                                console.log(`[showCrossPracticeModal] Adjusting initial count from ${this.crossPracticeCount} to ${totalAvailable}`);
                                this.crossPracticeCount = totalAvailable;
                            }
                        });
                    }
                }
            }
        },
        methods: {
            // 加载题库列表
            async loadBankList() {
                this.isLoading = true;
                this.loadError = null;
                try {
                    const response = await fetch('assets/list.json');
                    const data = await response.json();
                    this.fileList = data.banks || [];
                    this.updateTime = data.updateTime;
                    
                    // 加载每个题库的统计信息
                    for (const bank of this.fileList) {
                        await this.loadBankStats(bank.file);
                    }
                    
                    // 加载每个题库的sets信息以获取category和tags
                    const fileCategories = {};
                    const fileTags = {};
                    const tagsCount = new Map();
                    
                    for (const bank of this.fileList) {
                        try {
                            const bankData = await this.jsonLoader.loadFile(bank.file);
                            const category = bankData.sets[0]?.category || '未分类';
                            const tags = bankData.sets[0]?.tags || [];
                            
                            fileCategories[bank.file] = category;
                            fileTags[bank.file] = tags;
                            
                            // 统计tags
                            tags.forEach(tag => {
                                tagsCount.set(tag, (tagsCount.get(tag) || 0) + 1);
                            });
                        } catch (error) {
                            console.error(`Error loading bank ${bank.file}:`, error);
                            fileCategories[bank.file] = '未分类';
                            fileTags[bank.file] = [];
                        }
                    }
                    
                    // 更新fileList添加tags信息
                    this.fileList = this.fileList.map(bank => ({
                        ...bank,
                        tags: fileTags[bank.file] || []
                    }));
                    
                    // 获取前三个最常用的tags
                    this.topTags = Array.from(tagsCount.entries())
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3)
                        .map(([tag, count]) => ({ tag, count }));
                    
                    // 获取所有tags
                    this.allTags = Array.from(tagsCount.entries())
                        .sort((a, b) => b[1] - a[1])
                        .map(([tag, count]) => ({ tag, count }));
                    
                    // 按category对题库进行分组
                    const groups = {};
                    this.fileList.forEach(bank => {
                        const category = fileCategories[bank.file] || '未分类';
                        if (!groups[category]) {
                            groups[category] = [];
                        }
                        groups[category].push(bank);
                    });
                    
                    // 对每个分类内的题库按名称排序
                    for (const category in groups) {
                        groups[category].sort((a, b) => a.name.localeCompare(b.name));
                    }
                    
                    // 转换为数组并按分类名排序，确保"未分类"永远在最后
                    this.groupedFileList = Object.entries(groups)
                        .sort((a, b) => {
                            if (a[0] === '未分类') return 1;
                            if (b[0] === '未分类') return -1;
                            return a[0].localeCompare(b[0]);
                        });
                } catch (error) {
                    console.error('Error loading file list:', error);
                    this.loadError = error.message;
                }
                this.isLoading = false;
            },

            // 加载题库文件
            async loadJsonFile(fileName) {
                console.log('[loadJsonFile] Starting to load file:', fileName);
                if (this.isLoading) {
                    console.log('[loadJsonFile] Already loading, skipping');
                    return;
                }
                this.isLoading = true;
                try {
                    console.log('[loadJsonFile] Loading data from file');
                    const data = await this.jsonLoader.loadFile(fileName);
                    console.log('[loadJsonFile] Data loaded:', {
                        setName: data.sets[0]?.name,
                        questionCount: data.questions?.length
                    });
                    
                    this.chosenSet = data.sets[0];
                    
                    // 更新统计数据
                    console.log('[loadJsonFile] Updating bank stats');
                    await this.loadBankStats(fileName);
                    
                    // 更新URL并切换到题库详情页
                    console.log('[loadJsonFile] Updating page state to setDescription');
                    this.updatePageState('setDescription');
                } catch (error) {
                    console.error('[loadJsonFile] Failed to load bank:', error);
                    alert('加载题库失败: ' + error.message);
                } finally {
                    this.isLoading = false;
                    console.log('[loadJsonFile] Loading completed');
                }
            },

            // 开始练习
            startQuiz(mode) {
                switch (mode) {
                    case 'all':
                        this.enterQuizMode();
                        break;
                    case 'wrong':
                        this.enterOrderQuizMode();
                        break;
                    case 'random':
                        this.enterRandomQuizMode();
                        break;
                    case 'preview':
                        this.enterPreviewMode();
                        break;
                }
            },

            // 进入练习模式
            enterQuizMode() {
                this.practiceManager.initPractice(this.jsonLoader.questions, 'sequence');
                this.practiceManager.togglePreviewMode(false);
                this.showAnswer = false;
                this.currentSessionCompleted.clear();
                this.updatePageState('quiz', { mode: 'all' });
            },

            enterOrderQuizMode() {
                this.practiceManager.initPractice(this.jsonLoader.questions, 'error-rate');
                this.practiceManager.togglePreviewMode(false);
                this.showAnswer = false;
                this.currentSessionCompleted.clear();
                this.updatePageState('quiz', { mode: 'wrong' });
            },

            enterRandomQuizMode() {
                this.practiceManager.initPractice(this.jsonLoader.questions, 'random');
                this.practiceManager.togglePreviewMode(false);
                this.showAnswer = false;
                this.currentSessionCompleted.clear();
                this.updatePageState('quiz', { mode: 'random' });
            },

            enterPreviewMode() {
                this.practiceManager.initPractice(this.jsonLoader.questions, 'sequence');
                this.practiceManager.togglePreviewMode(true);
                this.showAnswer = true;
                this.updatePageState('quiz', { mode: 'preview' });
            },

            // 编辑相关方法
            editQuestion() {
                if (this.isPreviewMode) return;
                console.log('Starting edit mode for question:', this.currentQuestion);
                this.questionManager.startEditing(this.currentQuestion);
                this.isEditing = true;
                this.showExportButton = true;
                // 自动切换到解析模式
                this.showAnswer = true;
            },

            enterEditMode(field, content) {
                if (this.isPreviewMode) return;
                console.log('Entering edit mode:', {
                    field,
                    content,
                    currentContent: content || '点击编辑'
                });
                this.editingField = field;
                this.editingContent = content || '';
            },

            exitEditMode() {
                console.log('Exiting edit mode:', {
                    field: this.editingField,
                    content: this.editingContent,
                    question: this.currentQuestion
                });
                
                if (this.editingField && this.editingContent !== undefined) {
                    const question = this.currentQuestion;
                    if (this.editingField === 'content') {
                        question.content = this.editingContent;
                    } else if (this.editingField === 'analysis') {
                        question.analysis = this.editingContent;
                    } else if (this.editingField.startsWith('option-')) {
                        const idx = parseInt(this.editingField.split('-')[1]);
                        question.options[idx] = this.editingContent;
                    }
                    this.questionManager.saveCurrentEdit();
                    // 更新修改计数
                    this.modifiedCount = this.questionManager.getModifiedQuestions().length;
                }
                this.editingField = null;
                this.editingContent = '';
                this.isEditing = false;
                this.showAnswer = false; // 退出解析模式
            },

            // 导出相关方法
            handleExport(questions) {
                const exportData = {
                    questions: questions,
                    sets: [this.chosenSet]
                };

                const blob = new Blob([JSON.stringify(exportData, null, 4)], 
                    { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                // 从fileList中获取当前题库的文件名
                const currentFile = this.fileList.find(f => f.name === this.chosenSet.name)?.file;
                a.download = this.questionManager.generateExportFileName(currentFile || 'export');
                a.click();
                URL.revokeObjectURL(url);

                // 更新导出状态
                this.lastExportTimestamp = Date.now();
                this.modifiedCount = 0;
                this.questionManager.clearModifiedQuestions();
                this.showExportButton = false;
                this.isEditing = false;
                this.showUnsavedModal = false;
            },

            // 导出修改
            exportModifiedData() {
                const modifiedQuestions = this.questionManager.getModifiedQuestions();
                const questions = this.jsonLoader.questions.map(q => {
                    if (modifiedQuestions.includes(q.uniqueId)) {
                        return { ...q };
                    }
                    return q;
                });
                this.handleExport(questions);
            },

            // 状态更新
            updatePageState(newState, params = {}) {
                console.log('[updatePageState] from:', this.pageState, 'to:', newState, 'params:', params);
                // 如果有未导出的修改，且不是刚刚导出的，且不是在编辑模式中
                if (this.modifiedCount > 0 && !this.dontShowExportReminder && 
                    (!this.lastExportTimestamp || Date.now() - this.lastExportTimestamp > 1000) &&
                    !this.isEditing) {
                    const hasUnsaved = this.checkModifiedQuestions();
                    if (hasUnsaved) {
                        return;
                    }
                }
                
                if (this.isEditing && this.questionManager.checkUnsavedChanges()) {
                    this.showUnsavedDialog(newState);
                    return;
                }
                
                this.pageState = newState;
                
                // 如果是返回题库详情页，确保传递当前题库参数
                if (newState === 'setDescription' && this.chosenSet) {
                    const currentFile = this.fileList.find(f => f.name === this.chosenSet.name)?.file;
                    if (currentFile) {
                        params.bank = currentFile;
                    }
                }
                
                // 更新URL参数
                this.updateUrlParams(newState, params);
                
                if (newState === 'home') {
                    this.questionManager.clearEditHistory();
                    this.showExportButton = false;
                }
            },

            showUnsavedDialog(newState) {
                const dialog = document.createElement('div');
                dialog.className = 'modal-overlay';
                dialog.innerHTML = `
                    <div class="modal-content" style="padding: 20px; max-width: 400px;">
                        <h3 style="margin-top: 0;">未保存的修改</h3>
                        <p>当前题目有未保存的修改，请选择操作：</p>
                        <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                            <button class="btn" id="continueEdit" style="background-color: #B0C1A2;">继续编辑</button>
                            <button class="btn" id="saveAndExit" style="background-color: #91a881;">保存并退出</button>
                            <button class="btn" id="discardAndExit" style="background-color: #d32f2f;">放弃修改</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(dialog);

                // 点击遮罩层关闭对话框（继续编辑）
                dialog.addEventListener('click', (e) => {
                    if (e.target === dialog) {
                        document.body.removeChild(dialog);
                    }
                });

                // 继续编辑
                dialog.querySelector('#continueEdit').addEventListener('click', () => {
                    document.body.removeChild(dialog);
                });

                // 保存并退出
                dialog.querySelector('#saveAndExit').addEventListener('click', () => {
                    this.questionManager.saveCurrentEdit();
                    this.isEditing = false;
                    this.showExportButton = false;
                    this.pageState = newState;
                    if (newState === 'home') {
                        this.questionManager.clearEditHistory();
                    }
                    document.body.removeChild(dialog);
                });

                // 放弃修改并退出
                dialog.querySelector('#discardAndExit').addEventListener('click', () => {
                    this.questionManager.cancelEditing();
                    this.isEditing = false;
                    this.showExportButton = false;
                    this.pageState = newState;
                    if (newState === 'home') {
                        this.questionManager.clearEditHistory();
                    }
                    document.body.removeChild(dialog);
                });
            },

            goBack() {
                console.log('[goBack] Called, pageState:', this.pageState, 'isEditing:', this.isEditing);
                if (this.isEditing) {
                    if (this.questionManager.checkUnsavedChanges()) {
                        this.showUnsavedDialog('setDescription');
                        return;
                    } else {
                        this.questionManager.cancelEditing();
                        this.isEditing = false;
                        this.showExportButton = false;
                        this.showAnswer = false; // 退出解析模式
                    }
                }
                
                // 获取当前题库文件名
                const currentFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                console.log('[goBack] Current bank file:', currentFile);
                
                // 返回题库描述页面时保持bank参数
                console.log('[goBack] updatePageState to setDescription');
                this.updatePageState('setDescription', { bank: currentFile });
            },

            goHome() {
                console.log('[goHome] Called, pageState:', this.pageState);
                // 清除所有状态和URL参数
                this.chosenSet = null;
                this.questionManager.clearEditHistory();
                this.showExportButton = false;
                this.updatePageState('home');
            },

            getBankStats(fileName) {
                try {
                    const bankData = this.storageManager.getBankStats(fileName);
                    console.log(`[getBankStats] Stats for ${fileName}:`, bankData);
                    if (!bankData) return null;
                    
                    const stats = {
                        completed: bankData.completed,
                        total: bankData.total,
                        accuracy: bankData.attempts > 0 
                            ? Math.round((bankData.correct / bankData.attempts) * 100)
                            : 0
                    };
                    console.log(`[getBankStats] Processed stats for ${fileName}:`, stats);
                    return stats;
                } catch (e) {
                    console.error('获取题库统计失败:', e);
                    return null;
                }
            },

            renderMarkdown(text) {
                if (!text) return '';
                return marked.parse(text);
            },

            renderMarkdownWithLatex(text) {
                if (!text) return '';
                
                // 先处理多行公式，避免被markdown解析器破坏格式
                let content = text;
                
                // 保存多行公式
                const formulas = [];
                content = content.replace(/\$\$([\s\S]+?)\$\$/g, (match, formula) => {
                    // 保持原始换行，不进行任何替换
                    formulas.push(formula.trim());
                    return `<div class="katex-display">${katex.renderToString(formula.trim(), {
                        displayMode: true,
                        throwOnError: false,
                        strict: false,
                        trust: true,
                        output: 'html'
                    })}</div>`;
                });
                
                // 处理Markdown
                content = marked.parse(content);
                
                // 处理行内公式
                content = content.replace(/\$([^$]+?)\$/g, (match, formula) => {
                    try {
                        return katex.renderToString(formula.trim(), {
                            displayMode: false,
                            throwOnError: false,
                            strict: false
                        });
                    } catch (e) {
                        console.error('LaTeX rendering error:', e);
                        console.error('Formula:', formula);
                        return match;
                    }
                });
                
                return content;
            },

            handleOptionChange(option, isSingleChoice) {
                console.log('Option change handler:', {
                    option,
                    isSingleChoice,
                    currentValue: isSingleChoice ? this.chosenAnswer : this.chosenAnswers
                });

                if (isSingleChoice) {
                    this.chosenAnswer = option;
                } else {
                    const index = this.chosenAnswers.indexOf(option);
                    if (index === -1) {
                        this.chosenAnswers.push(option);
                    } else {
                        this.chosenAnswers.splice(index, 1);
                    }
                }

                console.log('After option change:', {
                    chosenAnswer: this.chosenAnswer,
                    chosenAnswers: this.chosenAnswers
                });
            },

            isChosenOptionSingle(opt) {
                console.log('Checking single option selection:', {
                    option: opt,
                    optionType: typeof opt,
                    chosenAnswer: this.chosenAnswer,
                    chosenAnswerType: typeof this.chosenAnswer,
                    isChosen: String(this.chosenAnswer) === String(opt)
                });
                return String(this.chosenAnswer) === String(opt);
            },

            isCorrectOptionMulti(opt) {
                const ans = this.currentQuestion?.correct_answer || [];
                const isCorrect = ans.some(a => String(a) === String(opt));
                console.log('Checking multi option correctness:', {
                    option: opt,
                    correctAnswers: ans,
                    isCorrect: isCorrect
                });
                return isCorrect;
            },

            isCorrectOptionSingle(opt) {
                const ans = this.currentQuestion?.correct_answer || [];
                const isCorrect = ans.length > 0 && String(ans[0]) === String(opt);
                console.log('Checking single option correctness:', {
                    option: opt,
                    optionType: typeof opt,
                    correctAnswer: ans[0],
                    correctAnswerType: ans.length > 0 ? typeof ans[0] : 'undefined',
                    isCorrect: isCorrect
                });
                return isCorrect;
            },

            submitAnswer() {
                const q = this.currentQuestion;
                console.log('Submitting answer:', {
                    questionType: q.type,
                    questionId: q.uniqueId,
                    chosenAnswer: this.chosenAnswer,
                    chosenAnswers: this.chosenAnswers,
                    correctAnswer: q.correct_answer,
                    sourceBank: q.sourceBank
                });

                if (!q.uniqueId) return;

                // 在预览模式下，直接显示答案，不进行验证和记录
                if (this.isPreviewMode) {
                    this.showAnswer = true;
                    return;
                }

                // 未选择/未填写时提示
                if (q.type === 'single-choice' && !this.chosenAnswer) {
                    console.log('No answer chosen for single choice question');
                    alert('请先选择一个选项');
                    return;
                }
                if (q.type === 'multiple-choice' && !this.chosenAnswers.length) {
                    alert('请至少选择一个选项');
                    return;
                }
                if (q.type === 'short-answer' && !this.shortAnswerText.trim()) {
                    alert('请先填写你的答案');
                    return;
                }
                if (q.type === 'fill-in-blank') {
                    if (this.fillInAnswers.some(answer => !answer?.trim())) {
                        alert('请填写所有空格');
                        return;
                    }
                }

                // 判定正误
                let isCorrect = false;
                if (q.type === 'single-choice') {
                    const userAnswer = String(this.chosenAnswer || '');
                    const correctAnswer = String(q.correct_answer[0] || '');
                    isCorrect = userAnswer === correctAnswer;
                    console.log('Single choice answer check:', {
                        userAnswer,
                        correctAnswer,
                        isCorrect,
                        chosenAnswerType: typeof this.chosenAnswer,
                        correctAnswerType: typeof q.correct_answer[0]
                    });
                } else if (q.type === 'multiple-choice') {
                    const c1 = [...this.chosenAnswers].map(String).sort().join('||');
                    const c2 = [...q.correct_answer].map(String).sort().join('||');
                    isCorrect = (c1 === c2);
                } else if (q.type === 'short-answer') {
                    const userAns = this.shortAnswerText.trim();
                    const correctAns = (q.correct_answer[0] || '').trim();
                    isCorrect = (userAns === correctAns);
                } else if (q.type === 'fill-in-blank') {
                    const userAns = this.fillInAnswers.map(a => a.trim()).join('||');
                    const correctAns = q.correct_answer.map(a => a.trim()).join('||');
                    isCorrect = (userAns === correctAns);
                }

                // 更新当前会话的完成记录
                if (isCorrect) {
                    this.currentSessionCompleted.add(q.uniqueId);
                }

                // 更新完成状态（非预览模式）
                const setId = this.chosenSet.isCrossPractice ? q.sourceBank : this.chosenSet.id;
                this.storageManager.updateQuestionCompletion(setId, q.uniqueId, isCorrect);
                this.showAnswer = true;
            },

            nextQuestion() {
                if (this.practiceManager && this.practiceManager.currentIndex < this.practiceManager.questions.length - 1) {
                    this.practiceManager.currentIndex++;
                    this.showAnswer = false;
                    this.updateUrlParams('quiz', { mode: this.getCurrentMode(), qid: this.practiceManager.questions[this.practiceManager.currentIndex].uniqueId });
                } else if (!this.isPreviewMode) {
                    this.updatePageState('result');
                }
            },
            formatDate(isoDate) {
                if (!isoDate) return '';
                const date = new Date(isoDate);
                const today = new Date();
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);

                if (isoDate.startsWith(today.toISOString().split('T')[0])) {
                    return '今天 ' + date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                } else if (isoDate.startsWith(yesterday.toISOString().split('T')[0])) {
                    return '昨天 ' + date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                } else {
                    return date.toLocaleDateString('zh-CN') + ' ' + 
                           date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                }
            },
            closeUnsavedModal() {
                this.showUnsavedModal = false;
            },
            truncateText(text, length) {
                if (!text) return '';
                text = text.replace(/<[^>]*>/g, ''); // 移除HTML标签
                return text.length > length ? text.slice(0, length) + '...' : text;
            },
            getSetName(setId) {
                return this.jsonLoader.sets.find(s => s.id === setId)?.name || setId;
            },
            checkModifiedQuestions() {
                const modifiedQuestions = this.questionManager.getModifiedQuestions();
                if (modifiedQuestions.length > 0 && !this.dontShowExportReminder) {
                    // 只显示当前题库的修改题目
                    this.groupedModifiedQuestions = this.jsonLoader.questions
                        .filter(q => modifiedQuestions.includes(q.uniqueId));
                    
                    // 显示未导出提示模态框
                    this.showUnsavedModal = true;
                    return true;
                }
                return false;
            },
            showBanner(content, type = 'info', closeable = true) {
                this.banner = {
                    show: true,
                    content,
                    type,
                    closeable
                };
            },
            closeBanner() {
                this.banner.show = false;
            },
            formatUpdateTime(isoString) {
                const date = new Date(isoString);
                return date.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            },
            closeUnsavedModalAndContinue() {
                this.showUnsavedModal = false;
                this.questionManager.clearModifiedQuestions();
                this.modifiedCount = 0;
                this.showExportButton = false;
            },
            toggleTag(tag) {
                const index = this.selectedTags.indexOf(tag);
                if (index === -1) {
                    this.selectedTags.push(tag);
                } else {
                    this.selectedTags.splice(index, 1);
                }
            },
            clearTags() {
                this.selectedTags = [];
            },
            async loadBankStats(fileName) {
                console.log('[loadBankStats] Loading stats for:', fileName);
                try {
                    // 获取统计信息
                    const stats = this.storageManager.getBankStats(fileName, this.jsonLoader);
                    console.log('[loadBankStats] Retrieved stats:', stats);
                    this.bankStats[fileName] = stats;
                    
                    // 强制更新计算属性
                    this.$forceUpdate();
                    console.log('[loadBankStats] Stats updated and view forced to update');
                    
                    // 如果在题库详情页面，确保setStats被重新计算
                    if (this.pageState === 'setDescription') {
                        console.log('[loadBankStats] Recalculating setStats for description page');
                        // Vue会自动重新计算setStats，因为依赖的数据已经更新
                        const currentStats = this.setStats;
                        console.log('[loadBankStats] Current setStats:', currentStats);
                    }
                } catch (error) {
                    console.error('[loadBankStats] Error loading bank stats:', error);
                }
            },
            focusPrevButton(event) {
                console.log('focusPrevButton triggered', {
                    eventTarget: event.target,
                    eventType: event.type,
                    currentActiveElement: document.activeElement
                });
                
                const buttons = Array.from(document.querySelectorAll('.mode-btn'));
                console.log('Found mode buttons:', {
                    totalButtons: buttons.length,
                    buttonTexts: buttons.map(btn => btn.textContent.trim())
                });
                
                const currentIndex = buttons.indexOf(event.target);
                console.log('Current button index:', currentIndex);
                
                const prevIndex = (currentIndex - 1 + buttons.length) % buttons.length;
                console.log('Will focus on button index:', prevIndex);
                
                buttons[prevIndex].focus();
                console.log('Focus set to:', {
                    buttonText: buttons[prevIndex].textContent.trim(),
                    newActiveElement: document.activeElement
                });
            },
            focusNextButton(event) {
                console.log('focusNextButton triggered', {
                    eventTarget: event.target,
                    eventType: event.type,
                    currentActiveElement: document.activeElement
                });
                
                const buttons = Array.from(document.querySelectorAll('.mode-btn'));
                console.log('Found mode buttons:', {
                    totalButtons: buttons.length,
                    buttonTexts: buttons.map(btn => btn.textContent.trim())
                });
                
                const currentIndex = buttons.indexOf(event.target);
                console.log('Current button index:', currentIndex);
                
                const nextIndex = (currentIndex + 1) % buttons.length;
                console.log('Will focus on button index:', nextIndex);
                
                buttons[nextIndex].focus();
                console.log('Focus set to:', {
                    buttonText: buttons[nextIndex].textContent.trim(),
                    newActiveElement: document.activeElement
                });
            },
            focusUpButton(event) {
                console.log('focusUpButton triggered', {
                    eventTarget: event.target,
                    eventType: event.type,
                    currentActiveElement: document.activeElement
                });
                
                const buttons = Array.from(document.querySelectorAll('.mode-btn'));
                console.log('Found mode buttons:', {
                    totalButtons: buttons.length,
                    buttonTexts: buttons.map(btn => btn.textContent.trim())
                });
                
                const currentIndex = buttons.indexOf(event.target);
                console.log('Current button index:', currentIndex);
                
                const COLS = window.innerWidth <= 600 ? 1 : 2;
                console.log('Grid layout:', {
                    columns: COLS,
                    windowWidth: window.innerWidth
                });
                
                const prevIndex = currentIndex - COLS;
                console.log('Calculated previous index:', prevIndex);
                
                if (prevIndex >= 0) {
                    console.log('Moving up to index:', prevIndex);
                    buttons[prevIndex].focus();
                } else {
                    // 如果到达顶部，跳转到最后一行的相同列
                    const sameColBottom = currentIndex % COLS + Math.floor((buttons.length - 1) / COLS) * COLS;
                    console.log('Wrapping to bottom, calculated index:', {
                        currentCol: currentIndex % COLS,
                        lastRowStart: Math.floor((buttons.length - 1) / COLS) * COLS,
                        targetIndex: sameColBottom
                    });
                    
                    if (sameColBottom < buttons.length) {
                        buttons[sameColBottom].focus();
                    } else {
                        buttons[buttons.length - 1].focus();
                    }
                }
                
                console.log('Focus set to:', {
                    buttonText: document.activeElement.textContent.trim(),
                    newActiveElement: document.activeElement
                });
            },
            focusDownButton(event) {
                console.log('focusDownButton triggered', {
                    eventTarget: event.target,
                    eventType: event.type,
                    currentActiveElement: document.activeElement
                });
                
                const buttons = Array.from(document.querySelectorAll('.mode-btn'));
                console.log('Found mode buttons:', {
                    totalButtons: buttons.length,
                    buttonTexts: buttons.map(btn => btn.textContent.trim())
                });
                
                const currentIndex = buttons.indexOf(event.target);
                console.log('Current button index:', currentIndex);
                
                const COLS = window.innerWidth <= 600 ? 1 : 2;
                console.log('Grid layout:', {
                    columns: COLS,
                    windowWidth: window.innerWidth
                });
                
                const nextIndex = currentIndex + COLS;
                console.log('Calculated next index:', nextIndex);
                
                if (nextIndex < buttons.length) {
                    console.log('Moving down to index:', nextIndex);
                    buttons[nextIndex].focus();
                } else {
                    // 如果到达底部，跳转到第一行的相同列
                    const sameColTop = currentIndex % COLS;
                    console.log('Wrapping to top, calculated index:', {
                        currentCol: currentIndex % COLS,
                        targetIndex: sameColTop
                    });
                    buttons[sameColTop].focus();
                }
                
                console.log('Focus set to:', {
                    buttonText: document.activeElement.textContent.trim(),
                    newActiveElement: document.activeElement
                });
            },
            handleKeyNavigation(event) {
                // 如果不是在题库详情页，不处理
                if (this.pageState !== 'setDescription') {
                    return;
                }

                // 获取所有模式按钮
                const buttons = Array.from(document.querySelectorAll('.mode-btn'));
                if (!buttons.length) return;

                // 获取当前焦点按钮的索引
                const currentIndex = buttons.findIndex(btn => btn === document.activeElement);
                let nextIndex = currentIndex;

                // 定义网格布局
                const COLS = window.innerWidth <= 600 ? 1 : 2;
                const ROWS = Math.ceil(buttons.length / COLS);

                // 计算当前位置
                const currentRow = Math.floor(currentIndex / COLS);
                const currentCol = currentIndex % COLS;

                switch (event.key) {
                    case 'ArrowRight':
                        nextIndex = currentIndex + 1;
                        if (nextIndex >= buttons.length) {
                            nextIndex = 0; // 循环到第一个
                        }
                        break;
                    case 'ArrowLeft':
                        nextIndex = currentIndex - 1;
                        if (nextIndex < 0) {
                            nextIndex = buttons.length - 1; // 循环到最后一个
                        }
                        break;
                    case 'ArrowDown':
                        // 向下移动，如果到底则循环到顶部同列
                        nextIndex = currentIndex + COLS;
                        if (nextIndex >= buttons.length) {
                            // 如果超出范围，回到顶部同列
                            nextIndex = currentCol;
                        }
                        break;
                    case 'ArrowUp':
                        // 向上移动，如果到顶则循环到底部同列
                        nextIndex = currentIndex - COLS;
                        if (nextIndex < 0) {
                            // 如果超出范围，去到底部同列
                            nextIndex = currentCol + (ROWS - 1) * COLS;
                            // 确保不超出实际按钮数量
                            if (nextIndex >= buttons.length) {
                                nextIndex = buttons.length - 1;
                            }
                        }
                        break;
                    case 'Tab':
                        // Tab 键循环
                        nextIndex = event.shiftKey ? 
                            (currentIndex - 1 + buttons.length) % buttons.length :
                            (currentIndex + 1) % buttons.length;
                        break;
                    default:
                        return; // 其他键不处理
                }

                // 阻止默认行为
                event.preventDefault();

                // 设置焦点
                if (nextIndex >= 0 && nextIndex < buttons.length) {
                    buttons[nextIndex].focus();
                }
            },
            getFocusableElements() {
                // 获取当前页面中所有可聚焦的元素
                if (this.pageState === 'setDescription') {
                    // 在题库详情页中，只获取模式按钮
                    return Array.from(document.querySelectorAll('.mode-btn'))
                        .filter(el => {
                            const style = window.getComputedStyle(el);
                            return style.display !== 'none' && style.visibility !== 'hidden';
                        });
                }
                
                const selector = 'button, [tabindex="0"], a[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled])';
                return Array.from(this.$el.querySelectorAll(selector))
                    .filter(el => {
                        // 确保元素是可见的
                        const style = window.getComputedStyle(el);
                        return style.display !== 'none' && style.visibility !== 'hidden';
                    });
            },
            initModeButtonsFocus() {
                // 确保第一个按钮获得焦点
                if (this.pageState === 'setDescription') {
                    this.$nextTick(() => {
                        const firstBtn = this.$refs.firstModeBtn;
                        if (firstBtn) {
                            firstBtn.focus();
                        }
                    });
                }
            },
            // URL参数处理
            async handleUrlParams() {
                const urlParams = new URLSearchParams(window.location.search);
                const bankParam = urlParams.get('bank');
                const stateParam = urlParams.get('state');
                const modeParam = urlParams.get('mode');
                const qidParam = urlParams.get('qid');
                
                console.log('[handleUrlParams] Processing URL parameters:', {
                    bank: bankParam,
                    state: stateParam,
                    mode: modeParam,
                    qid: qidParam
                });
                
                if (!bankParam) {
                    console.log('[handleUrlParams] No bank parameter, staying on home page');
                    return;
                }

                // 确保题库列表已加载
                if (this.fileList.length === 0) {
                    console.log('[handleUrlParams] File list not loaded yet, waiting...');
                    await this.loadBankList();
                }

                // 验证题库是否存在
                const bankExists = this.fileList.some(f => f.file === bankParam);
                if (!bankExists) {
                    console.error('[handleUrlParams] Bank not found:', bankParam);
                    alert('找不到指定的题库');
                    this.resetAllState();
                    return;
                }
                
                try {
                    this.isLoading = true;
                    // 加载题库数据
                    console.log('[handleUrlParams] Loading bank data:', bankParam);
                    const data = await this.jsonLoader.loadFile(bankParam);
                    console.log('[handleUrlParams] Bank data loaded:', {
                        setName: data.sets[0]?.name,
                        questionCount: data.questions?.length
                    });
                    
                    this.chosenSet = data.sets[0];
                    
                    // 更新统计数据
                    console.log('[handleUrlParams] Updating bank stats');
                    await this.loadBankStats(bankParam);
                    
                    // 根据state参数设置页面状态
                    if (stateParam === 'quiz' && modeParam) {
                        console.log('[handleUrlParams] Setting up quiz mode:', modeParam);
                        await this.setupQuizMode(modeParam, qidParam);
                    } else {
                        console.log('[handleUrlParams] Setting page state to:', stateParam || 'setDescription');
                        this.pageState = stateParam || 'setDescription';
                    }
                } catch (error) {
                    console.error('[handleUrlParams] Failed to process URL parameters:', error);
                    alert('加载题库失败: ' + error.message);
                    this.resetAllState();
                } finally {
                    this.isLoading = false;
                }
            },

            // 设置练习模式，支持qid跳转
            async setupQuizMode(mode, qid = null) {
                console.log('[setupQuizMode] Setting up quiz mode:', mode, {
                    currentQuestions: this.jsonLoader.questions?.length,
                    qid
                });
                try {
                    // 确保我们使用的是当前加载的题库数据
                    const questions = this.jsonLoader.questions;
                    if (!questions || questions.length === 0) {
                        throw new Error('No questions available for quiz mode');
                    }

                    switch(mode) {
                        case 'all':
                            this.practiceManager.initPractice(questions, 'sequence');
                            this.practiceManager.togglePreviewMode(false);
                            break;
                        case 'wrong':
                            this.practiceManager.initPractice(questions, 'error-rate');
                            this.practiceManager.togglePreviewMode(false);
                            break;
                        case 'random':
                            this.practiceManager.initPractice(questions, 'random');
                            this.practiceManager.togglePreviewMode(false);
                            break;
                        case 'preview':
                            this.practiceManager.initPractice(questions, 'sequence');
                            this.practiceManager.togglePreviewMode(true);
                            this.showAnswer = true;
                            break;
                    }
                    // 跳转到指定qid
                    if (qid) {
                        const idx = questions.findIndex(q => q.uniqueId === qid);
                        if (idx !== -1) {
                            this.practiceManager.currentIndex = idx;
                        }
                    }
                    console.log('[setupQuizMode] Practice manager initialized with questions:', questions.length);
                    this.resetQuizState();
                    this.pageState = 'quiz';
                    console.log('[setupQuizMode] Quiz mode setup completed');
                } catch (error) {
                    console.error('[setupQuizMode] Failed to setup quiz mode:', error);
                    this.resetAllState();
                }
            },

            // 处理浏览器前进/后退
            async handlePopState(event) {
                console.log('[handlePopState] Processing popstate event:', event);
                const urlParams = new URLSearchParams(window.location.search);
                const bankParam = urlParams.get('bank');
                const stateParam = urlParams.get('state');
                const modeParam = urlParams.get('mode');
                const practiceModeParam = urlParams.get('practiceMode');
                const countParam = urlParams.get('count');
                
                console.log('[handlePopState] URL parameters:', {
                    bank: bankParam,
                    state: stateParam,
                    mode: modeParam,
                    practiceMode: practiceModeParam,
                    count: countParam
                });
                
                if (!bankParam && modeParam !== 'cross') {
                    console.log('[handlePopState] No bank parameter and not cross mode, resetting state');
                    this.resetAllState();
                    return;
                }
                
                try {
                    if (modeParam === 'cross') {
                        // 跨卷练习模式
                        if (this.chosenSet?.isCrossPractice) {
                            // 已经在跨卷练习中，保持状态
                            console.log('[handlePopState] Already in cross practice mode');
                            return;
                        }
                        // 否则重置到首页
                        console.log('[handlePopState] Invalid cross practice state, resetting');
                        this.resetAllState();
                        return;
                    }

                    // 普通题库模式
                    const currentFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                    console.log('[handlePopState] Checking bank change:', {
                        current: currentFile,
                        new: bankParam
                    });
                    
                    if (bankParam !== currentFile) {
                        console.log('[handlePopState] Loading new bank data');
                        const data = await this.jsonLoader.loadFile(bankParam);
                        this.chosenSet = data.sets[0];
                        // 更新统计数据
                        await this.loadBankStats(bankParam);
                    }
                    
                    // 根据state参数切换状态
                    if (stateParam) {
                        console.log('[handlePopState] Processing state:', stateParam);
                        switch(stateParam) {
                            case 'quiz':
                                if (modeParam) {
                                    console.log('[handlePopState] Setting up quiz mode:', modeParam);
                                    this.setupQuizMode(modeParam);
                                }
                                break;
                            case 'setDescription':
                                console.log('[handlePopState] Switching to setDescription');
                                this.pageState = 'setDescription';
                                break;
                            default:
                                console.log('[handlePopState] Invalid state, resetting');
                                this.resetAllState();
                        }
                    } else {
                        console.log('[handlePopState] No state parameter, defaulting to setDescription');
                        this.pageState = 'setDescription';
                    }
                } catch (error) {
                    console.error('[handlePopState] Failed to handle popstate:', error);
                    this.resetAllState();
                }
            },

            // 处理 URL 变化
            async handleUrlChange(event) {
                // 避免重复处理 popstate 事件
                if (event.type === 'popstate') {
                    return;
                }

                console.log('[handleUrlChange] URL changed:', {
                    oldURL: event.oldURL,
                    newURL: event.newURL || window.location.href
                });

                await this.handleUrlParams();
            },

            // 更新URL参数，支持qid
            updateUrlParams(state, params = {}) {
                console.log('[updateUrlParams] Updating URL parameters:', {
                    state,
                    params
                });
                
                const url = new URL(window.location.href);
                const oldParams = new URLSearchParams(url.search);
                const oldBank = oldParams.get('bank');
                const oldState = oldParams.get('state');
                
                // 清除现有参数
                url.search = '';
                const newParams = new URLSearchParams();
                
                // 根据状态设置参数
                if (state !== 'home') {
                    // 设置state参数
                    newParams.set('state', state);
                    
                    // 如果有题库，添加bank参数
                    if (this.chosenSet) {
                        const currentFile = this.fileList.find(f => f.name === this.chosenSet.name)?.file;
                        if (currentFile) {
                            newParams.set('bank', currentFile);
                        }
                    }
                    
                    // 如果是quiz状态，添加mode参数
                    if (state === 'quiz' || state === 'orderQuiz' || state === 'randomQuiz') {
                        let mode = 'all';
                        if (state === 'orderQuiz') mode = 'wrong';
                        else if (state === 'randomQuiz') mode = 'random';
                        newParams.set('mode', mode);
                        // 支持qid
                        if (params.qid) {
                            newParams.set('qid', params.qid);
                        } else if (this.practiceManager && this.practiceManager.questions && this.practiceManager.currentIndex != null) {
                            const q = this.practiceManager.questions[this.practiceManager.currentIndex];
                            if (q && q.uniqueId) {
                                newParams.set('qid', q.uniqueId);
                            }
                        }
                    }
                }
                
                // 添加其他参数
                Object.entries(params).forEach(([key, value]) => {
                    if (value && key !== 'qid') {
                        newParams.set(key, value);
                    }
                });
                
                // 检查参数是否真的改变了
                const newBank = newParams.get('bank');
                const newState = newParams.get('state');
                
                if (oldBank !== newBank || oldState !== newState) {
                    // 更新URL，不刷新页面
                    url.search = newParams.toString();
                    window.history.pushState({
                        state,
                        params
                    }, '', url);
                }
            },

            // 重置所有状态
            resetAllState() {
                this.pageState = 'home';
                this.chosenSet = null;
                this.practiceManager?.reset();
                this.resetQuizState();
                this.showExportButton = false;
                this.isEditing = false;
                this.editingField = null;
                this.editingContent = '';
            },

            // 重置答题状态
            resetQuizState() {
                this.chosenAnswer = '';
                this.chosenAnswers = [];
                this.shortAnswerText = '';
                this.fillInAnswers = [];
                this.currentSessionCompleted.clear();
                this.showAnswer = false;
            },
            prevQuestion() {
                if (this.practiceManager && this.practiceManager.currentIndex > 0) {
                    this.practiceManager.currentIndex--;
                    this.showAnswer = false;
                    this.updateUrlParams('quiz', { mode: this.getCurrentMode(), qid: this.practiceManager.questions[this.practiceManager.currentIndex].uniqueId });
                }
            },
            getCurrentMode() {
                if (!this.practiceManager) return 'all';
                if (this.practiceManager.isPreviewMode) return 'preview';
                if (this.practiceManager.mode === 'random') return 'random';
                if (this.practiceManager.mode === 'error-rate') return 'wrong';
                return 'all';
            },
            // 全局Alt+H返回上一级快捷键
            handleGlobalBackShortcut(e) {
                const tag = document.activeElement && document.activeElement.tagName;
                if (tag === 'INPUT' || tag === 'TEXTAREA') return;

                if (e.altKey && (e.key === 'h' || e.key === 'H')) {
                    console.log('[handleGlobalBackShortcut] Alt+H detected, pageState:', this.pageState);
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    switch (this.pageState) {
                        case 'quiz':
                        case 'orderQuiz':
                        case 'randomQuiz':
                            if (!this.isEditing) {
                                console.log('[handleGlobalBackShortcut] Calling goBack() from quiz mode');
                                this.goBack();
                            }
                            break;
                        case 'setDescription':
                            console.log('[handleGlobalBackShortcut] Calling goHome() from setDescription');
                            this.goHome();
                            break;
                        case 'home':
                            // 在首页不做任何操作
                            break;
                    }
                    return false;
                }
            },

            // 返回上一页
            goBack() {
                console.log('[goBack] Called, pageState:', this.pageState, 'isEditing:', this.isEditing);
                if (this.isEditing) {
                    if (this.questionManager.checkUnsavedChanges()) {
                        this.showUnsavedDialog('setDescription');
                        return;
                    } else {
                        this.questionManager.cancelEditing();
                        this.isEditing = false;
                        this.showExportButton = false;
                        this.showAnswer = false; // 退出解析模式
                    }
                }
                
                // 获取当前题库文件名
                const currentFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                console.log('[goBack] Current bank file:', currentFile);
                
                // 返回题库描述页面时保持bank参数
                console.log('[goBack] updatePageState to setDescription');
                this.updatePageState('setDescription', { bank: currentFile });
            },

            // 返回首页
            goHome() {
                console.log('[goHome] Called, pageState:', this.pageState);
                // 清除所有状态和URL参数
                this.chosenSet = null;
                this.questionManager.clearEditHistory();
                this.showExportButton = false;
                this.updatePageState('home');
            },

            // 获取题目所属的题库
            getBankByQuestion(question) {
                return this.filteredBankDistribution.find(
                    bank => bank.questions.some(q => q.uniqueId === question.uniqueId)
                );
            },

            // 开始跨卷练习
            async startCrossPractice() {
                if (!this.canStartCrossPractice) return;
                
                try {
                    this.isLoading = true;
                    
                    // 先加载所有需要的题库
                    const banksToLoad = this.filteredBankDistribution
                        .filter(bank => !this.jsonLoader.loadedBanks.has(bank.file))
                        .map(bank => bank.file);
                    
                    if (banksToLoad.length > 0) {
                        await this.jsonLoader.loadMultipleBanks(banksToLoad);
                    }

                    // 收集所有符合条件的题目
                    let allQuestions = [];
                    this.filteredBankDistribution.forEach(bank => {
                        const bankQuestions = this.jsonLoader.getQuestionsFromBank(bank.file)
                            .filter(q => this.selectedQuestionTypes.includes(q.type));
                        allQuestions = allQuestions.concat(bankQuestions);
                    });

                    if (allQuestions.length === 0) {
                        throw new Error('没有找到符合条件的题目');
                    }

                    if (this.crossPracticeCount > allQuestions.length) {
                        this.crossPracticeCount = allQuestions.length;
                    }

                    // 根据模式排序题目
                    if (this.crossPracticeMode === 'error-rate') {
                        allQuestions.sort((a, b) => {
                            const statsA = this.storageManager.getQuestionStats(this.getBankByQuestion(a).file, a.uniqueId);
                            const statsB = this.storageManager.getQuestionStats(this.getBankByQuestion(b).file, b.uniqueId);
                            const errorRateA = statsA ? 1 - (statsA.correct / statsA.attempts) : 1;
                            const errorRateB = statsB ? 1 - (statsB.correct / statsB.attempts) : 1;
                            return errorRateB - errorRateA;
                        });
                    } else {
                        // 随机模式
                        allQuestions = this.shuffleArray(allQuestions);
                    }

                    // 选择指定数量的题目
                    const selectedQuestions = allQuestions.slice(0, this.crossPracticeCount);

                    // 为每个题目添加来源题库信息
                    const questionsWithSource = selectedQuestions.map(q => ({
                        ...q,
                        sourceBank: this.getBankByQuestion(q).name || '未知题库'
                    }));

                    // 创建虚拟题库集合
                    const virtualSet = {
                        id: 'cross-practice-' + Date.now(),
                        name: '跨卷练习',
                        description: `从${this.filteredBankDistribution.length}个题库中选择的${this.crossPracticeCount}道题目\n\n包含题库：\n${this.filteredBankDistribution.map(bank => `- ${bank.name} (${bank.questionCount}题)`).join('\n')}`,
                        isCrossPractice: true
                    };

                    // 初始化练习
                    this.chosenSet = virtualSet;
                    this.practiceManager.initPractice(questionsWithSource, this.crossPracticeMode);
                    this.showCrossPracticeModal = false;
                    this.updatePageState('quiz', { 
                        mode: 'cross',
                        practiceMode: this.crossPracticeMode,
                        count: this.crossPracticeCount
                    });
                } catch (error) {
                    console.error('Failed to start cross practice:', error);
                    alert(error.message || '启动跨卷练习失败');
                } finally {
                    this.isLoading = false;
                }
            },

            // 数组随机打乱
            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            },

            // 验证题目数量
            handleQuestionInput(event) {
                const rawValue = event.target.value;
                console.log('[handleQuestionInput] Input event:', {
                    type: event.type,
                    rawValue: rawValue,
                    currentCount: this.crossPracticeCount
                });

                let value = parseInt(rawValue);
                
                // 允许输入框暂时为空或大于最大值
                if (rawValue === '' || !isNaN(value)) {
                    this.crossPracticeCount = rawValue;
                }
            },

            // 在失去焦点时验证和更新值
            handleQuestionBlur() {
                console.log('[handleQuestionBlur] Validating value:', this.crossPracticeCount);
                
                let value = parseInt(this.crossPracticeCount);
                if (isNaN(value) || value < 1) {
                    value = 1;
                } else if (value > this.maxQuestionCount) {
                    value = this.maxQuestionCount;
                }
                
                this.crossPracticeCount = value;
                this.updateBankDistribution();
            },

            // 更新题库分布
            updateBankDistribution() {
                console.log('[updateBankDistribution] Updating with count:', this.crossPracticeCount);
                
                const totalRequestedQuestions = this.crossPracticeCount;
                let remainingQuestions = totalRequestedQuestions;
                
                // 首先计算每个题库实际可用的题目数量
                this.filteredBankDistribution.forEach(bank => {
                    const bankQuestions = this.jsonLoader.getQuestionsFromBank(bank.file)
                        .filter(q => this.selectedQuestionTypes.includes(q.type));
                    bank.availableQuestions = bankQuestions.length;
                    console.log(`[updateBankDistribution] Bank ${bank.name} has ${bank.availableQuestions} available questions`);
                });

                // 根据策略计算每个题库的题目数
                if (this.crossPracticeStrategy === 'error-rate') {
                    // 根据错误率和可用题目数分配
                    let totalWeight = 0;
                    this.filteredBankDistribution.forEach(bank => {
                        const errorRate = 1 - (bank.stats.accuracy || 0) / 100;
                        bank.weight = errorRate * bank.availableQuestions;
                        totalWeight += bank.weight;
                    });

                    this.filteredBankDistribution.forEach(bank => {
                        const proportion = bank.weight / totalWeight;
                        bank.questionCount = Math.min(
                            Math.round(totalRequestedQuestions * proportion),
                            bank.availableQuestions
                        );
                        remainingQuestions -= bank.questionCount;
                    });
                } else {
                    // 平均分配题目，但考虑每个题库的可用题目数
                    const banksWithQuestions = this.filteredBankDistribution.filter(bank => bank.availableQuestions > 0);
                    let avgQuestions = Math.floor(remainingQuestions / banksWithQuestions.length);

                    this.filteredBankDistribution.forEach(bank => {
                        if (bank.availableQuestions > 0) {
                            bank.questionCount = Math.min(avgQuestions, bank.availableQuestions);
                            remainingQuestions -= bank.questionCount;
                        } else {
                            bank.questionCount = 0;
                        }
                    });
                }

                // 处理剩余的题目（分配给还有可用题目的题库）
                if (remainingQuestions > 0) {
                    for (let bank of this.filteredBankDistribution) {
                        const canAddMore = bank.availableQuestions - bank.questionCount;
                        if (canAddMore > 0) {
                            const toAdd = Math.min(remainingQuestions, canAddMore);
                            bank.questionCount += toAdd;
                            remainingQuestions -= toAdd;
                            if (remainingQuestions === 0) break;
                        }
                    }
                }

                // 如果总的可用题目数小于请求的题目数，更新 crossPracticeCount
                const totalAvailable = this.filteredBankDistribution.reduce((sum, bank) => sum + bank.questionCount, 0);
                if (totalAvailable < totalRequestedQuestions) {
                    console.log(`[updateBankDistribution] Adjusting requested count from ${totalRequestedQuestions} to ${totalAvailable} due to availability`);
                    this.crossPracticeCount = totalAvailable;
                }

                console.log('[updateBankDistribution] Updated distribution:', this.filteredBankDistribution);
            },
            backToHome() {
                if (this.showAnswer || confirm('确定要退出练习吗？当前进度将不会保存。')) {
                    this.updatePageState('home');
                }
            },
        }
    });

    app.mount('#app');
</script>

<style>
.fill-blank-item {
    margin: 10px 0;
}
.question-content, .option-content, .analysis {
    cursor: pointer;
}
.question-content:hover, .option-content:hover, .analysis:hover {
    background-color: rgba(0, 0, 0, 0.05);
}
.edit-textarea {
    width: 100%;
    padding: 8px;
    font-family: monospace;
    border: 1px solid #ddd;
    border-radius: 4px;
}
.edit-input {
    width: calc(100% - 30px);
    padding: 4px 8px;
    font-family: monospace;
    border: 1px solid #ddd;
    border-radius: 4px;
}
.option-edit {
    display: flex;
    align-items: center;
    width: 100%;
}
.action-button {
    display: inline-flex;
    align-items: center;
    padding: 4px 8px;
    border-radius: 4px;
    background: #f5f5f5;
    border: 1px solid #ddd;
    cursor: pointer;
    font-size: 14px;
    color: #666;
    margin-left: 8px;
}
.action-button:hover {
    background: #e8e8e8;
}
.action-button svg {
    width: 16px;
    height: 16px;
    margin-right: 4px;
}
.preview-mode {
    color: #B0C1A2;
    font-weight: bold;
}
.header-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}
.back-button {
    display: inline-flex;
    align-items: center;
    padding: 4px 8px;
    border-radius: 4px;
    background: #f5f5f5;
    border: 1px solid #ddd;
    cursor: pointer;
    font-size: 14px;
    color: #666;
    margin-right: 12px;
}
.back-button:hover {
    background: #e8e8e8;
}
.back-button svg {
    width: 16px;
    height: 16px;
    margin-right: 4px;
}
.progress-text {
    margin-left: 16px;
    color: #666;
    font-size: 14px;
}
.action-buttons {
    display: flex;
    gap: 8px;
}
.question-header {
    margin-bottom: 16px;
}
.editable {
    cursor: pointer;
}
.editable:hover {
    background-color: rgba(0, 0, 0, 0.05);
}
.stats-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
    margin-top: 15px;
}

.stats-item {
    padding: 15px;
    border-radius: 8px;
    background-color: #f5f5f5;
    text-align: center;
}

.stats-value {
    font-size: 24px;
    font-weight: bold;
    color: var(--theme-color);
    margin-bottom: 5px;
}

.stats-label {
    font-size: 14px;
    color: #666;
}

.stats-title {
    font-size: 18px;
    color: #333;
    margin-bottom: 10px;
}

.overall-stats {
    margin-bottom: 8px;
    padding: 15px;
    background: #fff;
    border-radius: 8px;
}

.quiz-item {
    background: white;
    border-radius: 8px;
    padding: 15px;
    margin: 10px;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
    flex: 1;
    min-width: 280px;
    max-width: 400px;
}

.quiz-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.quiz-item-content {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.quiz-item-title {
    font-size: 16px;
    color: #333;
    margin-bottom: 4px;
}

.quiz-item-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin: 4px 0;
}

.item-tag {
    font-size: 12px;
    padding: 2px 8px;
    border-radius: 12px;
    background-color: var(--theme-color-light);
    color: var(--theme-color);
    border: 1px solid var(--theme-color);
    display: inline-block;
}

.quiz-item-stats {
    display: flex;
    gap: 12px;
    font-size: 13px;
    color: #666;
    margin-top: 4px;
}

.quiz-stat {
    display: flex;
    align-items: center;
    gap: 4px;
}

.stats-details {
    font-size: 14px;
    color: #666;
    margin-top: 10px;
    padding: 10px;
    background: #f9f9f9;
    border-radius: 6px;
}

.set-stats {
    margin: 20px 0;
    padding: 15px;
    background: #f5f5f5;
    border-radius: 8px;
}

.empty-analysis {
    padding: 15px;
    border: 2px dashed #ddd;
    border-radius: 4px;
    color: #999;
    text-align: center;
    margin: 10px 0;
    font-size: 14px;
}

.empty-analysis.editable:hover {
    background-color: rgba(33, 150, 243, 0.05);
    border-color: #B0C1A2;
    color: #B0C1A2;
    cursor: pointer;
}

.stats-sublabel {
    font-size: 12px;
    color: #666;
    margin-top: 2px;
}

.stats-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
}

.question-stats {
    margin: 15px 0;
    padding: 15px;
    background: #f5f5f5;
    border-radius: 8px;
}

.question-stats h4 {
    margin: 0 0 10px 0;
    color: #333;
}

.status-indicator {
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 12px;
    margin-left: 8px;
}

.status-indicator.correct {
    background-color: #4caf50;
    color: white;
}

.status-indicator.incorrect {
    background-color: #f44336;
    color: white;
}

.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.modal-content {
    background-color: white;
    padding: 24px;
    border-radius: 8px;
    min-width: 400px;
    max-width: 80%;
    max-height: 80vh;
    overflow-y: auto;
}

.modal-content h2 {
    margin: 0 0 20px 0;
    color: #333;
    font-size: 1.5em;
}

.tags-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 12px;
    margin: 0 0 24px 0;
    padding: 4px;
}

.modal-footer {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-top: 24px;
    border-top: 1px solid #eee;
    padding-top: 24px;
}

.btn {
    padding: 10px 20px;
    border-radius: 4px;
    border: 1px solid transparent;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.3s ease;
    width: 100%;
    text-align: center;
}

.btn-clear {
    background-color: #f5f5f5;
    color: #666;
    border-color: #ddd;
}

.btn-clear:hover {
    background-color: #eee;
}

.btn-close {
    background-color: var(--theme-color, #B0C1A2);
    color: white;
    border-color: var(--theme-color, #B0C1A2);
}

.btn-close:hover {
    opacity: 0.9;
}

.btn.primary {
    background-color: var(--theme-color, #B0C1A2);
    color: white;
    border-color: var(--theme-color, #B0C1A2);
}

.btn.primary:hover {
    opacity: 0.9;
}

.tag-chip {
    padding: 6px 12px;
    border-radius: 16px;
    background-color: #f5f5f5;
    color: #666;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.3s ease;
    white-space: nowrap;
    border: 1px solid transparent;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    user-select: none;
}

.tag-chip:hover {
    background-color: #eee;
}

.tag-chip.active {
    background-color: var(--theme-color-light, rgba(176, 193, 162, 0.1));
    color: var(--theme-color, #B0C1A2);
    border-color: var(--theme-color, #B0C1A2);
}

.tags-button {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: #f5f5f5;
    border: 1px solid transparent;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    color: #666;
}

.tags-button:hover, .tags-button.has-active {
    background-color: var(--theme-color-light, rgba(176, 193, 162, 0.1));
    color: var(--theme-color, #B0C1A2);
    border-color: var(--theme-color, #B0C1A2);
}

.item-tag {
    font-size: 12px;
    padding: 2px 8px;
    border-radius: 12px;
    background-color: var(--theme-color-light);
    color: var(--theme-color);
    border: 1px solid var(--theme-color);
    display: inline-block;
}

.modal-footer {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 20px;
}

.quiz-item-tags {
    margin: 4px 0;
}

:root {
    --theme-color: #B0C1A2;
    --theme-color-light: rgba(176, 193, 162, 0.1);
}

.banner {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    padding: 10px;
    background-color: var(--theme-color);
    color: white;
    display: flex;
    justify-content: space-between;
    align-items: center;
    z-index: 1000;
}

.banner-content {
    flex: 1;
}

.banner-close {
    background: none;
    border: none;
    color: white;
    font-size: 16px;
    cursor: pointer;
}

.category-header {
    width: 100%;
    margin-top: 20px;
    margin-bottom: 10px;
}

.category-header h2 {
    font-size: 1.5em;
    color: #333;
    margin-bottom: 5px;
}

.category-header hr {
    border: none;
    height: 1px;
    background-color: #ddd;
    margin: 5px 0;
}

.tags-filter {
    position: fixed;
    right: 20px;
    top: 100px;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 10px;
    z-index: 100;
    background-color: rgba(255, 255, 255, 0.9);
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.top-tags {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.loading-text {
    text-align: center;
    padding: 20px;
    color: #666;
    font-size: 14px;
    margin: 0;
}

.card {
    background: white;
    border-radius: 8px;
    padding: 20px;
    margin: 20px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.card.loading {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 200px;
}

.empty-state {
    text-align: center;
    padding: 40px;
    color: #666;
    font-size: 14px;
    background: #f5f5f5;
    border-radius: 8px;
    margin: 20px;
}

.cross-practice-btn {
    width: 100%;
    margin-top: 15px;
    padding: 10px;
    background-color: var(--theme-color);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    font-size: 16px;
    transition: all 0.3s ease;
}

.cross-practice-btn:hover {
    opacity: 0.9;
}

.cross-practice-modal {
    max-width: 600px;
    width: 90%;
}

.setting-section {
    margin-bottom: 24px;
}

.setting-section h3 {
    margin-bottom: 12px;
    color: #333;
    font-size: 16px;
}

.question-types {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 12px;
}

.type-checkbox {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
}

.practice-mode {
    display: flex;
    gap: 24px;
}

.mode-radio {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
}

.question-count {
    display: flex;
    align-items: center;
    gap: 12px;
}

.count-input {
    width: 100px;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
}

.max-count {
    color: #666;
    font-size: 14px;
    transition: color 0.3s ease;
}

.max-count.error {
    color: #f44336;
}

.bank-distribution {
    max-height: 200px;
    overflow-y: auto;
    margin-top: 12px;
}

.bank-item {
    padding: 12px;
    border: 1px solid #eee;
    border-radius: 4px;
    margin-bottom: 8px;
}

.bank-name {
    font-weight: bold;
    margin-bottom: 4px;
}

.bank-count {
    color: #666;
    font-size: 14px;
    margin-bottom: 8px;
}

.bank-progress {
    height: 4px;
    background-color: #eee;
    border-radius: 2px;
    overflow: hidden;
}

.progress-bar {
    height: 100%;
    background-color: var(--theme-color);
    transition: width 0.3s ease;
}
</style>
</body>
</html>