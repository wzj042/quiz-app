<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <title>刷题</title>
    <meta name="referrer" content="no-referrer">
    <link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/katex.min.css">
    <script defer src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/katex.min.js"></script>
    <script defer src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/contrib/auto-render.min.js"></script>
    <script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vue/3.2.23/vue.global.prod.min.js"></script>
    <script src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/marked/4.0.2/marked.min.js"></script>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/mobile.css">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
</head>
<body>
<div id="app" class="container">
    <!-- 未保存修改的模态窗口 -->
    <div v-if="showUnsavedModal" class="modal-overlay" @click.self="closeUnsavedModal">
        <div class="modal-content">
            <h3>未导出的修改</h3>
            <div class="modal-body">
                <p>当前题库有未导出的修改：</p>
                <div class="modified-questions-list">
                    <ul>
                        <li v-for="q in groupedModifiedQuestions" :key="q.uniqueId">
                            题目ID: {{ q.uniqueId }}
                            <br>
                            <span class="question-preview">{{ truncateText(q.content, 50) }}</span>
                        </li>
                    </ul>
                </div>
                <div class="modal-actions">
                    <div class="action-buttons">
                        <button class="btn export-btn" @click="exportModifiedData">
                            导出修改
                        </button>
                        <button class="btn close-btn" @click="closeUnsavedModalAndContinue">
                            直接退出
                        </button>
                    </div>
                    <label class="dont-show-again">
                        <input type="checkbox" v-model="dontShowExportReminder">
                        <span>不再提醒</span>
                    </label>
                </div>
            </div>
        </div>
    </div>

    <!-- 导航栏 -->
    <div class="nav">
        <a href="#" class="nav-title-link" @click="goHome" @mouseover="hoverTitle = true" @mouseout="hoverTitle = false">
            <span class="nav-title">Quiz App</span>
        </a>
        <a href="https://github.com/wzj042/quiz-app" class="github-link" target="_blank" rel="noopener noreferrer" 
            title="项目调试中，欢迎参与开发和反馈。可参考 demo.json 格式，Fork 项目后添加自己的题库。">
            <svg class="github-icon" viewBox="0 0 16 16" width="24" height="24">
                <path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
            </svg>
        </a>
    </div>

    <!-- 列出题库 -->
    <div v-if="pageState === 'home'" class="card">
        <h1 class="title">
            选择题库
            <span class="update-time" v-if="updateTime">更新于: {{ formatUpdateTime(updateTime) }}</span>
        </h1>
        <!-- 加载状态 -->
        <div v-if="isLoading" class="loading-state">
            正在加载题库列表...
        </div>
        <!-- 错误状态 -->
        <div v-else-if="loadError" class="error-state">
            加载失败: {{ loadError }}
            <button @click="loadBankList" class="btn">重试</button>
        </div>
        <!-- 总体统计 -->
        <div v-else class="overall-stats">
            <div class="stats-title">总体统计</div>
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="stats-value">{{ totalStats.totalCompleted }}/{{ totalStats.totalQuestions }}</div>
                    <div class="stats-label">总完成题数</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value">{{ totalStats.averageAccuracy }}%</div>
                    <div class="stats-label">平均正确率</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value">{{ totalStats.todayPracticed }}</div>
                    <div class="stats-label">今日已练习</div>
                </div>
            </div>
        </div>
        <!-- 题库列表 -->
        <ul v-else class="horizontal-list">
            <li
                v-for="(fileObj, idx) in fileList"
                :key="idx"
                class="quiz-item"
                @click="loadJsonFile(fileObj.file)"
            >
                <div class="quiz-item-content">
                    <div class="quiz-item-title">{{ fileObj.name }}</div>
                    <div class="quiz-item-stats" v-if="getBankStats(fileObj.file)">
                        <div class="quiz-stat">
                            完成：{{ getBankStats(fileObj.file).completed }}/{{ getBankStats(fileObj.file).total }}
                        </div>
                        <div class="quiz-stat">
                            正确率：{{ getBankStats(fileObj.file).accuracy }}%
                        </div>
                    </div>
                </div>
            </li>
        </ul>
        <!-- 如果列表为空 -->
        <div v-if="!isLoading && !loadError && fileList.length === 0" class="empty-state">
            没有找到可用的题库
        </div>
    </div>

    <!-- 题库详情页面 -->
    <div v-else-if="pageState === 'setDescription'" class="card">
        <h1 class="title">{{ chosenSet.name }}</h1>
        <p v-if="chosenSet.description" style="white-space: pre-wrap;" v-html="renderMarkdown(chosenSet.description)"></p>
        
        <!-- 题库统计信息 -->
        <div class="set-stats">
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="stats-value">{{ setStats.completedQuestions }}/{{ setStats.totalQuestions }}</div>
                    <div class="stats-label">已练习题数</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value">{{ setStats.averageAccuracy }}%</div>
                    <div class="stats-label">平均正确率</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value">{{ setStats.todayDistinctQuestions }}</div>
                    <div class="stats-label">今日练习题数</div>
                    <div class="stats-sublabel">正确: {{ setStats.todayCorrect }}</div>
                </div>
            </div>
            <div class="stats-details">
                <div class="stats-row">
                    <span class="stats-label">总练习次数：</span>
                    <span class="stats-value">{{ setStats.totalAttempts }}次</span>
                </div>
                <div class="stats-row">
                    <span class="stats-label">不同题目数：</span>
                    <span class="stats-value">{{ setStats.distinctQuestionCount }}题</span>
                </div>
                <div class="stats-row">
                    <span class="stats-label">总正确次数：</span>
                    <span class="stats-value">{{ setStats.totalCorrect }}次</span>
                </div>
                <div class="stats-row">
                    <span class="stats-label">总错误次数：</span>
                    <span class="stats-value">{{ setStats.totalIncorrect }}次</span>
                </div>
                <div class="stats-row">
                    <span class="stats-label">完成率：</span>
                    <span class="stats-value">{{ setStats.completionRate }}%</span>
                </div>
            </div>
        </div>

        <!-- 当前题目统计 -->
        <div v-if="currentQuestion && !isPreviewMode" class="question-stats">
            <h4>当前题目统计</h4>
            <div class="stats-details">
                <div class="stats-row" v-if="questionStats">
                    <span class="stats-label">练习次数：</span>
                    <span class="stats-value">{{ questionStats.totalAttempts }}次</span>
                </div>
                <div class="stats-row" v-if="questionStats">
                    <span class="stats-label">正确次数：</span>
                    <span class="stats-value">{{ questionStats.correctCount }}次</span>
                </div>
                <div class="stats-row" v-if="questionStats">
                    <span class="stats-label">错误次数：</span>
                    <span class="stats-value">{{ questionStats.incorrectCount }}次</span>
                </div>
                <div class="stats-row" v-if="questionStats">
                    <span class="stats-label">连续正确：</span>
                    <span class="stats-value">{{ questionStats.consecutiveCorrect }}次</span>
                </div>
                <div class="stats-row" v-if="questionStats && questionStats.lastAttemptDate">
                    <span class="stats-label">上次练习：</span>
                    <span class="stats-value">{{ formatDate(questionStats.lastAttemptDate) }}</span>
                    <span :class="['status-indicator', questionStats.lastCorrect ? 'correct' : 'incorrect']">
                        {{ questionStats.lastCorrect ? '正确' : '错误' }}
                    </span>
                </div>
            </div>
        </div>

        <div style="margin-top: 20px;">
            <button type="button" class="btn" @click="enterQuizMode">顺序答题</button>
            <button type="button" class="btn" @click="enterOrderQuizMode" style="margin-left: 10px;">
                按错误率答题
            </button>
            <button type="button" class="btn" @click="enterRandomQuizMode" style="margin-left: 10px;">
                随机答题
            </button>
            <button type="button" class="btn" @click="enterPreviewMode" style="margin-left: 10px;">
                预览模式
            </button>
        </div>
    </div>

    <!-- 题目页面 -->
    <div v-else-if="pageState === 'quiz' || pageState === 'orderQuiz' || pageState === 'randomQuiz'" class="card">
        <div class="question-header">
            <div class="header-row">
                <button class="back-button" @click="goBack">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 12H5M12 19l-7-7 7-7"/>
                    </svg>
                    返回
                </button>
                <h1 class="title">
                    第 {{ currentIndex + 1 }} / {{ quizList.length }} 题
                    <span style="font-size: 14px; color:#888">
                        [ {{ currentQuestion.type }} ]
                    </span>
                    <span v-if="isPreviewMode" class="preview-mode">
                        [预览模式]
                    </span>
                </h1>
            </div>
            <div class="header-row">
                <div class="question-id">
                    题目 ID: {{ currentQuestion.uniqueId }}
                    <span v-if="!isPreviewMode" class="progress-text">{{ progressText }}</span>
                </div>
                <div class="action-buttons">
                    <span class="action-button" @click="editQuestion" v-if="!isEditing">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                        </svg>
                        编辑{{ modifiedCount ? ` (${modifiedCount})` : '' }}
                    </span>
                    <span class="action-button" @click="exitEditMode" v-if="isEditing">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M5 13l4 4L19 7"></path>
                        </svg>
                        完成
                    </span>
                    <span class="action-button" @click="exportModifiedData" v-if="showExportButton">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="7 10 12 15 17 10"></polyline>
                            <line x1="12" y1="15" x2="12" y2="3"></line>
                        </svg>
                        导出题库
                    </span>
                </div>
            </div>
        </div>

        <!-- 题目内容 -->
        <div 
            v-if="!isEditing || editingField !== 'content'"
            @click="isEditing && !isPreviewMode ? enterEditMode('content', currentQuestion.content) : null"
            class="question-content"
            :class="{ 'editable': !isPreviewMode && isEditing }"
            v-html="renderedContent"
        ></div>
        <textarea
            v-else-if="editingField === 'content'"
            v-model="editingContent"
            @blur="exitEditMode"
            class="edit-textarea"
            rows="8"
        ></textarea>

        <!-- 选项 -->
        <div v-if="currentQuestion.type === 'single-choice' || currentQuestion.type === 'multiple-choice'">
            <label
                v-for="(opt, idx) in currentQuestion.options"
                :key="idx"
                class="option-item"
                :class="{
                    'green': showAnswer && (currentQuestion.type === 'single-choice' ? isCorrectOptionSingle(opt) : isCorrectOptionMulti(opt)),
                    'red': showAnswer && (currentQuestion.type === 'single-choice' ? 
                        (isChosenOptionSingle(opt) && !isCorrectOptionSingle(opt)) : 
                        (chosenAnswers.includes(opt) && !isCorrectOptionMulti(opt))),
                    'editable': !isPreviewMode
                }"
            >
                <input
                    :type="currentQuestion.type === 'single-choice' ? 'radio' : 'checkbox'"
                    :name="currentQuestion.type === 'single-choice' ? 'single-choice-' + currentQuestion.uniqueId : ''"
                    :value="opt"
                    :checked="currentQuestion.type === 'single-choice' ? chosenAnswer === opt : chosenAnswers.includes(opt)"
                    @change="handleOptionChange(opt, currentQuestion.type === 'single-choice')"
                    :disabled="showAnswer || isEditing || isPreviewMode"
                    style="margin-right: 6px;"
                >
                <div class="option-content" v-if="!isEditing || editingField !== `option-${idx}`">
                    <strong>{{ letterMap[idx] }}. </strong>
                    <span 
                        v-html="renderMarkdownWithLatex(opt)"
                        @click="isEditing && !isPreviewMode ? enterEditMode(`option-${idx}`, opt) : null"
                    ></span>
                </div>
                <div v-else class="option-edit">
                    <strong>{{ letterMap[idx] }}. </strong>
                    <input
                        type="text"
                        v-model="editingContent"
                        @blur="exitEditMode"
                        class="edit-input"
                    >
                </div>
            </label>
        </div>

        <div v-else-if="currentQuestion.type === 'short-answer'">
            <!-- 简答题 -->
            <textarea
                v-model="shortAnswerText"
                :disabled="showAnswer"
                rows="4"
                style="width: 100%; padding: 8px;"
                placeholder="请输入你的答案"
            ></textarea>
        </div>

        <div v-else-if="currentQuestion.type === 'fill-in-blank'">
            <!-- 填空题 -->
            <div v-for="(blank, idx) in currentQuestion.blanks" :key="idx" class="fill-blank-item">
                <label :for="'blank-'+idx">空{{idx + 1}}：</label>
                <input
                    :id="'blank-'+idx"
                    type="text"
                    v-model="fillInAnswers[idx]"
                    :disabled="showAnswer"
                    style="width: 200px; padding: 4px 8px; margin: 4px 0;"
                    :placeholder="'请填写空'+(idx+1)"
                >
                <span v-if="showAnswer" style="margin-left: 10px; color: #666;">
                    正确答案：{{ currentQuestion.correct_answer[idx] }}
                </span>
            </div>
        </div>

        <!-- 提交答案 / 下一题 按钮 -->
        <div style="margin-top: 12px;">
            <button
                type="button"
                v-if="!showAnswer"
                class="btn"
                @click="submitAnswer"
            >
                提交答案 (空格)
            </button>
            <button
                type="button"
                v-else
                class="btn"
                @click="nextQuestion"
            >
                下一题 (空格)
            </button>
        </div>

        <!-- 解析 -->
        <div v-if="showAnswer" class="analysis">
            <h3>解析</h3>
            <div 
                v-if="(!isEditing || editingField !== 'analysis') && currentQuestion.analysis"
                @click="isEditing && !isPreviewMode ? enterEditMode('analysis', currentQuestion.analysis) : null"
                v-html="renderedAnalysis"
                :class="{ 'editable': isEditing && !isPreviewMode }"
            ></div>
            <div 
                v-if="(!isEditing || editingField !== 'analysis') && !currentQuestion.analysis"
                @click="isEditing && !isPreviewMode ? enterEditMode('analysis', '') : null"
                class="empty-analysis"
                :class="{ 'editable': isEditing && !isPreviewMode }"
            >
                点击添加解析
            </div>
            <textarea
                v-else-if="editingField === 'analysis'"
                v-model="editingContent"
                @blur="exitEditMode"
                class="edit-textarea"
                rows="6"
                placeholder="请输入解析内容..."
            ></textarea>
        </div>

        <p style="font-size:13px; color:#666; margin-top:8px;">
            键盘：1~4 选项，空格提交/下一题，Shift+C切换解析
        </p>
    </div>

    <!-- 5) result: 最终结果 -->
    <div v-else-if="pageState === 'result'" class="card">
        <h1 class="title">答题完成</h1>
        <p>本轮共 {{ quizList.length }} 题，已完成：{{ completedCount }}。</p>
        <button type="button" class="btn" @click="pageState = 'home'">
            返回题目选择 (空格)
        </button>
    </div>

    <!-- 其他情况 -->
    <div v-else class="card">
        <p>正在处理，请稍后...</p>
    </div>
</div>

<script type="module">
    import StorageManager from './js/modules/storage.js';
    import JsonLoader from './js/modules/jsonLoader.js';
    import KeyboardManager from './js/modules/keyboard.js';
    import QuestionManager from './js/modules/QuestionManager.js';
    import PracticeManager from './js/modules/PracticeManager.js';

    const app = Vue.createApp({
        data() {
            return {
                storageManager: new StorageManager(),
                jsonLoader: null,
                keyboardManager: null,
                questionManager: null,
                practiceManager: null,
                pageState: 'home',
                isLoading: false,
                loadError: null,
                fileList: [],
                chosenSet: null,
                showAnswer: false,
                isEditing: false,
                editingField: null,
                editingContent: '',
                showExportButton: false,
                chosenAnswer: '',
                chosenAnswers: [],
                shortAnswerText: '',
                fillInAnswers: [],
                currentSessionCompleted: new Set(),
                modifiedCount: 0,
                showUnsavedModal: false,
                dontShowExportReminder: false,
                groupedModifiedQuestions: {},
                lastExportTimestamp: null,
                updateTime: null
            }
        },
        async created() {
            // 初始化各个管理器
            this.jsonLoader = new JsonLoader();
            this.keyboardManager = new KeyboardManager(this);
            this.questionManager = new QuestionManager(this.storageManager);
            this.practiceManager = new PracticeManager(this.storageManager);

            // 加载题库列表
            await this.loadBankList();
        },
        computed: {
            currentQuestion() {
                return this.practiceManager?.getCurrentQuestion() || null;
            },
            currentIndex() {
                return this.practiceManager?.currentIndex || 0;
            },
            quizList() {
                return this.practiceManager?.questions || [];
            },
            isPreviewMode() {
                return this.practiceManager?.isPreviewMode || false;
            },
            totalStats() {
                return this.storageManager.getAllBanksStats();
            },
            setStats() {
                if (!this.chosenSet) return null;
                const stats = this.storageManager.getSetStats(this.chosenSet.id, this.jsonLoader.questions);
                const today = new Date().toISOString().split('T')[0];
                
                // 获取今日练习题数
                const todayCount = this.jsonLoader.questions.reduce((count, q) => {
                    const completion = this.storageManager.getQuestionCompletion(this.chosenSet.id, q.uniqueId);
                    if (completion && completion.lastAttemptDate === today) {
                        return count + 1;
                    }
                    return count;
                }, 0);

                return {
                    ...stats,
                    todayCount,
                    accuracy: stats.totalAttempts > 0 
                        ? Math.round((stats.totalAttempts - stats.totalErrors) / stats.totalAttempts * 100) 
                        : 0
                };
            },
            renderedContent() {
                if (!this.currentQuestion.content) return '';
                return this.renderMarkdownWithLatex(this.currentQuestion.content);
            },
            renderedAnalysis() {
                if (!this.currentQuestion.analysis) return '';
                return this.renderMarkdownWithLatex(this.currentQuestion.analysis);
            },
            progressText() {
                return `本次练习完成度：${this.currentSessionCompleted.size}/${this.quizList.length}`;
            },
            completedCount() {
                return this.currentSessionCompleted.size;
            },
            letterMap() {
                return ['A','B','C','D','E','F'];
            },
            hoverTitle() {
                return false;
            },
            hasChanges() {
                return false;
            },
            changesExported() {
                return false;
            },
            questionStats() {
                if (!this.chosenSet || !this.currentQuestion) return null;
                return this.storageManager.getQuestionStats(
                    this.chosenSet.id,
                    this.currentQuestion.uniqueId
                );
            }
        },
        watch: {
            chosenAnswer: {
                handler(newVal, oldVal) {
                    console.log('chosenAnswer changed:', {
                        newValue: newVal,
                        oldValue: oldVal,
                        questionId: this.currentQuestion?.uniqueId,
                        timestamp: new Date().toISOString()
                    });
                },
                immediate: true
            }
        },
        methods: {
            // 加载题库列表
            async loadBankList() {
                this.isLoading = true;
                this.loadError = null;
                try {
                    const response = await fetch('assets/list.json');
                    const data = await response.json();
                    this.fileList = data.banks || [];
                    this.updateTime = data.updateTime;
                } catch (error) {
                    console.error('Error loading file list:', error);
                    this.loadError = error.message;
                }
                this.isLoading = false;
            },

            // 加载题库文件
            async loadJsonFile(fileName) {
                if (this.isLoading) return;
                this.isLoading = true;
                try {
                    const data = await this.jsonLoader.loadFile(fileName);
                    this.chosenSet = data.sets[0];
                    this.updatePageState('setDescription');
                } catch (error) {
                    console.error('加载题库失败:', error);
                    alert('加载题库失败: ' + error.message);
                } finally {
                    this.isLoading = false;
                }
            },

            // 进入练习模式
            enterQuizMode() {
                this.practiceManager.initPractice(this.jsonLoader.questions, 'sequence');
                this.practiceManager.togglePreviewMode(false);
                this.showAnswer = false;
                this.currentSessionCompleted.clear();
                this.updatePageState('quiz');
            },

            enterOrderQuizMode() {
                this.practiceManager.initPractice(this.jsonLoader.questions, 'error-rate');
                this.practiceManager.togglePreviewMode(false);
                this.showAnswer = false;
                this.currentSessionCompleted.clear();
                this.updatePageState('orderQuiz');
            },

            enterRandomQuizMode() {
                this.practiceManager.initPractice(this.jsonLoader.questions, 'random');
                this.practiceManager.togglePreviewMode(false);
                this.showAnswer = false;
                this.currentSessionCompleted.clear();
                this.updatePageState('randomQuiz');
            },

            enterPreviewMode() {
                this.practiceManager.initPractice(this.jsonLoader.questions, 'sequence');
                this.practiceManager.togglePreviewMode(true);
                this.showAnswer = true;
                this.updatePageState('quiz');
            },

            // 编辑相关方法
            editQuestion() {
                if (this.isPreviewMode) return;
                console.log('Starting edit mode for question:', this.currentQuestion);
                this.questionManager.startEditing(this.currentQuestion);
                this.isEditing = true;
                this.showExportButton = true;
                // 自动切换到解析模式
                this.showAnswer = true;
            },

            enterEditMode(field, content) {
                if (this.isPreviewMode) return;
                console.log('Entering edit mode:', {
                    field,
                    content,
                    currentContent: content || '点击编辑'
                });
                this.editingField = field;
                this.editingContent = content || '';
            },

            exitEditMode() {
                console.log('Exiting edit mode:', {
                    field: this.editingField,
                    content: this.editingContent,
                    question: this.currentQuestion
                });
                
                if (this.editingField && this.editingContent !== undefined) {
                    const question = this.currentQuestion;
                    if (this.editingField === 'content') {
                        question.content = this.editingContent;
                    } else if (this.editingField === 'analysis') {
                        question.analysis = this.editingContent;
                    } else if (this.editingField.startsWith('option-')) {
                        const idx = parseInt(this.editingField.split('-')[1]);
                        question.options[idx] = this.editingContent;
                    }
                    this.questionManager.saveCurrentEdit();
                    // 更新修改计数
                    this.modifiedCount = this.questionManager.getModifiedQuestions().length;
                }
                this.editingField = null;
                this.editingContent = '';
                this.isEditing = false;
                this.showAnswer = false; // 退出解析模式
            },

            // 导出相关方法
            handleExport(questions) {
                const exportData = {
                    questions: questions,
                    sets: [this.chosenSet]
                };

                const blob = new Blob([JSON.stringify(exportData, null, 4)], 
                    { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                // 从fileList中获取当前题库的文件名
                const currentFile = this.fileList.find(f => f.name === this.chosenSet.name)?.file;
                a.download = this.questionManager.generateExportFileName(currentFile || 'export');
                a.click();
                URL.revokeObjectURL(url);

                // 更新导出状态
                this.lastExportTimestamp = Date.now();
                this.modifiedCount = 0;
                this.questionManager.clearModifiedQuestions();
                this.showExportButton = false;
                this.isEditing = false;
                this.showUnsavedModal = false;
            },

            // 导出修改
            exportModifiedData() {
                const modifiedQuestions = this.questionManager.getModifiedQuestions();
                const questions = this.jsonLoader.questions.map(q => {
                    if (modifiedQuestions.includes(q.uniqueId)) {
                        return { ...q };
                    }
                    return q;
                });
                this.handleExport(questions);
            },

            // 状态更新
            updatePageState(newState) {
                // 如果有未导出的修改，且不是刚刚导出的，且不是在编辑模式中
                if (this.modifiedCount > 0 && !this.dontShowExportReminder && 
                    (!this.lastExportTimestamp || Date.now() - this.lastExportTimestamp > 1000) &&
                    !this.isEditing) {
                    const hasUnsaved = this.checkModifiedQuestions();
                    if (hasUnsaved) {
                        return;
                    }
                }
                
                if (this.isEditing && this.questionManager.checkUnsavedChanges()) {
                    this.showUnsavedDialog(newState);
                    return;
                }
                
                this.pageState = newState;
                if (newState === 'home') {
                    this.questionManager.clearEditHistory();
                    this.showExportButton = false;
                }
            },

            showUnsavedDialog(newState) {
                const dialog = document.createElement('div');
                dialog.className = 'modal-overlay';
                dialog.innerHTML = `
                    <div class="modal-content" style="padding: 20px; max-width: 400px;">
                        <h3 style="margin-top: 0;">未保存的修改</h3>
                        <p>当前题目有未保存的修改，请选择操作：</p>
                        <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                            <button class="btn" id="continueEdit" style="background-color: #B0C1A2;">继续编辑</button>
                            <button class="btn" id="saveAndExit" style="background-color: #91a881;">保存并退出</button>
                            <button class="btn" id="discardAndExit" style="background-color: #d32f2f;">放弃修改</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(dialog);

                // 点击遮罩层关闭对话框（继续编辑）
                dialog.addEventListener('click', (e) => {
                    if (e.target === dialog) {
                        document.body.removeChild(dialog);
                    }
                });

                // 继续编辑
                dialog.querySelector('#continueEdit').addEventListener('click', () => {
                    document.body.removeChild(dialog);
                });

                // 保存并退出
                dialog.querySelector('#saveAndExit').addEventListener('click', () => {
                    this.questionManager.saveCurrentEdit();
                    this.isEditing = false;
                    this.showExportButton = false;
                    this.pageState = newState;
                    if (newState === 'home') {
                        this.questionManager.clearEditHistory();
                    }
                    document.body.removeChild(dialog);
                });

                // 放弃修改并退出
                dialog.querySelector('#discardAndExit').addEventListener('click', () => {
                    this.questionManager.cancelEditing();
                    this.isEditing = false;
                    this.showExportButton = false;
                    this.pageState = newState;
                    if (newState === 'home') {
                        this.questionManager.clearEditHistory();
                    }
                    document.body.removeChild(dialog);
                });
            },

            goBack() {
                if (this.isEditing) {
                    if (this.questionManager.checkUnsavedChanges()) {
                        this.showUnsavedDialog('setDescription');
                        return;
                    } else {
                        this.questionManager.cancelEditing();
                        this.isEditing = false;
                        this.showExportButton = false;
                        this.showAnswer = false; // 退出解析模式
                    }
                }
                this.updatePageState('setDescription');
            },

            goHome() {
                this.updatePageState('home');
            },

            getBankStats(fileName) {
                try {
                    const bankData = this.storageManager.getBankStats(fileName);
                    if (!bankData) return null;
                    
                    return {
                        completed: bankData.completed,
                        total: bankData.total,
                        accuracy: bankData.attempts > 0 
                            ? Math.round((bankData.attempts - bankData.errors) / bankData.attempts * 100)
                            : 0
                    };
                } catch (e) {
                    console.error('获取题库统计失败:', e);
                    return null;
                }
            },

            renderMarkdown(text) {
                if (!text) return '';
                return marked.parse(text);
            },

            renderMarkdownWithLatex(text) {
                if (!text) return '';
                
                // 先处理多行公式，避免被markdown解析器破坏格式
                let content = text;
                
                // 保存多行公式
                const formulas = [];
                content = content.replace(/\$\$([\s\S]+?)\$\$/g, (match, formula) => {
                    // 保持原始换行，不进行任何替换
                    formulas.push(formula.trim());
                    return `<div class="katex-display">${katex.renderToString(formula.trim(), {
                        displayMode: true,
                        throwOnError: false,
                        strict: false,
                        trust: true,
                        output: 'html'
                    })}</div>`;
                });
                
                // 处理Markdown
                content = marked.parse(content);
                
                // 处理行内公式
                content = content.replace(/\$([^$]+?)\$/g, (match, formula) => {
                    try {
                        return katex.renderToString(formula.trim(), {
                            displayMode: false,
                            throwOnError: false,
                            strict: false
                        });
                    } catch (e) {
                        console.error('LaTeX rendering error:', e);
                        console.error('Formula:', formula);
                        return match;
                    }
                });
                
                return content;
            },

            handleOptionChange(option, isSingleChoice) {
                console.log('Option change handler:', {
                    option,
                    isSingleChoice,
                    currentValue: isSingleChoice ? this.chosenAnswer : this.chosenAnswers
                });

                if (isSingleChoice) {
                    this.chosenAnswer = option;
                } else {
                    const index = this.chosenAnswers.indexOf(option);
                    if (index === -1) {
                        this.chosenAnswers.push(option);
                    } else {
                        this.chosenAnswers.splice(index, 1);
                    }
                }

                console.log('After option change:', {
                    chosenAnswer: this.chosenAnswer,
                    chosenAnswers: this.chosenAnswers
                });
            },

            isChosenOptionSingle(opt) {
                console.log('Checking single option selection:', {
                    option: opt,
                    optionType: typeof opt,
                    chosenAnswer: this.chosenAnswer,
                    chosenAnswerType: typeof this.chosenAnswer,
                    isChosen: String(this.chosenAnswer) === String(opt)
                });
                return String(this.chosenAnswer) === String(opt);
            },

            isCorrectOptionMulti(opt) {
                const ans = this.currentQuestion?.correct_answer || [];
                const isCorrect = ans.some(a => String(a) === String(opt));
                console.log('Checking multi option correctness:', {
                    option: opt,
                    correctAnswers: ans,
                    isCorrect: isCorrect
                });
                return isCorrect;
            },

            isCorrectOptionSingle(opt) {
                const ans = this.currentQuestion?.correct_answer || [];
                const isCorrect = ans.length > 0 && String(ans[0]) === String(opt);
                console.log('Checking single option correctness:', {
                    option: opt,
                    optionType: typeof opt,
                    correctAnswer: ans[0],
                    correctAnswerType: ans.length > 0 ? typeof ans[0] : 'undefined',
                    isCorrect: isCorrect
                });
                return isCorrect;
            },

            submitAnswer() {
                const q = this.currentQuestion;
                console.log('Submitting answer:', {
                    questionType: q.type,
                    questionId: q.uniqueId,
                    chosenAnswer: this.chosenAnswer,
                    chosenAnswers: this.chosenAnswers,
                    correctAnswer: q.correct_answer
                });

                if (!q.uniqueId) return;

                // 在预览模式下，直接显示答案，不进行验证和记录
                if (this.isPreviewMode) {
                    this.showAnswer = true;
                    return;
                }

                // 未选择/未填写时提示
                if (q.type === 'single-choice' && !this.chosenAnswer) {
                    console.log('No answer chosen for single choice question');
                    alert('请先选择一个选项');
                    return;
                }
                if (q.type === 'multiple-choice' && !this.chosenAnswers.length) {
                    alert('请至少选择一个选项');
                    return;
                }
                if (q.type === 'short-answer' && !this.shortAnswerText.trim()) {
                    alert('请先填写你的答案');
                    return;
                }
                if (q.type === 'fill-in-blank') {
                    if (this.fillInAnswers.some(answer => !answer?.trim())) {
                        alert('请填写所有空格');
                        return;
                    }
                }

                // 判定正误
                let isCorrect = false;
                if (q.type === 'single-choice') {
                    const userAnswer = String(this.chosenAnswer || '');
                    const correctAnswer = String(q.correct_answer[0] || '');
                    isCorrect = userAnswer === correctAnswer;
                    console.log('Single choice answer check:', {
                        userAnswer,
                        correctAnswer,
                        isCorrect,
                        chosenAnswerType: typeof this.chosenAnswer,
                        correctAnswerType: typeof q.correct_answer[0]
                    });
                } else if (q.type === 'multiple-choice') {
                    const c1 = [...this.chosenAnswers].map(String).sort().join('||');
                    const c2 = [...q.correct_answer].map(String).sort().join('||');
                    isCorrect = (c1 === c2);
                } else if (q.type === 'short-answer') {
                    const userAns = this.shortAnswerText.trim();
                    const correctAns = (q.correct_answer[0] || '').trim();
                    isCorrect = (userAns === correctAns);
                } else if (q.type === 'fill-in-blank') {
                    const userAns = this.fillInAnswers.map(a => a.trim()).join('||');
                    const correctAns = q.correct_answer.map(a => a.trim()).join('||');
                    isCorrect = (userAns === correctAns);
                }

                // 更新当前会话的完成记录
                if (isCorrect) {
                    this.currentSessionCompleted.add(q.uniqueId);
                }

                // 更新完成状态（非预览模式）
                this.storageManager.updateQuestionCompletion(this.chosenSet.id, q.uniqueId, isCorrect);
                this.showAnswer = true;
            },

            nextQuestion() {
                // 在预览模式下，不更新答题记录
                if (this.currentIndex < this.quizList.length - 1) {
                    this.practiceManager.nextQuestion();
                    // 重置答案状态
                    this.chosenAnswer = '';
                    this.chosenAnswers = [];
                    this.shortAnswerText = '';
                    this.fillInAnswers = [];
                    this.showAnswer = false;
                    console.log('Reset answer state:', {
                        chosenAnswer: this.chosenAnswer,
                        chosenAnswers: this.chosenAnswers
                    });
                } else if (!this.isPreviewMode) {
                    this.updatePageState('result');
                }
            },
            formatDate(isoDate) {
                if (!isoDate) return '';
                const date = new Date(isoDate);
                const today = new Date();
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);

                if (isoDate.startsWith(today.toISOString().split('T')[0])) {
                    return '今天 ' + date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                } else if (isoDate.startsWith(yesterday.toISOString().split('T')[0])) {
                    return '昨天 ' + date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                } else {
                    return date.toLocaleDateString('zh-CN') + ' ' + 
                           date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                }
            },
            closeUnsavedModal() {
                this.showUnsavedModal = false;
            },
            truncateText(text, length) {
                if (!text) return '';
                text = text.replace(/<[^>]*>/g, ''); // 移除HTML标签
                return text.length > length ? text.slice(0, length) + '...' : text;
            },
            getSetName(setId) {
                return this.jsonLoader.sets.find(s => s.id === setId)?.name || setId;
            },
            checkModifiedQuestions() {
                const modifiedQuestions = this.questionManager.getModifiedQuestions();
                if (modifiedQuestions.length > 0 && !this.dontShowExportReminder) {
                    // 只显示当前题库的修改题目
                    this.groupedModifiedQuestions = this.jsonLoader.questions
                        .filter(q => modifiedQuestions.includes(q.uniqueId));
                    
                    // 显示未导出提示模态框
                    this.showUnsavedModal = true;
                    return true;
                }
                return false;
            },
            showBanner(content, type = 'info', closeable = true) {
                this.banner = {
                    show: true,
                    content,
                    type,
                    closeable
                };
            },
            closeBanner() {
                this.banner.show = false;
            },
            formatUpdateTime(isoString) {
                const date = new Date(isoString);
                return date.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            },
            closeUnsavedModalAndContinue() {
                this.showUnsavedModal = false;
                this.questionManager.clearModifiedQuestions();
                this.modifiedCount = 0;
                this.showExportButton = false;
            }
        }
    });

    app.mount('#app');
</script>

<style>
.fill-blank-item {
    margin: 10px 0;
}
.question-content, .option-content, .analysis {
    cursor: pointer;
}
.question-content:hover, .option-content:hover, .analysis:hover {
    background-color: rgba(0, 0, 0, 0.05);
}
.edit-textarea {
    width: 100%;
    padding: 8px;
    font-family: monospace;
    border: 1px solid #ddd;
    border-radius: 4px;
}
.edit-input {
    width: calc(100% - 30px);
    padding: 4px 8px;
    font-family: monospace;
    border: 1px solid #ddd;
    border-radius: 4px;
}
.option-edit {
    display: flex;
    align-items: center;
    width: 100%;
}
.action-button {
    display: inline-flex;
    align-items: center;
    padding: 4px 8px;
    border-radius: 4px;
    background: #f5f5f5;
    border: 1px solid #ddd;
    cursor: pointer;
    font-size: 14px;
    color: #666;
    margin-left: 8px;
}
.action-button:hover {
    background: #e8e8e8;
}
.action-button svg {
    width: 16px;
    height: 16px;
    margin-right: 4px;
}
.preview-mode {
    color: #B0C1A2;
    font-weight: bold;
}
.header-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}
.back-button {
    display: inline-flex;
    align-items: center;
    padding: 4px 8px;
    border-radius: 4px;
    background: #f5f5f5;
    border: 1px solid #ddd;
    cursor: pointer;
    font-size: 14px;
    color: #666;
    margin-right: 12px;
}
.back-button:hover {
    background: #e8e8e8;
}
.back-button svg {
    width: 16px;
    height: 16px;
    margin-right: 4px;
}
.progress-text {
    margin-left: 16px;
    color: #666;
    font-size: 14px;
}
.action-buttons {
    display: flex;
    gap: 8px;
}
.question-header {
    margin-bottom: 16px;
}
.editable {
    cursor: pointer;
}
.editable:hover {
    background-color: rgba(0, 0, 0, 0.05);
}
.stats-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
    margin: 15px 0;
}

.stats-item {
    text-align: center;
    padding: 15px;
    background: #f5f5f5;
    border-radius: 8px;
}

.stats-value {
    font-size: 24px;
    font-weight: bold;
    color: #B0C1A2;
}

.stats-label {
    font-size: 14px;
    color: #666;
    margin-top: 5px;
}

.stats-title {
    font-size: 18px;
    font-weight: bold;
    margin: 20px 0 10px;
}

.overall-stats {
    margin-bottom: 20px;
    padding: 15px;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.quiz-item-content {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.quiz-item-title {
    font-weight: bold;
}

.quiz-item-stats {
    font-size: 13px;
    color: #666;
}

.quiz-stat {
    margin-top: 2px;
}

.stats-details {
    font-size: 14px;
    color: #666;
    margin-top: 10px;
    padding: 10px;
    background: #f9f9f9;
    border-radius: 6px;
}

.set-stats {
    margin: 20px 0;
    padding: 15px;
    background: #f5f5f5;
    border-radius: 8px;
}

.empty-analysis {
    padding: 15px;
    border: 2px dashed #ddd;
    border-radius: 4px;
    color: #999;
    text-align: center;
    margin: 10px 0;
    font-size: 14px;
}

.empty-analysis.editable:hover {
    background-color: rgba(33, 150, 243, 0.05);
    border-color: #B0C1A2;
    color: #B0C1A2;
    cursor: pointer;
}

.stats-sublabel {
    font-size: 12px;
    color: #666;
    margin-top: 2px;
}

.stats-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
}

.question-stats {
    margin: 15px 0;
    padding: 15px;
    background: #f5f5f5;
    border-radius: 8px;
}

.question-stats h4 {
    margin: 0 0 10px 0;
    color: #333;
}

.status-indicator {
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 12px;
    margin-left: 8px;
}

.status-indicator.correct {
    background-color: #4caf50;
    color: white;
}

.status-indicator.incorrect {
    background-color: #f44336;
    color: white;
}

.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.modal-content {
    background: white;
    padding: 20px;
    border-radius: 8px;
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
}

.modal-content h3 {
    margin-top: 0;
    color: #333;
    border-bottom: 1px solid #eee;
    padding-bottom: 10px;
}

.modified-questions-list {
    margin: 15px 0;
}

.modified-set {
    margin-bottom: 20px;
    padding: 15px;
    background: #f5f5f5;
    border-radius: 6px;
}

.modified-set h4 {
    margin: 0 0 10px 0;
    color: #B0C1A2;
}

.modified-set ul {
    list-style: none;
    padding: 0;
    margin: 0 0 15px 0;
}

.modified-set li {
    padding: 8px;
    margin: 5px 0;
    background: white;
    border-radius: 4px;
    font-size: 14px;
}

.question-preview {
    color: #666;
    font-size: 13px;
}

.modal-actions {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid #eee;
}

.export-btn {
    font-size: 14px;
    padding: 6px 12px;
    margin-top: 10px;
}

.dont-show-again {
    margin-left: 20px;
    font-size: 14px;
    color: #666;
    display: flex;
    align-items: center;
    gap: 5px;
}

.btn.primary {
    background-color: #B0C1A2;
    color: white;
}

.btn.primary:hover {
    background-color: #1976d2;
}

.banner {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    padding: 10px;
    background-color: #B0C1A2;
    color: white;
    display: flex;
    justify-content: space-between;
    align-items: center;
    z-index: 1000;
}

.banner-content {
    flex: 1;
}

.banner-close {
    background: none;
    border: none;
    color: white;
    font-size: 16px;
    cursor: pointer;
}
</style>
</body>
</html>