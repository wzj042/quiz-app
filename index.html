<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8" />
    <title>åˆ·é¢˜</title>
    <meta name="referrer" content="no-referrer">
    <link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/katex.min.css">
    <script defer src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/katex.min.js"></script>
    <script defer
        src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/contrib/auto-render.min.js"></script>
    <script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vue/3.2.23/vue.global.prod.min.js"></script>
    <script src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/marked/4.0.2/marked.min.js"></script>
    <link rel="stylesheet" href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css">
    <!-- æ·»åŠ  highlight.js -->
    <link href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/highlight.js/11.4.0/styles/qtcreator-light.min.css"
        type="text/css" rel="stylesheet" />
    <script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/highlight.js/11.4.0/highlight.min.js"
        type="application/javascript"></script>
    <!-- æ·»åŠ  SQL è¯­è¨€æ”¯æŒ -->
    <script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/highlight.js/11.4.0/languages/sql.min.js"
        type="application/javascript"></script>

    <!-- é…ç½® marked å’Œ highlight.js -->
    <script>
        // é…ç½® marked çš„ä»£ç é«˜äº®
        marked.setOptions({
            highlight: function (code, lang) {
                if (lang) {
                    try {
                        const highlighted = hljs.highlight(code, {
                            language: lang.toLowerCase(),
                            ignoreIllegals: true
                        }).value;
                        return `<pre data-language="${lang}"><code class="hljs language-${lang}">${highlighted}</code></pre>`;
                    } catch (e) {
                        console.warn('Language highlight failed:', e);
                        return `<pre data-language="${lang}"><code class="hljs">${hljs.highlightAuto(code).value}</code></pre>`;
                    }
                }
                return `<pre><code class="hljs">${hljs.highlightAuto(code).value}</code></pre>`;
            },
            breaks: true,
            gfm: true
        });
    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/mobile.css?v=_timestamp_">
    <link rel="icon" href="favicon.ico?v=_timestamp_" type="image/x-icon">
    <script>
        // åŠ¨æ€åŠ è½½ JS æ¨¡å—ï¼Œä½¿ç”¨æ—¶é—´æˆ³é˜²æ­¢ç¼“å­˜
        window.addEventListener('DOMContentLoaded', function () {
            const timestamp = Date.now();  // ä½¿ç”¨æ—¶é—´æˆ³ç¡®ä¿æ¯æ¬¡åŠ è½½æœ€æ–°èµ„æº
            const modules = [
                'js/modules/DataManager.js',
                'js/modules/jsonLoader.js',
                'js/modules/keyboard.js',
                'js/modules/PracticeManager.js',
                'js/modules/ProgressManager.js',
                'js/modules/QuestionManager.js',
                'js/modules/storage.js',
                'js/modules/AIManager.js'  // æ·»åŠ  AI ç®¡ç†å™¨
            ];

            // æ›´æ–° CSS å’Œ favicon çš„æ—¶é—´æˆ³
            document.querySelector('link[href*="mobile.css"]').href = `css/mobile.css?v=${timestamp}`;
            document.querySelector('link[rel="icon"]').href = `favicon.ico?v=${timestamp}`;

            // åŠ¨æ€åŠ è½½ JS æ¨¡å—
            modules.forEach(module => {
                const script = document.createElement('script');
                script.type = 'module';
                script.src = `${module}?v=${timestamp}`;
                document.head.appendChild(script);
            });

            // æ·»åŠ é”®ç›˜å¿«æ·é”®æ”¯æŒ
            const handleKeydown = (e) => {
                // å¦‚æœæ­£åœ¨è¾“å…¥ï¼Œä¸å¤„ç†å¿«æ·é”®
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }

                // T: æ‰“å¼€æ ‡ç­¾ç­›é€‰
                if (e.key === 't' && !e.ctrlKey && !e.altKey && !e.shiftKey) {
                    e.preventDefault();
                    const tagsButton = document.querySelector('.tags-button');
                    if (tagsButton) tagsButton.click();
                }

                // Esc: å…³é—­æ¨¡æ€çª—å£
                if (e.key === 'Escape') {
                    const modalOverlay = document.querySelector('.modal-overlay');
                    if (modalOverlay) {
                        const closeBtn = modalOverlay.querySelector('.close-btn');
                        if (closeBtn) closeBtn.click();
                    }
                }

                // Ctrl + S: å¯¼å‡ºä¿®æ”¹
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    const exportBtn = document.querySelector('.export-btn');
                    if (exportBtn) exportBtn.click();
                }
            };

            document.addEventListener('keydown', handleKeydown);

            // åˆå§‹åŒ–ç„¦ç‚¹ç®¡ç†
            initFocusManagement();
        });

        function initFocusManagement() {
            // æ¨¡æ€çª—å£ç„¦ç‚¹ç®¡ç†
            const modalOverlay = document.querySelector('.modal-overlay');
            if (modalOverlay) {
                const focusableElements = modalOverlay.querySelectorAll(
                    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                );
                const firstFocusable = focusableElements[0];
                const lastFocusable = focusableElements[focusableElements.length - 1];
                // ç„¦ç‚¹å¾ªç¯
                modalOverlay.addEventListener('keydown', function (e) {
                    if (e.key === 'Tab') {
                        if (e.shiftKey) {
                            if (document.activeElement === firstFocusable) {
                                e.preventDefault();
                                lastFocusable.focus();
                            }
                        } else {
                            if (document.activeElement === lastFocusable) {
                                e.preventDefault();
                                firstFocusable.focus();
                            }
                        }
                    }
                });
            }
        }
    </script>
    <style>
        /* ç§»é™¤ä¹‹å‰çš„å·¥å…·æ å’Œé¡¶éƒ¨å¯¼èˆªæ ·å¼ */
        .toolbar,
        .toolbar-right,
        .nav-right,
        .nav-left {
            display: none;
        }

        /* å¯¼èˆªæ å›¾æ ‡æŒ‰é’®æ ·å¼ */
        .nav-icon-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 4px;
            color: #B8C7AB;
            background: transparent;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }

        .nav-icon-btn:hover {
            opacity: 0.8;
        }

        .nav-icon-btn svg {
            width: 24px;
            height: 24px;
        }

        /* è°ƒæ•´å¯¼èˆªæ å¸ƒå±€ */
        .nav {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-title-link {
            margin-right: auto;
        }

        /* AI æµ‹è¯•æ¨¡æ€çª—å£æ ·å¼ */
        .ai-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1000;
        }

        .ai-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ai-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .ai-modal-title {
            margin: 0;
            font-size: 1.2em;
            font-weight: 600;
        }

        .ai-modal-close {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            padding: 0;
            color: #666;
        }

        .ai-modal-close:hover {
            color: #333;
        }

        .ai-model-select {
            margin-bottom: 20px;
        }

        .ai-model-select select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
            font-size: 14px;
        }

        .ai-input-group {
            margin-bottom: 20px;
        }

        .ai-input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #333;
        }

        .ai-input-group input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        /* è‡ªåŠ¨è¯„åˆ†å¼€å…³æ ·å¼ */
        .custom-switch {
            padding-left: 2.25rem;
            padding-bottom: 1rem;
            position: relative;
            display: inline-block;
        }

        .custom-control-input {
            position: absolute;
            left: 0;
            z-index: -1;
            width: 1.5rem;
            height: 1.5rem;
            opacity: 0;
        }

        .custom-control-label {
            position: relative;
            margin-bottom: 0;
            vertical-align: top;
            cursor: pointer;
            padding-left: 0.5rem;
        }

        .custom-control-label::before {
            position: absolute;
            top: 0.25rem;
            left: -2.25rem;
            display: block;
            width: 1.75rem;
            height: 1rem;
            pointer-events: none;
            content: "";
            background-color: #fff;
            border: 1px solid #adb5bd;
            border-radius: 0.5rem;
            transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }

        .custom-control-label::after {
            position: absolute;
            top: calc(0.25rem + 2px);
            left: calc(-2.25rem + 2px);
            display: block;
            width: calc(1rem - 4px);
            height: calc(1rem - 4px);
            content: "";
            background: #adb5bd;
            border-radius: 0.5rem;
            transition: transform 0.15s ease-in-out, background-color 0.15s ease-in-out;
        }

        .custom-control-input:checked ~ .custom-control-label::before {
            color: #fff;
            border-color: #B8C7AB;
            background-color: #B8C7AB;
        }

        .custom-control-input:checked ~ .custom-control-label::after {
            background-color: #fff;
            transform: translateX(0.75rem);
        }

        .custom-control-input:focus ~ .custom-control-label::before {
            box-shadow: 0 0 0 0.2rem rgba(184, 199, 171, 0.25);
        }

        .ai-chat-area {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            margin-bottom: 15px;
            background: #f9f9f9;
            font-size: 14px;
            line-height: 1.5;
        }

        .ai-input-area {
            display: flex;
            gap: 10px;
        }

        .ai-input-area textarea {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            min-height: 80px;
            font-size: 14px;
        }

        .ai-input-area button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            align-self: flex-end;
        }

        .ai-input-area button:hover {
            background: #0056b3;
        }

        .ai-input-area button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* æµ‹è¯•åŒºåŸŸæ ·å¼ */
        .ai-test-area {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 10px 0;
            border: 1px solid #eee;
        }

        .test-prompt {
            width: 100%;
            min-height: 80px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            font-family: inherit;
            font-size: 14px;
        }

        .test-btn {
            width: 100%;
            background: #A5B596;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
            align-self: flex-end;
            min-width: 120px;
        }

        .test-btn:hover:not(:disabled) {
            background: #2d3748;
        }

        .test-btn:disabled {
            background: #718096;
            cursor: not-allowed;
        }

        .test-result {
            margin-top: 10px;
            padding: 15px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.5;
            min-height: 100px;
            max-height: 300px;
            overflow-y: auto;
        }

        .custom-preset-form {
            background: #f8f9fa;
            border: 1px solid #eee;
            padding: 20px;
            border-radius: 4px;
            margin-top: 20px;
        }

        .custom-preset-form h4 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #333;
        }

        .form-row {
            margin-bottom: 15px;
        }

        .form-row label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #333;
        }

        .form-row input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .preset-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .preset-actions button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        .preset-actions .save-btn {
            background: #B8C7AB;
            color: white;
        }

        .preset-actions .save-btn:hover {
            background: #218838;
        }

        .preset-actions .cancel-btn {
            background: #dc3545;
            color: white;
        }

        .preset-actions .cancel-btn:hover {
            background: #c82333;
        }

        .custom-preset-trigger {
            display: block;
            width: 100%;
            padding: 12px;
            background: #f8f9fa;
            border: 1px dashed #ddd;
            border-radius: 4px;
            text-align: center;
            cursor: pointer;
            margin-top: 15px;
            color: #666;
            font-size: 14px;
        }

        .custom-preset-trigger:hover {
            background: #e9ecef;
            color: #333;
        }

        .model-description {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            padding-left: 2px;
        }

        /* æ—¥å¿—æŸ¥çœ‹å™¨æ ·å¼ */
        .log-viewer {
            margin-top: 15px;
            border-top: 1px solid #eee;
            padding-top: 15px;
        }

        .log-viewer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .log-viewer-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .log-controls {
            display: flex;
            gap: 10px;
        }

        .log-controls select,
        .log-controls button {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            background: white;
        }

        .log-controls button {
            cursor: pointer;
        }

        .log-controls button:hover {
            background: #f8f9fa;
        }

        .log-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            background: #f8f9fa;
        }

        .log-entry {
            padding: 6px 8px;
            border-bottom: 1px solid #eee;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-entry.debug {
            color: #6c757d;
        }

        .log-entry.info {
            color: #17a2b8;
        }

        .log-entry.warn {
            color: #ffc107;
        }

        .log-entry.error {
            color: #dc3545;
        }

        .log-timestamp {
            color: #666;
            margin-right: 8px;
        }

        .log-level {
            font-weight: bold;
            margin-right: 8px;
        }

        .log-message {
            white-space: pre-wrap;
            word-break: break-all;
        }

        .log-data {
            margin-top: 4px;
            padding-left: 16px;
            color: #666;
            font-style: italic;
        }

        /* Markdown æ¸²æŸ“æ ·å¼ */
        .markdown-content {
            font-size: 14px;
            line-height: 1.6;
        }

        .markdown-content h1,
        .markdown-content h2,
        .markdown-content h3,
        .markdown-content h4,
        .markdown-content h5,
        .markdown-content h6 {
            margin-top: 16px;
            margin-bottom: 8px;
            line-height: 1.25;
        }

        .markdown-content h1 {
            font-size: 2em;
        }

        .markdown-content h2 {
            font-size: 1.5em;
        }

        .markdown-content h3 {
            font-size: 1.25em;
        }

        .markdown-content h4 {
            font-size: 1em;
        }

        .markdown-content p {
            margin: 8px 0;
        }

        .markdown-content pre {
            background-color: #f6f8fa;
            border-radius: 4px;
            padding: 16px;
            overflow: auto;
            margin: 8px 0;
        }

        .markdown-content code {
            font-family: monospace;
            background-color: #f6f8fa;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }

        .markdown-content pre code {
            padding: 0;
            background-color: transparent;
        }

        .markdown-content blockquote {
            margin: 8px 0;
            padding: 0 16px;
            color: #666;
            border-left: 4px solid #ddd;
        }

        .markdown-content ul,
        .markdown-content ol {
            margin: 8px 0;
            padding-left: 24px;
        }

        .markdown-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 8px 0;
        }

        .markdown-content table th,
        .markdown-content table td {
            padding: 6px 12px;
            border: 1px solid #ddd;
        }

        .markdown-content table th {
            background-color: #f6f8fa;
        }

        .markdown-content img {
            max-width: 100%;
            height: auto;
        }

        .markdown-content hr {
            margin: 16px 0;
            border: none;
            border-top: 1px solid #ddd;
        }

        .markdown-content a {
            color: #0366d6;
            text-decoration: none;
        }

        .markdown-content a:hover {
            text-decoration: underline;
        }

        /* é¢„è§ˆåŒºåŸŸæ ·å¼ */
        .preview-area {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            background: #fff;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
        }

        .preview-area:empty::before {
            content: 'é¢„è§ˆåŒºåŸŸ';
            color: #999;
            font-style: italic;
        }

        /* æ ‡ç­¾é¡µæ ·å¼ */
        .tabs {
            display: flex;
            margin-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }

        .tab {
            padding: 8px 16px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-bottom: -1px;
            background: transparent;
        }

        .tab.active {
            border-color: #ddd;
            border-radius: 4px 4px 0 0;
            background: white;
            border-bottom-color: white;
        }

        .tab:hover:not(.active) {
            background: #f8f9fa;
        }

        /* æ€ç»´é“¾å†…å®¹æ ·å¼ */
        .reasoning-content {
            background-color: #f8f9fa;
            border-left: 4px solid #6c757d;
            padding: 12px;
            margin: 8px 0;
            font-size: 0.95em;
            color: #495057;
        }

        .reasoning-content::before {
            content: "æ€ç»´è¿‡ç¨‹";
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #6c757d;
        }

        .final-answer {
            border-left: 4px solid #B8C7AB;
            padding: 12px;
            margin: 8px 0;
        }

        .final-answer::before {
            content: "æœ€ç»ˆå›ç­”";
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #B8C7AB;
        }

        /* æŒ‰é’®åŸºç¡€æ ·å¼ */
        .ai-modal button {
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            border: none;
            outline: none;
        }

        /* ä¸»è¦æŒ‰é’®æ ·å¼ */
        .ai-modal button.primary {
            background-color: #B8C7AB;
            color: white;
            border: 1px solid #B8C7AB;
        }

        .ai-modal button.primary:hover {
            background-color: #B8C7AB;
        }

        .ai-modal button.primary:disabled {
            background-color: #A5D6A7;
            border-color: #A5D6A7;
            cursor: not-allowed;
        }

        /* æ¬¡è¦æŒ‰é’®æ ·å¼ */
        .ai-modal button.secondary {
            background-color: #F5F5F5;
            color: #333;
            border: 1px solid #DDD;
        }

        .ai-modal button.secondary:hover {
            background-color: #EEEEEE;
            border-color: #CCCCCC;
        }

        /* æ ‡ç­¾é¡µæŒ‰é’®æ ·å¼ */
        .ai-modal .tab {
            background-color: transparent;
            border: 1px solid transparent;
            color: #666;
            padding: 8px 16px;
            margin-right: 4px;
        }

        .ai-modal .tab:hover:not(.active) {
            background-color: #F5F5F5;
            color: #333;
        }

        .ai-modal .tab.active {
            background-color: white;
            border-color: #DDD;
            border-bottom-color: white;
            color: #B8C7AB;
            font-weight: 500;
        }

        /* å‘é€æŒ‰é’®æ ·å¼ */
        .ai-modal .ai-input-area button {
            background-color: #B8C7AB;
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 4px;
            margin-left: 8px;
            transition: all 0.3s ease;
        }

        .ai-modal .ai-input-area button:hover:not(:disabled) {
            background-color: #B8C7AB;
            transform: translateY(-1px);
        }

        .ai-modal .ai-input-area button:disabled {
            background-color: #A5D6A7;
            cursor: not-allowed;
        }

        /* å…³é—­æŒ‰é’®æ ·å¼ */
        .ai-modal .ai-modal-close {
            background-color: transparent;
            border: none;
            color: #666;
            font-size: 24px;
            padding: 4px 8px;
            position: absolute;
            right: 16px;
            top: 12px;
            transition: color 0.3s ease;
        }

        .ai-modal .ai-modal-close:hover {
            color: #333;
        }

        /* è‡ªå®šä¹‰é¢„è®¾è¡¨å•æŒ‰é’® */
        .ai-modal .custom-preset-form .preset-actions {
            display: flex;
            gap: 8px;
            margin-top: 16px;
        }

        .ai-modal .custom-preset-form .save-btn {
            background-color: #B8C7AB;
            color: white;
        }

        .ai-modal .custom-preset-form .save-btn:hover {
            background-color: #B8C7AB;
        }

        .ai-modal .custom-preset-form .cancel-btn {
            background-color: #F5F5F5;
            color: #666;
        }

        .ai-modal .custom-preset-form .cancel-btn:hover {
            background-color: #EEEEEE;
            color: #333;
        }

        /* æ·»åŠ è‡ªå®šä¹‰é¢„è®¾æŒ‰é’® */
        .ai-modal .custom-preset-trigger {
            background-color: #F5F5F5;
            color: #666;
            border: 1px dashed #DDD;
            padding: 8px 16px;
            margin-top: 16px;
            width: 100%;
            text-align: center;
            transition: all 0.3s ease;
        }

        .ai-modal .custom-preset-trigger:hover {
            background-color: #EEEEEE;
            border-color: #B8C7AB;
            color: #B8C7AB;
        }

        /* è®¡åˆ†æ˜¾ç¤ºå’Œè®¡æ—¶å™¨æ ·å¼ */
        .score-display {
            text-align: center;
            margin: 20px 0;
            font-size: 24px;
        }

        .timer-bar {
            width: 100%;
            height: 6px;
            background: #eee;
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }

        .timer-progress {
            height: 100%;
            background: #B8C7AB;
            width: 100%;
            transition: width 0.1s linear;
        }

        .score-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .score-button {
            font-size: 20px;
            padding: 10px 25px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .score-button.positive {
            background: #B8C7AB;
            color: white;
        }

        .score-button.negative {
            background: #ff6b6b;
            color: white;
        }

        .score-button:not(.positive):not(.negative) {
            background: #f0f0f0;
            color: #666;
        }

        .score-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        /* è¾“å…¥æ¡†æ ·å¼ç»Ÿä¸€ */
        .ai-modal input[type="text"],
        .ai-modal input[type="password"],
        .ai-modal textarea {
            border: 1px solid #DDD;
            border-radius: 4px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .ai-modal input[type="text"]:focus,
        .ai-modal input[type="password"]:focus,
        .ai-modal textarea:focus {
            border-color: #B8C7AB;
            outline: none;
        }

        /* ä¸‹æ‹‰æ¡†æ ·å¼ */
        .ai-modal select {
            border: 1px solid #DDD;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 14px;
            background-color: white;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        .ai-modal select:focus {
            border-color: #B8C7AB;
            outline: none;
        }

        /* æ¨¡æ€æ¡†æ ‡é¢˜æ ·å¼ */
        .ai-modal .ai-modal-title {
            color: #333;
            margin: 0;
            font-size: 18px;
            font-weight: 500;
        }

        /* æ¨¡æ€æ¡†å†…å®¹åŒºåŸŸæ ·å¼ */
        .ai-modal .ai-chat-area {
            background-color: #FAFAFA;
            border: 1px solid #EEEEEE;
            border-radius: 4px;
            padding: 16px;
            margin: 16px 0;
        }

        /* AI é…ç½®æŒ‰é’®æ ·å¼ */
        .ai-config-trigger {
            display: inline-flex;
            align-items: center;
            padding: 6px 12px;
            background: #B8C7AB;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 8px;
            transition: all 0.3s ease;
        }

        .ai-config-trigger:hover {
            background: #A5B596;
            transform: translateY(-1px);
        }

        .ai-config-trigger svg {
            width: 16px;
            height: 16px;
            margin-right: 6px;
        }

        /* è°ƒæ•´é¡¶éƒ¨å·¥å…·æ å¸ƒå±€ */
        .toolbar {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 8px 16px;
            background: #fff;
            border-bottom: 1px solid #eee;
        }

        .toolbar-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ai-score-section {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-left: 4px solid #B8C7AB;
            border-radius: 4px;
        }

        .ai-score-section .empty-message {
            color: #999;
            font-style: italic;
            margin-top: 8px;
        }

        .ai-score-section .markdown-content:not(:empty) {
            margin-top: 8px;
        }

        .ai-analysis-section {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-left: 4px solid #B8C7AB;
            border-radius: 4px;
        }

        .ai-analysis-section .markdown-content:empty::before {
            content: 'ç­‰å¾… AI è§£æ...';
            color: #999;
            font-style: italic;
        }

        .api-key-input-container {
            display: flex;
            gap: 8px;
        }
        .api-key-input-container input {
            flex: 4;
        }
        .delete-api-key-btn {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .delete-api-key-btn:hover {
            background: #f5f5f5;
            border-color: #ccc;
        }

        /* Toast notification styles */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
        }

        .toast {
            background-color: #333;
            color: white;
            padding: 12px 24px;
            border-radius: 4px;
            margin-bottom: 10px;
            min-width: 250px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
            animation: slideIn 0.3s ease-out;
        }

        .toast.success {
            background-color: #4caf50;
        }

        .toast.error {
            background-color: #f44336;
        }

        .toast.info {
            background-color: #2196f3;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
    </style>
</head>

<body>
    <div id="app" class="container">
        <!-- Toast container -->
        <div class="toast-container">
            <div v-for="toast in toasts" :key="toast.id" :class="['toast', toast.type]" :data-toast-id="toast.id">
                {{ toast.message }}
            </div>
        </div>

        <!-- éŸ³æ•ˆé…ç½®æ¨¡æ€çª—å£ -->
        <div v-if="showSoundModal" class="ai-modal-overlay" @click.self="closeSoundModal">
            <div class="ai-modal">
                <div class="ai-modal-header">
                    <h3 class="ai-modal-title">éŸ³æ•ˆé…ç½®</h3>
                    <button class="ai-modal-close" @click="closeSoundModal">&times;</button>
                </div>

                <!-- éŸ³æ•ˆå¯ç”¨æ§åˆ¶ -->
                <div class="control-group">
                    <label>
                        <input type="checkbox" v-model="audioEnabled">
                        å¯ç”¨éŸ³æ•ˆ
                    </label>
                </div>

                <!-- éŸ³é‡æ§åˆ¶ -->
                <div class="control-group">
                    <label>
                        éŸ³é‡æ§åˆ¶: <span>{{ volumeValue }}%</span>
                        <input type="range" v-model="volumeValue" min="0" max="100">
                    </label>
                </div>

                <!-- æ—¶é—´è®¾ç½® -->
                <div class="settings-group">
                    <h3>æ—¶é—´è®¾ç½®</h3>
                    <label>
                        è¿å‡»çª—å£æ—¶é—´(ms):
                        <input type="number" v-model="comboWindowMs" min="1000" step="500">
                    </label>
                    <label>
                        é‡ç½®æ—¶é—´(ms):
                        <input type="number" v-model="resetTimeoutMs" min="1000" step="500">
                    </label>
                </div>

                <!-- è®¡åˆ†æ˜¾ç¤ºå’Œæ“ä½œåŒºåŸŸ -->
                <div class="settings-group">
                    <h3>è¿ç»­è¯„åˆ†åé¦ˆæµ‹è¯•</h3>
                    <div class="score-display">
                        <div>è¿ç»­æ•°: <span>{{ currentScore }}</span></div>
                        <div class="timer-bar">
                            <div class="timer-progress" :style="{ width: timerProgress + '%' }"></div>
                        </div>
                        <div>å‰©ä½™æ—¶é—´: <span>{{ timeLeft.toFixed(1) }}</span>s</div>
                    </div>
                    <div class="score-buttons">
                        <button class="score-button positive" @click="addScore">+1</button>
                        <button class="score-button negative" @click="subtractScore">-1</button>
                        <button class="score-button" @click="resetScore">é‡ç½®</button>
                    </div>
                </div>

                <!-- éŸ³æ•ˆæµ‹è¯•åŒºåŸŸ -->
                <div class="settings-group">
                    <h3>éŸ³æ•ˆæµ‹è¯•</h3>
                    <div class="button-group">
                        <button class="positive" @click="testSound('positive', 1)">æ’­æ”¾+1</button>
                        <button class="positive" @click="testSound('positive', 2)">æ’­æ”¾+2</button>
                        <button class="positive" @click="testSound('positive', 3)">æ’­æ”¾+3</button>
                    </div>
                    <div class="button-group">
                        <button class="negative" @click="testSound('negative', 1)">æ’­æ”¾-1</button>
                        <button class="negative" @click="testSound('negative', 2)">æ’­æ”¾-2</button>
                        <button class="negative" @click="testSound('negative', 3)">æ’­æ”¾-3</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- AI é…ç½®æ¨¡æ€çª—å£ -->
        <div v-if="showAIModal" class="ai-modal-overlay" @click.self="closeAIModal">
            <div class="ai-modal">
                <div class="ai-modal-header">
                    <h3 class="ai-modal-title">AI é…ç½®</h3>
                    <button class="ai-modal-close" @click="closeAIModal">&times;</button>
                </div>

                <!-- æ¨¡å‹é€‰æ‹© -->
                <div class="ai-model-select">
                    <label for="modelSelect">é€‰æ‹©æ¨¡å‹ï¼š</label>
                    <select id="modelSelect" v-model="selectedPresetId" @change="handlePresetChange">
                        <option v-for="(preset, id) in presets" :key="id" :value="id">
                            {{ preset?.name || id }}
                        </option>
                    </select>
                    <div class="model-description" v-if="currentPreset?.name">
                        {{ getModelDescription(selectedPresetId) }}
                    </div>
                </div>

                <!-- API Key è¾“å…¥ -->
                <form class="ai-input-group" @submit.prevent v-if="currentPreset?.name">
                    <label :for="'apiKey_' + currentProvider">{{ currentPreset.name }} API Key</label>
                    <div class="api-key-input-container">
                        <input type="password" :id="'apiKey_' + currentProvider" v-model="providerApiKeys[currentProvider]"
                            @input="updateApiKey" :placeholder="`è¯·è¾“å…¥ ${currentPreset.name} çš„ API Keyï¼Œä»…æœ¬åœ°å­˜å‚¨`">
                        <button type="button" class="delete-api-key-btn" @click="deleteProviderApiKey" title="åˆ é™¤ API Key">
                            <svg viewBox="0 0 24 24" width="16" height="16">
                                <path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                            </svg>
                        </button>
                    </div>
                </form>
                <div class="api-key-help">
                    <p class="help-text">
                        {{ providerApiKeys[currentProvider] ? 'ğŸ³' : 'ğŸ‹' }} <strong>è·å– API Keyï¼š</strong> 
                        <a href="https://platform.deepseek.com/usage" target="_blank" rel="noopener noreferrer">
                            deepseek
                        </a>
                    </p>
                </div>

                <!-- AI è‡ªåŠ¨è¯„åˆ†è®¾ç½® -->
                <div class="ai-input-group">
                    <div class="custom-control custom-switch">
                        <input type="checkbox" class="custom-control-input" id="autoScoring" 
                            v-model="autoScoring" @change="updateAutoScoring">
                        <label class="custom-control-label" for="autoScoring">è‡ªåŠ¨AIè¯„åˆ†</label>
                    </div>
                </div>

                <!-- æµå¼æ¸²æŸ“æµ‹è¯• -->
                <div class="ai-test-area">
                    <div class="ai-input-group">
                        <label for="testPrompt">æµ‹è¯•æç¤ºè¯ï¼š</label>
                        <textarea id="testPrompt" v-model="testPrompt" rows="3" 
                            placeholder="è¾“å…¥æµ‹è¯•æç¤ºè¯" class="test-prompt"></textarea>
                        <button class="test-btn" @click="testStreaming" :disabled="isTestingStream">
                            {{ isTestingStream ? 'æµ‹è¯•ä¸­...' : 'æµ‹è¯•è¿é€šæ€§' }}
                        </button>
                    </div>
                    <div v-if="testStreamContent" class="test-result markdown-content" v-html="renderedTestContent()"></div>
                </div>
            </div>
        </div>

        <!-- å¯¼èˆªæ  -->
        <nav class="nav" role="navigation">
            <a href="#" class="nav-title-link" @click="goHome" @mouseover="hoverTitle = true"
                @mouseout="hoverTitle = false">
                <span class="nav-title">Quiz App</span>
            </a>
            <button class="nav-icon-btn" @click="showAIModal = true" title="AI é…ç½®">
                <svg fill="currentColor" fill-rule="evenodd" height="24" viewBox="0 0 24 24" width="24"
                    xmlns="http://www.w3.org/2000/svg">
                    <path
                        d="M23.748 4.482c-.254-.124-.364.113-.512.234-.051.039-.094.09-.137.136-.372.397-.806.657-1.373.626-.829-.046-1.537.214-2.163.848-.133-.782-.575-1.248-1.247-1.548-.352-.156-.708-.311-.955-.65-.172-.241-.219-.51-.305-.774-.055-.16-.11-.323-.293-.35-.2-.031-.278.136-.356.276-.313.572-.434 1.202-.422 1.84.027 1.436.633 2.58 1.838 3.393.137.093.172.187.129.323-.082.28-.18.552-.266.833-.055.179-.137.217-.329.14a5.526 5.526 0 01-1.736-1.18c-.857-.828-1.631-1.742-2.597-2.458a11.365 11.365 0 00-.689-.471c-.985-.957.13-1.743.388-1.836.27-.098.093-.432-.779-.428-.872.004-1.67.295-2.687.684a3.055 3.055 0 01-.465.137 9.597 9.597 0 00-2.883-.102c-1.885.21-3.39 1.102-4.497 2.623C.082 8.606-.231 10.684.152 12.85c.403 2.284 1.569 4.175 3.36 5.653 1.858 1.533 3.997 2.284 6.438 2.14 1.482-.085 3.133-.284 4.994-1.86.47.234.962.327 1.78.397.63.059 1.236-.03 1.705-.128.735-.156.684-.837.419-.961-2.155-1.004-1.682-.595-2.113-.926 1.096-1.296 2.746-2.642 3.392-7.003.05-.347.007-.565 0-.845-.004-.17.035-.237.23-.256a4.173 4.173 0 001.545-.475c1.396-.763 1.96-2.015 2.093-3.517.02-.23-.004-.467-.247-.588zM11.581 18c-2.089-1.642-3.102-2.183-3.52-2.16-.392.024-.321.471-.235.763.09.288.207.486.371.739.114.167.192.416-.113.603-.673.416-1.842-.14-1.897-.167-1.361-.802-2.5-1.86-3.301-3.307-.774-1.393-1.224-2.887-1.298-4.482-.02-.386.093-.522.477-.592a4.696 4.696 0 011.529-.039c2.132.312 3.946 1.265 5.468 2.774.868.86 1.525 1.887 2.202 2.891.72 1.066 1.494 2.082 2.48 2.914.348.292.625.514.891.677-.802.09-2.14.11-3.054-.614zm1-6.44a.306.306 0 01.415-.287.302.302 0 01.2.288.306.306 0 01-.31.307.303.303 0 01-.304-.308zm3.11 1.596c-.2.081-.399.151-.59.16a1.245 1.245 0 01-.798-.254c-.274-.23-.47-.358-.552-.758a1.73 1.73 0 01.016-.588c.07-.327-.008-.537-.239-.727-.187-.156-.426-.199-.688-.199a.559.559 0 01-.254-.078c-.11-.054-.2-.19-.114-.358.028-.054.16-.186.192-.21.356-.202.767-.136 1.146.016.352.144.618.408 1.001.782.391.451.462.576.685.914.176.265.336.537.445.848.067.195-.019.354-.25.452z">
                    </path>
                </svg>
            </button>
            <button class="nav-icon-btn" @click="showSoundModal = true" title="éŸ³æ•ˆé…ç½®">
                <svg fill="currentColor" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                </svg>
            </button>
            <a href="https://github.com/wzj042/quiz-app" class="github-link" target="_blank" rel="noopener noreferrer"
                aria-label="åœ¨ GitHub ä¸ŠæŸ¥çœ‹é¡¹ç›®" title="é¡¹ç›®è°ƒè¯•ä¸­ï¼Œæ¬¢è¿å‚ä¸å¼€å‘å’Œåé¦ˆã€‚å¯å‚è€ƒ demo.json æ ¼å¼ï¼ŒFork é¡¹ç›®åæ·»åŠ è‡ªå·±çš„é¢˜åº“ã€‚">
                <svg class="github-icon" viewBox="0 0 16 16" width="24" height="24" aria-hidden="true">
                    <path fill="currentColor"
                        d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
                    </path>
                </svg>
            </a>
        </nav>

        <!-- æœªä¿å­˜ä¿®æ”¹çš„æ¨¡æ€çª—å£ -->
        <div v-if="showUnsavedModal" class="modal-overlay" @click.self="closeUnsavedModal" role="dialog"
            aria-labelledby="unsaved-modal-title" aria-modal="true" @keydown.esc="closeUnsavedModal">
            <div class="modal-content" tabindex="-1">
                <h3 id="unsaved-modal-title">æœªå¯¼å‡ºçš„ä¿®æ”¹</h3>
                <div class="modal-body">
                    <p>å½“å‰é¢˜åº“æœ‰æœªå¯¼å‡ºçš„ä¿®æ”¹ï¼š</p>
                    <div class="modified-questions-list" role="list">
                        <ul>
                            <li v-for="q in groupedModifiedQuestions" :key="q.uniqueId" role="listitem">
                                é¢˜ç›®ID: {{ q.uniqueId }}
                                <br>
                                <span class="question-preview">{{ truncateText(q.content, 50) }}</span>
                            </li>
                        </ul>
                    </div>
                    <div class="modal-actions">
                        <div class="modal-actions">
                            <div class="action-buttons">
                                <button class="btn export-btn" @click="exportModifiedData" data-shortcut="Ctrl+S">
                                    å¯¼å‡ºä¿®æ”¹
                                </button>
                                <button class="btn close-btn" @click="closeUnsavedModalAndContinue" data-shortcut="Esc">
                                    ç›´æ¥é€€å‡º
                                </button>
                            </div>
                            <label class="dont-show-again">
                                <input type="checkbox" v-model="dontShowExportReminder"
                                    @keydown.enter="$event.target.click()">
                                <span>ä¸å†æé†’</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- åˆ—å‡ºé¢˜åº“ -->
        <div v-if="isLoading" class="card" role="status">
            <p>æ­£åœ¨å¤„ç†ï¼Œè¯·ç¨å...</p>
        </div>

        <template v-else>
            <div v-if="pageState === 'home'" class="card">
                <h1 class="title">
                    é€‰æ‹©é¢˜åº“
                    <span class="update-time" v-if="updateTime">æ›´æ–°äº: {{ formatUpdateTime(updateTime) }}</span>
                </h1>

                <!-- æ€»ä½“ç»Ÿè®¡ -->
                <div class="overall-stats" role="region" aria-label="æ€»ä½“ç»Ÿè®¡">
                    <h2 class="stats-title">æ€»ä½“ç»Ÿè®¡</h2>
                    <div class="stats-grid">
                        <div class="stats-item">
                            <div class="stats-value">{{ totalStats.completedQuestions }}/{{ totalStats.totalAttempts }}
                            </div>
                            <div class="stats-label">æ€»ç»ƒä¹ é¢˜æ•°</div>
                        </div>
                        <div class="stats-item">
                            <div class="stats-value">{{ totalStats.averageAccuracy }}%</div>
                            <div class="stats-label">å¹³å‡æ­£ç¡®ç‡</div>
                        </div>
                        <div class="stats-item">
                            <div class="stats-value">{{ totalStats.todayPracticed }}</div>
                            <div class="stats-label">ä»Šæ—¥å·²ç»ƒä¹ </div>
                        </div>
                    </div>
                    <button class="cross-practice-btn" @click="showCrossPracticeModal = true">
                        <i class="fas fa-random"></i>
                        è·¨å·ç»ƒä¹ è®¾ç½®
                    </button>
                </div>

                <!-- é¢˜åº“åˆ—è¡¨ -->
                <template v-if="fileList.length > 0">
                    <ul class="horizontal-list" role="list">
                        <!-- Tagsç­›é€‰å™¨ -->
                        <div class="tags-filter" role="region" aria-label="æ ‡ç­¾ç­›é€‰">
                            <div class="top-tags">
                                <button v-for="tag in topTags" :key="tag.tag"
                                    :class="['tag-chip', { active: selectedTags.includes(tag.tag) }]"
                                    @click="toggleTag(tag.tag)" :aria-pressed="selectedTags.includes(tag.tag)"
                                    :aria-label="'é€‰æ‹©æ ‡ç­¾: ' + tag.tag">
                                    {{ tag.tag }}
                                    <span v-if="selectedTags.includes(tag.tag)" class="tag-count">({{ tag.count
                                        }})</span>
                                </button>
                            </div>
                            <button :class="['tags-button', { 'has-active': selectedTags.length > 0 }]"
                                @click="showTagsModal = true" aria-label="æ›´å¤šæ ‡ç­¾" data-shortcut="T">
                                <i class="fas fa-tags" aria-hidden="true"></i>
                            </button>
                        </div>

                        <template v-for="(group, groupIndex) in filteredGroupedFileList" :key="groupIndex">
                            <li class="category-header" role="separator">
                                <h2>{{ group[0] }}</h2>
                                <hr>
                            </li>
                            <li v-for="(fileObj, idx) in group[1]" :key="idx" class="quiz-item" role="button"
                                tabindex="0" @click="loadJsonFile(fileObj.file)"
                                @keydown.enter="loadJsonFile(fileObj.file)"
                                @keydown.space.prevent="loadJsonFile(fileObj.file)">
                                <div class="quiz-item-content">
                                    <div class="quiz-item-title">{{ fileObj.name }}</div>
                                    <div class="quiz-item-tags" v-if="fileObj.tags && fileObj.tags.length">
                                        <span v-for="tag in fileObj.tags.slice(0, 3)" :key="tag" class="item-tag">
                                            {{ tag }}
                                        </span>
                                    </div>
                                    <div class="quiz-item-stats" v-if="bankStats[fileObj.file]">
                                        <div class="quiz-stat">
                                            å…±{{ bankStats[fileObj.file].totalQuestions }}é¢˜ (å·²ç»ƒ{{
                                            bankStats[fileObj.file].uniquePracticed || 0 }}é¢˜/æäº¤{{
                                            bankStats[fileObj.file].totalSubmissions || 0 }}æ¬¡)
                                            <span class="accuracy-stat"
                                                v-if="bankStats[fileObj.file].averageAccuracy !== undefined">
                                                - æ­£ç¡®ç‡: {{ bankStats[fileObj.file].averageAccuracy }}%
                                            </span>
                                        </div>
                                    </div>
                                </div>
                            </li>
                        </template>
                    </ul>
                </template>

                <!-- å¦‚æœåˆ—è¡¨ä¸ºç©º -->
                <template v-else>
                    <div class="empty-state" role="status">
                        æ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„é¢˜åº“
                    </div>
                </template>
            </div>

            <!-- é¢˜åº“è¯¦æƒ…é¡µé¢ -->
            <div v-else-if="pageState === 'setDescription'" class="card" @keydown.prevent="handleKeyNavigation"
                tabindex="-1">
                <h1 class="title">
                    {{ chosenSet.name }}
                    <div class="time-info" v-if="chosenSet.createTime || chosenSet.updateTime">
                        <div v-if="chosenSet.updateTime" class="update-time">
                            æ›´æ–°äºï¼š{{ formatDate(chosenSet.updateTime) }}
                        </div>
                        <div v-else-if="chosenSet.createTime" class="create-time">
                            åˆ›å»ºäºï¼š{{ formatDate(chosenSet.createTime) }}
                        </div>
                    </div>
                </h1>
                <p v-if="chosenSet.description" class="pre-wrap" v-html="renderMarkdown(chosenSet.description)"></p>

                <!-- ç»ƒä¹ æ¨¡å¼é€‰æ‹© -->
                <div class="mode-selection" role="group" aria-label="ç»ƒä¹ æ¨¡å¼é€‰æ‹©">
                    <button class="mode-btn" @click="enterQuizMode" @keydown.enter.prevent="enterQuizMode"
                        @keydown.space.prevent="enterQuizMode" @keydown.left.prevent="focusPrevButton($event)"
                        @keydown.right.prevent="focusNextButton($event)" @keydown.up.prevent="focusUpButton($event)"
                        @keydown.down.prevent="focusDownButton($event)" tabindex="0" role="button" data-nav="mode-btn">
                        å…¨éƒ¨ç»ƒä¹ 
                        <span class="mode-description">æŒ‰é¡ºåºç»ƒä¹ æ‰€æœ‰é¢˜ç›®</span>
                    </button>
                    <button class="mode-btn" @click="enterOrderQuizMode" @keydown.enter.prevent="enterOrderQuizMode"
                        @keydown.space.prevent="enterOrderQuizMode" @keydown.left.prevent="focusPrevButton($event)"
                        @keydown.right.prevent="focusNextButton($event)" @keydown.up.prevent="focusUpButton($event)"
                        @keydown.down.prevent="focusDownButton($event)" tabindex="0" role="button" data-nav="mode-btn">
                        é”™é¢˜ç»ƒä¹ 
                        <span class="mode-description">ä¸“æ³¨äºä¹‹å‰ç­”é”™çš„é¢˜ç›®</span>
                    </button>
                    <button class="mode-btn" @click="enterRandomQuizMode" @keydown.enter.prevent="enterRandomQuizMode"
                        @keydown.space.prevent="enterRandomQuizMode" @keydown.left.prevent="focusPrevButton($event)"
                        @keydown.right.prevent="focusNextButton($event)" @keydown.up.prevent="focusUpButton($event)"
                        @keydown.down.prevent="focusDownButton($event)" tabindex="0" role="button" data-nav="mode-btn">
                        éšæœºç»ƒä¹ 
                        <span class="mode-description">éšæœºé¡ºåºç»ƒä¹ é¢˜ç›®</span>
                    </button>
                    <button class="mode-btn" @click="enterPreviewMode" @keydown.enter.prevent="enterPreviewMode"
                        @keydown.space.prevent="enterPreviewMode" @keydown.left.prevent="focusPrevButton($event)"
                        @keydown.right.prevent="focusNextButton($event)" @keydown.up.prevent="focusUpButton($event)"
                        @keydown.down.prevent="focusDownButton($event)" tabindex="0" role="button" data-nav="mode-btn">
                        é¢„è§ˆæ¨¡å¼
                        <span class="mode-description">æŸ¥çœ‹å’Œç¼–è¾‘æ‰€æœ‰é¢˜ç›®å’Œç­”æ¡ˆ</span>
                    </button>
                </div>
            </div>

            <!-- é¢˜ç›®é¡µé¢ -->
            <div v-else-if="['quiz', 'orderQuiz', 'randomQuiz'].includes(pageState)" class="card">
                <!-- æ·»åŠ å·²æäº¤æ•°é‡æ˜¾ç¤º -->
                <div class="progress-info">
                    å·²æäº¤ï¼š{{ currentSessionCompleted.size }}/{{ quizList.length }}
                </div>

                <div class="question-header">
                    <div class="header-row">
                        <div class="flex-center">
                            <button class="back-button" @click="backToHome">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path d="M19 12H5M12 19l-7-7 7-7" />
                                </svg>
                                è¿”å›
                            </button>
                            <span class="progress-text">
                                {{ practiceManager.currentIndex + 1 }} / {{ practiceManager.questions.length }}
                                <template v-if="chosenSet.isCrossPractice && currentQuestion">
                                    Â· æ¥è‡ªï¼š{{ currentQuestion.sourceBank }}
                                </template>
                            </span>
                        </div>
                        <div class="action-buttons">
                            <button class="action-button" @click="copyCurrentLink" title="å¤åˆ¶å½“å‰é¢˜ç›®é“¾æ¥">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" />
                                    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" />
                                </svg>
                                å¤åˆ¶é“¾æ¥
                            </button>
                            <button class="action-button" @click="saveCurrentEdit"
                                v-if="isEditing && questionManager.checkUnsavedChanges()" title="ä¿å­˜å¹¶å¯¼å‡ºä¿®æ”¹">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                                    <polyline points="17 21 17 13 7 13 7 21" />
                                    <polyline points="7 3 7 8 15 8" />
                                </svg>
                                ä¿å­˜å¹¶å¯¼å‡º
                            </button>
                            <button class="action-button" @click="togglePreviewMode" v-if="isAdmin">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" />
                                    <circle cx="12" cy="12" r="3" />
                                </svg>
                                {{ isPreviewMode ? 'é€€å‡ºé¢„è§ˆ' : 'é¢„è§ˆæ¨¡å¼' }}
                            </button>
                            <button class="action-button" @click="editCurrentQuestion" v-if="isAdmin && !isPreviewMode">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" />
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" />
                                </svg>
                                ç¼–è¾‘
                            </button>
                        </div>
                    </div>
                </div>

                <!-- é¢˜ç›®å†…å®¹ -->
                <div v-if="!isEditing || editingField !== 'content'"
                    @click="isEditing && !isPreviewMode ? enterEditMode('content', currentQuestion.content) : null"
                    class="question-content" :class="{ 'editable': !isPreviewMode && isEditing }">
                    <span v-html="renderedContent"></span>
                    <span v-if="currentQuestion.type === 'multiple-choice'" class="question-type-label">å¤šé€‰é¢˜</span>
                </div>
                <textarea v-else-if="editingField === 'content'" v-model="editingContent" @blur="exitEditMode"
                    class="edit-textarea" rows="8"></textarea>

                <!-- é€‰é¡¹ -->
                <div v-if="currentQuestion.type === 'single-choice' || currentQuestion.type === 'multiple-choice'">
                    <label v-for="(opt, idx) in currentQuestion.options" :key="idx" class="option-item" :class="{
                        'green': showAnswer && (currentQuestion.type === 'single-choice' ? isCorrectOptionSingle(opt) : isCorrectOptionMulti(opt)),
                        'red': showAnswer && (currentQuestion.type === 'single-choice' ? 
                            (isChosenOptionSingle(opt) && !isCorrectOptionSingle(opt)) : 
                            (chosenAnswers.includes(opt) && !isCorrectOptionMulti(opt))),
                        'editable': !isPreviewMode
                    }">
                        <input :type="currentQuestion.type === 'single-choice' ? 'radio' : 'checkbox'"
                            :name="currentQuestion.type === 'single-choice' ? 'single-choice-' + currentQuestion.uniqueId : ''"
                            :value="opt"
                            :checked="currentQuestion.type === 'single-choice' ? chosenAnswer === opt : chosenAnswers.includes(opt)"
                            @change="handleOptionChange(opt, currentQuestion.type === 'single-choice')"
                            :disabled="showAnswer || isEditing || isPreviewMode" class="margin-right-6">
                        <div class="option-content" v-if="!isEditing || editingField !== `option-${idx}`">
                            <strong>{{ letterMap[idx] }}. </strong>
                            <span v-html="renderMarkdownWithLatex(opt)"
                                @click="isEditing && !isPreviewMode ? enterEditMode(`option-${idx}`, opt) : null"></span>
                        </div>
                        <div v-else class="option-edit">
                            <strong>{{ letterMap[idx] }}. </strong>
                            <input type="text" v-model="editingContent" @blur="exitEditMode" class="edit-input">
                        </div>
                    </label>
                </div>

                <div v-else-if="currentQuestion.type === 'short-answer'">
                    <!-- ç®€ç­”é¢˜ -->
                    <textarea v-model="shortAnswerText" :disabled="showAnswer" rows="4" class="full-width-input"
                        placeholder="è¯·è¾“å…¥ä½ çš„ç­”æ¡ˆ"></textarea>
                </div>

                <div v-else-if="currentQuestion.type === 'fill-in-blank'">
                    <!-- å¡«ç©ºé¢˜ -->
                    <div v-for="(blank, idx) in currentQuestion.blanks" :key="idx" class="fill-blank-item">
                        <label :for="'blank-'+idx">ç©º{{idx + 1}}ï¼š</label>
                        <input :id="'blank-'+idx" type="text" v-model="fillInAnswers[idx]" :disabled="showAnswer"
                            class="medium-input" :placeholder="'è¯·å¡«å†™ç©º'+(idx+1)">
                    </div>
                </div>

                <!-- æäº¤ç­”æ¡ˆ / ä¸‹ä¸€é¢˜ æŒ‰é’® -->
                <div class="flex-gap-12">
                    <button type="button" v-if="practiceManager?.currentIndex > 0" class="btn" @click="prevQuestion"
                        title="å¿«æ·é”®ï¼šq">
                        <i class="fas fa-chevron-left"></i> ä¸Šä¸€é¢˜
                    </button>
                    <button type="button" v-if="!showAnswer" class="btn" @click="submitAnswer" title="å¿«æ·é”®ï¼šç©ºæ ¼">
                        æäº¤ç­”æ¡ˆ
                    </button>
                    <button type="button" v-else class="btn" @click="nextQuestion"
                        :disabled="practiceManager?.currentIndex === quizList.length - 1 && isPreviewMode"
                        title="å¿«æ·é”®ï¼šç©ºæ ¼">
                        ä¸‹ä¸€é¢˜ <i class="fas fa-chevron-right"></i>
                    </button>
                    <button type="button" v-if="practiceManager?.currentIndex < quizList.length - 1" class="btn"
                        @click="nextQuestion" title="å¿«æ·é”®ï¼še">
                        è·³è¿‡ <i class="fas fa-forward"></i>
                    </button>
                </div>

                <!-- æ˜¾ç¤ºæ­£ç¡®ç­”æ¡ˆå’ŒAIè¯„åˆ† -->
                <div v-if="showAnswer" class="answer-section">
                    <!-- æ˜¾ç¤ºæ­£ç¡®ç­”æ¡ˆ -->
                    <div class="correct-answer">
                        <h4>å‚è€ƒç­”æ¡ˆï¼š</h4>
                        <template v-if="currentQuestion.type === 'short-answer'">
                            <div v-for="(answer, index) in currentQuestion.correct_answer" :key="index"
                                v-html="renderMarkdownWithLatex(answer)" class="short-answer-content">
                            </div>
                        </template>
                        <template v-else-if="currentQuestion.type === 'fill-in-blank'">
                            <div v-for="(answer, idx) in currentQuestion.correct_answer" :key="idx" class="fill-blank-answer">
                                ç©º{{idx + 1}}ï¼š{{ answer }}
                            </div>
                        </template>
                    </div>

                    <!-- AIè¯„åˆ†åŒºåŸŸ -->
                    <div v-if="currentQuestion.type === 'fill-in-blank' || currentQuestion.type === 'short-answer'" class="ai-score-section">
                        <h4>AIè¯„åˆ†</h4>
                        <div v-if="currentQuestion.aiScoreExplanation" class="markdown-content" v-html="renderMarkdownWithLatex(currentQuestion.aiScoreExplanation)"></div>
                        <div v-else class="empty-message">
                            <template v-if="!practiceManager.aiManager?.getAutoScoring()">
                                <button @click="triggerAIScoring" class="btn btn-primary">AIè¯„åˆ†</button>
                            </template>
                            <template v-else>
                                ç­‰å¾… AI è¯„åˆ†...
                            </template>
                        </div>
                    </div>

                    <!-- è§£æ -->
                    <div class="analysis">
                        <!-- é»˜è®¤è§£æ -->
                        <div class="default-analysis-section">
                            <div class="analysis-header">
                                <h3>é¢˜ç›®è§£æ</h3>
                            </div>
                            
                            <div v-if="(!isEditing || editingField !== 'analysis') && currentQuestion.analysis"
                                @click="isEditing && !isPreviewMode ? enterEditMode('analysis', currentQuestion.analysis) : null"
                                v-html="renderedAnalysis" :class="{ 'editable': isEditing && !isPreviewMode }"></div>
                            <div v-if="(!isEditing || editingField !== 'analysis') && !currentQuestion.analysis"
                                @click="isEditing && !isPreviewMode ? enterEditMode('analysis', '') : null"
                                class="empty-analysis" :class="{ 'editable': isEditing && !isPreviewMode }">
                                æš‚æ— è§£æ
                            </div>
                            <textarea v-else-if="editingField === 'analysis'" v-model="editingContent" @blur="exitEditMode"
                                class="edit-textarea" rows="6" placeholder="è¯·è¾“å…¥è§£æå†…å®¹..."></textarea>
                        </div>

                        <!-- AIè§£æåŒºåŸŸ -->
                        <div class="ai-analysis-section">
                            <div class="analysis-header">
                                <h3>AIè§£æ</h3>
                                <button class="ai-analysis-btn" @click="generateAIAnalysis" :disabled="isGeneratingAnalysis">
                                    <span v-if="!aiAnalysis">ç”Ÿæˆè§£æ</span>
                                    <span v-else>é‡æ–°ç”Ÿæˆ</span>
                                </button>
                            </div>
                            <div v-if="isGeneratingAnalysis" class="generating-message">
                                <div v-if="aiAnalysisExplanation" class="markdown-content" v-html="renderMarkdownWithLatex(aiAnalysisExplanation)"></div>
                                <div v-else>æ­£åœ¨ç”Ÿæˆè§£æ...</div>
                            </div>
                            <div v-else-if="aiAnalysis" class="markdown-content" v-html="renderMarkdownWithLatex(aiAnalysis)"></div>
                            <div v-else class="empty-message">
                                ç‚¹å‡»æŒ‰é’®ç”Ÿæˆ AI è§£æ
                            </div>
                        </div>
                    </div>
                </div>

                <p class="small-text">
                    é”®ç›˜ï¼š1~4 é€‰é¡¹ï¼Œç©ºæ ¼æäº¤/ä¸‹ä¸€é¢˜ï¼ŒShift+Cåˆ‡æ¢è§£æï¼Œq/eåˆ‡æ¢ä¸Šä¸€é¢˜/ä¸‹ä¸€é¢˜
                </p>
            </div>

            <!-- 5) result: æœ€ç»ˆç»“æœ -->
            <div v-else-if="pageState === 'result'" class="card">
                <h1 class="title">ç­”é¢˜å®Œæˆ</h1>
                <p>æœ¬è½®å…± {{ quizList.length }} é¢˜ï¼Œå·²å®Œæˆï¼š{{ completedCount }}ã€‚</p>
                <button type="button" class="btn" @click="pageState = 'home'">
                    è¿”å›é¢˜ç›®é€‰æ‹© 
                </button>
            </div>
        </template>

        <!-- Tags Modal -->
        <div v-if="showTagsModal" class="modal-overlay" @click="showTagsModal = false">
            <div class="modal-content" @click.stop>
                <h2>é€‰æ‹©æ ‡ç­¾</h2>
                <div class="tags-grid">
                    <span v-for="tagInfo in allTags" :key="tagInfo.tag"
                        :class="['tag-chip', { active: selectedTags.includes(tagInfo.tag) }]"
                        @click="toggleTag(tagInfo.tag)">
                        {{ tagInfo.tag }} ({{ tagInfo.count }})
                    </span>
                </div>
                <div class="modal-footer">
                    <button @click="clearTags" class="btn btn-clear">æ¸…é™¤ç­›é€‰</button>
                    <button @click="showTagsModal = false" class="btn btn-close">å…³é—­çª—å£</button>
                </div>
            </div>
        </div>

        <!-- Cross Practice Modal -->
        <div v-if="showCrossPracticeModal" class="modal-overlay" @keydown.stop>
            <div class="modal-content cross-practice-modal" @click.stop @keydown.left.prevent @keydown.right.prevent
                @keydown.up.prevent @keydown.down.prevent>
                <div class="modal-header">
                    <h2>è·¨å·ç»ƒä¹ è®¾ç½®</h2>
                    <button class="modal-close" @click="showCrossPracticeModal = false">&times;</button>
                </div>

                <!-- é¢˜å‹ç­›é€‰ -->
                <div class="setting-section">
                    <h3>é¢˜å‹ç­›é€‰</h3>
                    <div class="question-types">
                        <label v-for="type in questionTypes" :key="type.value" class="type-checkbox">
                            <input type="checkbox" v-model="selectedQuestionTypes" :value="type.value">
                            {{ type.label }}
                        </label>
                    </div>
                </div>

                <!-- ç»ƒä¹ æ¨¡å¼ -->
                <div class="setting-section">
                    <h3>ç»ƒä¹ æ¨¡å¼</h3>
                    <div class="practice-mode">
                        <label class="mode-radio">
                            <input type="radio" v-model="crossPracticeMode" value="random">
                            éšæœºæŠ½é¢˜
                        </label>
                        <label class="mode-radio">
                            <input type="radio" v-model="crossPracticeMode" value="error-rate">
                            é”™è¯¯ç‡ä¼˜å…ˆ
                        </label>
                    </div>
                </div>

                <!-- é¢˜ç›®æ•°é‡ -->
                <div class="setting-section">
                    <h3>ç»ƒä¹ é¢˜æ•°</h3>
                    <div class="question-count">
                        <input type="number" :value="crossPracticeCount" min="1" :max="maxQuestionCount"
                            class="count-input" @input="handleQuestionInput" @blur="handleQuestionBlur" @keydown.stop
                            @keydown.left.prevent @keydown.right.prevent @keydown.up.prevent @keydown.down.prevent
                            ref="countInput">
                        <span class="max-count" :class="{ 'error': crossPracticeCount > maxQuestionCount }">
                            å½“å‰å¯é€‰ {{ maxQuestionCount }} é¢˜
                            <template v-if="crossPracticeCount > maxQuestionCount">
                                (è¶…å‡ºé™åˆ¶)
                            </template>
                        </span>
                    </div>
                </div>

                <!-- å‚ä¸é¢˜åº“åŠå æ¯” -->
                <div class="setting-section">
                    <h3>å‚ä¸é¢˜åº“åŠå æ¯”</h3>
                    <div class="bank-distribution">
                        <div v-for="bank in filteredBankDistribution" :key="bank.file" class="bank-item">
                            <div class="bank-name">{{ bank.name }}</div>
                            <div class="bank-count">
                                {{ bank.questionCount }}/{{ bank.availableQuestions }}é¢˜
                                ({{ calculateBankPercentage(bank) }}%)
                            </div>
                            <div class="bank-progress">
                                <div class="progress-bar" :style="{ width: calculateBankPercentage(bank) + '%' }"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="modal-footer">
                    <button @click="showCrossPracticeModal = false" class="btn btn-clear">å–æ¶ˆ</button>
                    <button @click="startCrossPractice" class="btn btn-primary" :disabled="!canStartCrossPractice">
                        å¼€å§‹ç»ƒä¹ 
                    </button>
                </div>
            </div>
        </div>

        <!-- åœ¨ template ä¸­æ›´æ–° banner çš„ HTML ç»“æ„ -->
        <div v-if="banner.show" :class="['banner', banner.type]" role="alert">
            <div class="banner-content">{{ banner.content }}</div>
            <button v-if="banner.closeable" 
                    class="banner-close" 
                    @click="closeBanner"
                    aria-label="å…³é—­æç¤º">
                Ã—
            </button>
        </div>
    </div>

    <script type="module">
        import StorageManager from './js/modules/storage.js';
        import JsonLoader from './js/modules/jsonLoader.js';
        import KeyboardManager from './js/modules/keyboard.js';
        import QuestionManager from './js/modules/QuestionManager.js';
        import PracticeManager from './js/modules/PracticeManager.js';
        // å¯¼å…¥ AI ç®¡ç†å™¨
        import { aiManager } from './js/modules/AIManager.js';

        // æ‰©å±• Vue åº”ç”¨é…ç½®
        const appConfig = {
            data() {
                return {
                    storageManager: new StorageManager(),
                    jsonLoader: null,
                    keyboardManager: null,
                    questionManager: null,
                    practiceManager: null,
                    pageState: 'home',
                    isLoading: false,
                    loadError: null,
                    fileList: [],
                    groupedFileList: [],
                    chosenSet: null,
                    showAnswer: false,
                    isEditing: false,
                    editingField: null,
                    editingContent: '',
                    showExportButton: false,
                    chosenAnswer: null,
                    chosenAnswers: [],
                    shortAnswerText: '',
                    fillInAnswers: [],
                    currentSessionCompleted: new Set(),
                    modifiedCount: 0,
                    showUnsavedModal: false,
                    dontShowExportReminder: false,
                    groupedModifiedQuestions: {},
                    lastExportTimestamp: null,
                    updateTime: null,
                    showTagsModal: false,
                    selectedTags: [],
                    topTags: [],
                    allTags: [],
                    bankStats: {},
                    _altHPressed: false,
                    hoverTitle: false,  // æ·»åŠ  hoverTitle æ•°æ®å±æ€§
                    // è·¨å·ç»ƒä¹ ç›¸å…³
                    _showCrossPracticeModal: false,
                    selectedQuestionTypes: ['single-choice', 'multiple-choice', 'fill-in-blank', 'short-answer'],
                    crossPracticeMode: 'random',
                    crossPracticeCount: 30,
                    questionTypes: [
                        { value: 'single-choice', label: 'å•é€‰é¢˜' },
                        { value: 'multiple-choice', label: 'å¤šé€‰é¢˜' },
                        { value: 'fill-in-blank', label: 'å¡«ç©ºé¢˜' },
                        { value: 'short-answer', label: 'ç®€ç­”é¢˜' }
                    ],
                    showAIModal: false, // é»˜è®¤ä¸æ˜¾ç¤º AI é…ç½®çª—å£
                    showSoundModal: false, // é»˜è®¤ä¸æ˜¾ç¤ºéŸ³æ•ˆé…ç½®çª—å£
                    providerApiKeys: {},
                    autoScoring: aiManager.getAutoScoring(), // AI è‡ªåŠ¨è¯„åˆ†è®¾ç½®
                    userMessage: '',
                    aiResponse: '',
                    isProcessing: false,
                    selectedPresetId: aiManager.selectedPresetId,
                    presets: aiManager.getPresets(),
                    activeTab: 'edit',
                    reasoningContent: '',
                    currentResponseType: null,
                    // AI è§£æç›¸å…³
                    aiAnalysis: null,
                    testStreamContent: '',
                    isTestingStream: false,
                    testPrompt: 'è¯·è§£é‡ŠTCPä¸‰æ¬¡æ¡æ‰‹çš„è¿‡ç¨‹ã€‚',
                    isGeneratingAnalysis: false,
                    aiAnalysisExplanation: '', // æ·»åŠ ç”¨äºæµå¼æ¸²æŸ“çš„çŠ¶æ€
                    // éŸ³æ•ˆé…ç½®ç›¸å…³
                    audioEnabled: false,
                    volumeValue: 100,
                    comboWindowMs: 3000,
                    resetTimeoutMs: 5000,
                    audioManager: null,
                    // è®¡åˆ†å’Œè®¡æ—¶ç›¸å…³
                    currentScore: 0,
                    timerProgress: 0,
                    timeLeft: 0,
                    timerInterval: null,
                    toasts: [], // Array to store active toasts
                    banner: {
                        show: false,
                        content: '',
                        type: 'info',
                        closeable: true
                    },
                    bannerTimer: null,
                }
            },
            mounted() {
                // åˆå§‹åŒ– AI é…ç½®
                this.initAIConfig();

                // åˆå§‹åŒ–éŸ³æ•ˆé…ç½®
                this.initSoundConfig();

                // æ¯ç§’æ›´æ–°ä¸€æ¬¡æ—¥å¿—æ˜¾ç¤º
                setInterval(() => {
                    this.logs = [...aiManager.getLogs()];
                }, 1000);

                // åˆå§‹åŒ–é”®ç›˜äº‹ä»¶ç›‘å¬
                this.initKeyboardEvents();
            },
            beforeUnmount() {
                // æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
                window.removeEventListener('popstate', this.handlePopState);
                window.removeEventListener('hashchange', this.handleUrlChange);
                window.removeEventListener('popstate', this.handleUrlChange);
                window.removeEventListener('keydown', this.handleGlobalBackShortcut);
            },
            watch: {
                // éŸ³æ•ˆé…ç½®ç›¸å…³çš„ç›‘å¬å™¨
                showSoundModal: {
                    handler(newValue) {
                        if (newValue) {
                            // æ‰“å¼€æ¨¡æ€æ—¶ï¼Œå¼€å§‹è®¡æ—¶å™¨å¹¶åŒæ­¥åˆ†æ•°
                            if (this.audioManager) {
                                this.currentScore = this.audioManager.getScore();
                                this.startTimer();
                            }
                        } else {
                            // å…³é—­æ¨¡æ€æ—¶ï¼Œåœæ­¢è®¡æ—¶å™¨
                            this.stopTimer();
                        }
                    }
                },
                audioEnabled: {
                    handler(newValue) {
                        if (this.audioManager) {
                            this.audioManager.positiveAudios.forEach(audio => audio.muted = !newValue);
                            this.audioManager.negativeAudios.forEach(audio => audio.muted = !newValue);
                            this.updateAudioConfig();
                        }
                    }
                },
                volumeValue: {
                    handler(newValue) {
                        if (this.audioManager) {
                            const volume = newValue / 100;
                            this.audioManager.positiveAudios.forEach(audio => audio.volume = volume);
                            this.audioManager.negativeAudios.forEach(audio => audio.volume = volume);
                            this.updateAudioConfig();
                        }
                    }
                },
                comboWindowMs: {
                    handler() {
                        this.updateAudioConfig();
                    }
                },
                resetTimeoutMs: {
                    handler() {
                        this.updateAudioConfig();
                    }
                },
                selectedQuestionTypes: {
                    handler() {
                        console.log('[selectedQuestionTypes] Question types changed, updating distribution');
                        this.updateBankDistribution();
                    },
                    deep: true
                },
                pageState: {
                    handler(newState, oldState) {
                        console.log('Page state changed:', {
                            from: oldState,
                            to: newState
                        });
                        if (newState === 'setDescription') {
                            this.$nextTick(() => {
                                const buttons = document.querySelectorAll('.mode-btn');
                                console.log('Mode buttons after state change:', {
                                    totalButtons: buttons.length,
                                    buttonElements: Array.from(buttons).map(btn => ({
                                        text: btn.textContent.trim(),
                                        tabIndex: btn.tabIndex,
                                        hasClickHandler: btn.onclick !== null,
                                        hasKeydownHandler: btn.onkeydown !== null
                                    }))
                                });
                            });
                        }
                    },
                    immediate: true
                },
                'practiceManager.currentIndex': {
                    handler(newIndex) {
                        console.log('[watch] currentIndex changed:', newIndex);
                        if (this.practiceManager && this.practiceManager.questions) {
                            const currentQuestion = this.practiceManager.questions[newIndex];
                            console.log('[watch] Current question:', currentQuestion);
                            if (currentQuestion) {
                                // ç¡®ä¿ä¿æŒ bank å‚æ•°
                                const currentFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                                this.updateUrlParams('quiz', {
                                    mode: this.getCurrentMode(),
                                    qid: newIndex + 1, // ä½¿ç”¨é¢˜ç›®åºå·ï¼ˆä»1å¼€å§‹ï¼‰
                                    bank: currentFile
                                });
                            }
                        }
                    },
                    immediate: true
                },
                // ç›‘å¬ AI å“åº”å˜åŒ–ï¼Œè‡ªåŠ¨æ¸²æŸ“æ•°å­¦å…¬å¼
                renderedResponse() {
                    this.$nextTick(() => {
                        if (window.renderMathInElement) {
                            window.renderMathInElement(this.$refs.chatArea, {
                                delimiters: [
                                    { left: '$$', right: '$$', display: true },
                                    { left: '$', right: '$', display: false }
                                ]
                            });
                        }
                    });
                },
                // ç›‘å¬æ€ç»´é“¾å†…å®¹å˜åŒ–ï¼Œå®æ—¶æ¸²æŸ“æ•°å­¦å…¬å¼
                reasoningContent() {
                    this.$nextTick(() => {
                        if (window.renderMathInElement && this.$refs.chatArea) {
                            window.renderMathInElement(this.$refs.chatArea, {
                                delimiters: [
                                    { left: '$$', right: '$$', display: true },
                                    { left: '$', right: '$', display: false }
                                ]
                            });
                        }
                    });
                },
                // ç›‘å¬æ˜¾ç¤ºç­”æ¡ˆçŠ¶æ€
                showAnswer(newVal) {
                    // ä¸å†åœ¨è¿™é‡Œè§¦å‘ AI è¯„åˆ†ï¼Œå› ä¸ºå·²ç»åœ¨ submitAnswer ä¸­å¤„ç†äº†
                }
            },
            async created() {
                // åˆå§‹åŒ–å„ä¸ªç®¡ç†å™¨
                this.jsonLoader = new JsonLoader();
                this.keyboardManager = new KeyboardManager(this);
                this.questionManager = new QuestionManager(this.storageManager);
                this.practiceManager = new PracticeManager(this.storageManager);
                this.practiceManager.setAIManager(aiManager);

                // å…ˆåŠ è½½é¢˜åº“åˆ—è¡¨
                await this.loadBankList();

                // ç„¶åå¤„ç†URLå‚æ•°
                await this.handleUrlParams();

                // è®¾ç½®åˆå§‹æ—¥å¿—çº§åˆ«ä¸º debugï¼Œä»¥ä¾¿æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯
                aiManager.setLogLevel('debug');

                // é…ç½® marked é€‰é¡¹
                marked.setOptions({
                    breaks: true, // æ”¯æŒ GitHub é£æ ¼çš„æ¢è¡Œ
                    gfm: true,    // å¯ç”¨ GitHub é£æ ¼çš„ Markdown
                    highlight: function (code, lang) {
                        if (window.hljs && lang) {
                            try {
                                return hljs.highlight(code, {
                                    language: lang,
                                    ignoreIllegals: true
                                }).value;
                            } catch (e) {
                                return hljs.highlightAuto(code).value;
                            }
                        }
                        return code;
                    }
                });

                // åˆå§‹åŒ–é€‰ä¸­çš„é¢„è®¾
                this.selectedPresetId = aiManager.selectedPresetId;

                // åˆå§‹åŒ–å„ä¸ª provider çš„ API Key
                Object.values(this.presets).forEach(preset => {
                    if (preset.provider) {
                        this.providerApiKeys[preset.provider] = aiManager.getApiKey(preset.provider);
                    }
                });
            },
            computed: {
                currentQuestion() {
                    return this.practiceManager?.getCurrentQuestion() || null;
                },
                currentIndex() {
                    return this.practiceManager?.currentIndex || 0;
                },
                quizList() {
                    return this.practiceManager?.questions || [];
                },
                isPreviewMode() {
                    return this.practiceManager?.isPreviewMode || false;
                },
                totalStats() {
                    const stats = this.storageManager.getAllBanksStats();
                    console.log('[totalStats computed] Raw stats from storage:', stats);
                    return {
                        completedQuestions: stats.completedQuestions || 0,
                        totalAttempts: stats.totalAttempts || 0,
                        averageAccuracy: stats.averageAccuracy || 0,
                        todayPracticed: stats.todayPracticed || 0,
                    };
                },
                setStats() {
                    if (!this.chosenSet) return null;
                    const stats = this.storageManager.getSetStats(this.chosenSet.id, this.jsonLoader.questions);
                    const today = new Date().toISOString().split('T')[0];

                    // è·å–ä»Šæ—¥ç»ƒä¹ é¢˜æ•°
                    const todayCount = this.jsonLoader.questions.reduce((count, q) => {
                        const completion = this.storageManager.getQuestionCompletion(this.chosenSet.id, q.uniqueId);
                        if (completion && completion.lastAttemptDate === today) {
                            return count + 1;
                        }
                        return count;
                    }, 0);

                    return {
                        ...stats,
                        todayCount,
                        averageAccuracy: stats.totalAttempts > 0
                            ? Math.round((stats.totalCorrect / stats.totalAttempts) * 100)
                            : 0
                    };
                },
                renderedContent() {
                    if (!this.currentQuestion.content) return '';
                    return this.renderMarkdownWithLatex(this.currentQuestion.content);
                },
                renderedAnalysis() {
                    if (!this.currentQuestion.analysis) return '';
                    return this.renderMarkdownWithLatex(this.currentQuestion.analysis);
                },
                progressText() {
                    return `æœ¬æ¬¡ç»ƒä¹ å®Œæˆåº¦ï¼š${this.currentSessionCompleted.size}/${this.quizList.length}`;
                },
                completedCount() {
                    return this.currentSessionCompleted.size;
                },
                letterMap() {
                    return ['A', 'B', 'C', 'D', 'E', 'F'];
                },
                hoverTitle() {
                    return false;
                },
                hasChanges() {
                    return false;
                },
                changesExported() {
                    return false;
                },
                questionStats() {
                    if (!this.chosenSet || !this.currentQuestion) return null;
                    return this.storageManager.getQuestionStats(
                        this.chosenSet.id,
                        this.currentQuestion.uniqueId
                    );
                },
                filteredGroupedFileList() {
                    if (this.selectedTags.length === 0) return this.groupedFileList;

                    return this.groupedFileList.map(([category, items]) => {
                        const filteredItems = items.filter(item =>
                            this.selectedTags.every(tag => item.tags && item.tags.includes(tag))
                        );
                        return [category, filteredItems];
                    }).filter(([_, items]) => items.length > 0);
                },
                // è·¨å·ç»ƒä¹ ç›¸å…³çš„è®¡ç®—å±æ€§
                filteredBankDistribution() {
                    // è·å–ç¬¦åˆå½“å‰æ ‡ç­¾å’Œé¢˜å‹ç­›é€‰çš„é¢˜åº“åŠé¢˜ç›®æ•°
                    const distribution = [];

                    // éå†æ‰€æœ‰é¢˜åº“
                    this.fileList.forEach(bank => {
                        // æ£€æŸ¥æ ‡ç­¾ç­›é€‰
                        if (this.selectedTags.length > 0 &&
                            !this.selectedTags.every(tag => bank.tags && bank.tags.includes(tag))) {
                            return;
                        }

                        // è·å–é¢˜åº“ä¸­ç¬¦åˆé¢˜å‹çš„é¢˜ç›®æ•°é‡
                        const questions = this.jsonLoader.getQuestionsFromBank(bank.file);
                        const filteredQuestions = questions.filter(q =>
                            this.selectedQuestionTypes.includes(q.type)
                        );

                        if (filteredQuestions.length > 0) {
                            distribution.push({
                                file: bank.file,
                                name: bank.name,
                                questionCount: 0, // åˆå§‹åŒ–ä¸º0ï¼Œå®é™…åˆ†é…ç”±updateBankDistributionå¤„ç†
                                availableQuestions: filteredQuestions.length,
                                questions: filteredQuestions
                            });
                        }
                    });

                    return distribution;
                },

                maxQuestionCount() {
                    // è®¡ç®—æ‰€æœ‰å¯ç”¨é¢˜ç›®çš„æ€»æ•°
                    return this.filteredBankDistribution.reduce(
                        (sum, bank) => sum + bank.availableQuestions,
                        0
                    );
                },

                canStartCrossPractice() {
                    return this.selectedQuestionTypes.length > 0 &&
                        this.crossPracticeCount > 0 &&
                        this.crossPracticeCount <= this.maxQuestionCount &&
                        this.filteredBankDistribution.length > 0;
                },
                showCrossPracticeModal: {
                    get() {
                        return this._showCrossPracticeModal;
                    },
                    set(value) {
                        this._showCrossPracticeModal = value;
                        if (value) {
                            // æ‰“å¼€æ¨¡æ€æ¡†æ—¶åˆå§‹åŒ–
                            this.$nextTick(() => {
                                // å…ˆæ›´æ–°é¢˜åº“åˆ†å¸ƒ
                                this.updateBankDistribution();
                                // å¦‚æœå½“å‰é€‰æ‹©çš„é¢˜ç›®æ•°å¤§äºæœ€å¤§å¯é€‰æ•°ï¼Œè‡ªåŠ¨è°ƒæ•´
                                if (this.crossPracticeCount > this.maxQuestionCount) {
                                    console.log(`[showCrossPracticeModal] Adjusting initial count from ${this.crossPracticeCount} to ${this.maxQuestionCount}`);
                                    this.crossPracticeCount = this.maxQuestionCount;
                                }
                                // å†æ¬¡æ›´æ–°åˆ†å¸ƒä»¥ç¡®ä¿ç™¾åˆ†æ¯”æ­£ç¡®
                                this.updateBankDistribution();
                            });
                        }
                    }
                },
                currentPreset() {
                    return this.presets[this.selectedPresetId];
                },
                currentProvider() {
                    return this.currentPreset?.provider;
                },
                hasValidApiKey() {
                    return this.currentProvider && this.providerApiKeys[this.currentProvider];
                },
                filteredLogs() {
                    return aiManager.getLogs(this.logLevel);
                },
                // æ¸²æŸ“ Markdown é¢„è§ˆ
                renderedPreview() {
                    return this.userMessage ? marked.parse(this.userMessage) : '';
                },
                // æ¸²æŸ“ AI å“åº”
                renderedResponse() {
                    return this.aiResponse ? marked.parse(this.aiResponse) : '';
                },
                // æ¸²æŸ“æ€ç»´é“¾å†…å®¹
                renderedReasoningContent() {
                    return this.reasoningContent ? marked.parse(this.reasoningContent) : '';
                }
            },
            methods: {
                // åŠ è½½é¢˜åº“åˆ—è¡¨
                async loadBankList() {
                    this.isLoading = true;
                    this.loadError = null;
                    try {
                        const response = await fetch('assets/list.json');
                        const data = await response.json();
                        this.fileList = data.banks || [];
                        this.updateTime = data.updateTime;

                        // åˆå§‹åŒ– jsonLoader
                        if (!this.jsonLoader) {
                            this.jsonLoader = new JsonLoader();
                        }

                        // åŠ è½½æ¯ä¸ªé¢˜åº“çš„ç»Ÿè®¡ä¿¡æ¯
                        for (const bank of this.fileList) {
                            try {
                                // å…ˆåŠ è½½é¢˜åº“æ•°æ®
                                await this.jsonLoader.loadFile(bank.file);
                                // ç„¶åè·å–ç»Ÿè®¡ä¿¡æ¯
                                const stats = await this.storageManager.getBankStats(bank.file, this.jsonLoader);
                                this.bankStats[bank.file] = stats;
                            } catch (error) {
                                console.error(`Error loading bank ${bank.file}:`, error);
                                this.bankStats[bank.file] = {
                                    totalQuestions: 0,
                                    uniquePracticed: 0,
                                    totalSubmissions: 0
                                };
                            }
                        }

                        // åŠ è½½æ¯ä¸ªé¢˜åº“çš„setsä¿¡æ¯ä»¥è·å–categoryå’Œtags
                        const fileCategories = {};
                        const fileTags = {};
                        const tagsCount = new Map();

                        for (const bank of this.fileList) {
                            try {
                                const bankData = await this.jsonLoader.loadFile(bank.file);
                                const category = bankData.sets[0]?.category || 'æœªåˆ†ç±»';
                                const tags = bankData.sets[0]?.tags || [];

                                fileCategories[bank.file] = category;
                                fileTags[bank.file] = tags;

                                // ç»Ÿè®¡tags
                                tags.forEach(tag => {
                                    tagsCount.set(tag, (tagsCount.get(tag) || 0) + 1);
                                });
                            } catch (error) {
                                console.error(`Error loading bank ${bank.file}:`, error);
                                fileCategories[bank.file] = 'æœªåˆ†ç±»';
                                fileTags[bank.file] = [];
                            }
                        }

                        // æ›´æ–°fileListæ·»åŠ tagsä¿¡æ¯
                        this.fileList = this.fileList.map(bank => ({
                            ...bank,
                            tags: fileTags[bank.file] || []
                        }));

                        // è·å–å‰ä¸‰ä¸ªæœ€å¸¸ç”¨çš„tags
                        this.topTags = Array.from(tagsCount.entries())
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 3)
                            .map(([tag, count]) => ({ tag, count }));

                        // è·å–æ‰€æœ‰tags
                        this.allTags = Array.from(tagsCount.entries())
                            .sort((a, b) => b[1] - a[1])
                            .map(([tag, count]) => ({ tag, count }));

                        // æŒ‰categoryå¯¹é¢˜åº“è¿›è¡Œåˆ†ç»„
                        const groups = {};
                        this.fileList.forEach(bank => {
                            const category = fileCategories[bank.file] || 'æœªåˆ†ç±»';
                            if (!groups[category]) {
                                groups[category] = [];
                            }
                            groups[category].push(bank);
                        });

                        // å¯¹æ¯ä¸ªåˆ†ç±»å†…çš„é¢˜åº“æŒ‰åç§°æ’åº
                        for (const category in groups) {
                            groups[category].sort((a, b) => a.name.localeCompare(b.name));
                        }

                        // è½¬æ¢ä¸ºæ•°ç»„å¹¶æŒ‰åˆ†ç±»åæ’åºï¼Œç¡®ä¿"æœªåˆ†ç±»"æ°¸è¿œåœ¨æœ€å
                        this.groupedFileList = Object.entries(groups)
                            .sort((a, b) => {
                                if (a[0] === 'æœªåˆ†ç±»') return 1;
                                if (b[0] === 'æœªåˆ†ç±»') return -1;
                                return a[0].localeCompare(b[0]);
                            });
                    } catch (error) {
                        console.error('Error loading file list:', error);
                        this.loadError = error.message;
                    }
                    this.isLoading = false;
                },

                // åŠ è½½é¢˜åº“æ–‡ä»¶
                async loadJsonFile(fileName) {
                    console.log('[loadJsonFile] Starting to load file:', fileName);
                    if (this.isLoading) {
                        console.log('[loadJsonFile] Already loading, skipping');
                        return;
                    }
                    this.isLoading = true;
                    try {
                        console.log('[loadJsonFile] Loading data from file');
                        const data = await this.jsonLoader.loadFile(fileName);
                        console.log('[loadJsonFile] Data loaded:', {
                            setName: data.sets[0]?.name,
                            questionCount: data.questions?.length
                        });

                        // Set chosenSet with proper id
                        this.chosenSet = {
                            ...data.sets[0],
                            id: fileName.replace('.json', '') // Ensure id matches the file name without extension
                        };

                        // æ›´æ–°ç»Ÿè®¡æ•°æ®
                        console.log('[loadJsonFile] Updating bank stats');
                        const stats = await this.storageManager.getBankStats(fileName, this.jsonLoader);
                        this.bankStats[fileName] = stats;

                        // æ›´æ–°URLå¹¶åˆ‡æ¢åˆ°é¢˜åº“è¯¦æƒ…é¡µ
                        console.log('[loadJsonFile] Updating page state to setDescription');
                        this.updatePageState('setDescription');
                    } catch (error) {
                        console.error('[loadJsonFile] Failed to load bank:', error);
                        alert('åŠ è½½é¢˜åº“å¤±è´¥: ' + error.message);
                    } finally {
                        this.isLoading = false;
                        console.log('[loadJsonFile] Loading completed');
                    }
                },

                // å¼€å§‹ç»ƒä¹ 
                startQuiz(mode) {
                    switch (mode) {
                        case 'all':
                            this.enterQuizMode();
                            break;
                        case 'wrong':
                            this.enterOrderQuizMode();
                            break;
                        case 'random':
                            this.enterRandomQuizMode();
                            break;
                        case 'preview':
                            this.enterPreviewMode();
                            break;
                    }
                },

                // è¿›å…¥ç»ƒä¹ æ¨¡å¼
                enterQuizMode() {
                    this.practiceManager.initPractice(this.jsonLoader.questions, 'sequence');
                    this.practiceManager.togglePreviewMode(false);
                    this.showAnswer = false;
                    this.currentSessionCompleted.clear();
                    this.updatePageState('quiz', {
                        mode: 'all',
                        qid: 1 // ä»ç¬¬ä¸€é¢˜å¼€å§‹
                    });
                },

                enterOrderQuizMode() {
                    this.practiceManager.initPractice(this.jsonLoader.questions, 'error-rate');
                    this.practiceManager.togglePreviewMode(false);
                    this.showAnswer = false;
                    this.currentSessionCompleted.clear();
                    this.updatePageState('quiz', {
                        mode: 'wrong',
                        qid: 1 // ä»ç¬¬ä¸€é¢˜å¼€å§‹
                    });
                },

                enterRandomQuizMode() {
                    this.practiceManager.initPractice(this.jsonLoader.questions, 'random');
                    this.practiceManager.togglePreviewMode(false);
                    this.showAnswer = false;
                    this.currentSessionCompleted.clear();
                    this.updatePageState('quiz', {
                        mode: 'random',
                        qid: 1 // ä»ç¬¬ä¸€é¢˜å¼€å§‹
                    });
                },

                enterPreviewMode() {
                    this.practiceManager.initPractice(this.jsonLoader.questions, 'sequence');
                    this.practiceManager.togglePreviewMode(false); // å…³é—­é¢„è§ˆæ¨¡å¼
                    this.showAnswer = true; // æ˜¾ç¤ºè§£æ
                    this.isEditing = true; // å¯ç”¨ç¼–è¾‘æ¨¡å¼
                    this.questionManager.startEditing(this.jsonLoader.questions[0]); // å¼€å§‹ç¼–è¾‘ç¬¬ä¸€é¢˜
                    this.showExportButton = true; // æ˜¾ç¤ºå¯¼å‡ºæŒ‰é’®
                    this.updatePageState('quiz', {
                        mode: 'preview',
                        qid: 1 // ä»ç¬¬ä¸€é¢˜å¼€å§‹
                    });
                },

                // ç¼–è¾‘ç›¸å…³æ–¹æ³•
                editQuestion() {
                    if (this.isPreviewMode) return;
                    console.log('Starting edit mode for question:', this.currentQuestion);
                    this.questionManager.startEditing(this.currentQuestion);
                    this.isEditing = true;
                    this.showExportButton = true;
                    // è‡ªåŠ¨åˆ‡æ¢åˆ°è§£ææ¨¡å¼
                    this.showAnswer = true;
                },

                enterEditMode(field, content) {
                    if (this.isPreviewMode) return;
                    console.log('Entering edit mode:', {
                        field,
                        content,
                        currentContent: content || 'ç‚¹å‡»ç¼–è¾‘'
                    });
                    this.editingField = field;
                    this.editingContent = content || '';
                },

                exitEditMode() {
                    console.log('Exiting edit mode:', {
                        field: this.editingField,
                        content: this.editingContent,
                        question: this.currentQuestion
                    });

                    if (this.editingField && this.editingContent !== undefined) {
                        const question = this.currentQuestion;
                        if (this.editingField === 'content') {
                            question.content = this.editingContent;
                        } else if (this.editingField === 'analysis') {
                            question.analysis = this.editingContent;
                        } else if (this.editingField.startsWith('option-')) {
                            const idx = parseInt(this.editingField.split('-')[1]);
                            question.options[idx] = this.editingContent;
                        }
                        this.questionManager.saveCurrentEdit();
                        // æ›´æ–°ä¿®æ”¹è®¡æ•°
                        this.modifiedCount = this.questionManager.getModifiedQuestions().length;
                    }
                    this.editingField = null;
                    this.editingContent = '';
                },

                // é€€å‡ºæ•´ä¸ªç¼–è¾‘æ¨¡å¼
                exitEntireEditMode() {
                    if (this.editingField) {
                        this.exitEditMode();
                    }
                    this.isEditing = false;
                    this.showAnswer = false;
                    this.showExportButton = false;
                    this.questionManager.cancelEditing();
                },

                // å¯¼å‡ºç›¸å…³æ–¹æ³•
                handleExport(questions) {
                    const exportData = {
                        questions: questions,
                        sets: [this.chosenSet]
                    };

                    const blob = new Blob([JSON.stringify(exportData, null, 4)],
                        { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    // ä»fileListä¸­è·å–å½“å‰é¢˜åº“çš„æ–‡ä»¶å
                    const currentFile = this.fileList.find(f => f.name === this.chosenSet.name)?.file;
                    a.download = this.questionManager.generateExportFileName(currentFile || 'export');
                    a.click();
                    URL.revokeObjectURL(url);

                    // æ›´æ–°å¯¼å‡ºçŠ¶æ€
                    this.lastExportTimestamp = Date.now();
                    this.modifiedCount = 0;
                    this.questionManager.clearModifiedQuestions();
                    this.showExportButton = false;
                    this.isEditing = false;
                    this.showUnsavedModal = false;
                },

                // å¯¼å‡ºä¿®æ”¹
                exportModifiedData() {
                    const modifiedQuestions = this.questionManager.getModifiedQuestions();
                    const questions = this.jsonLoader.questions.map(q => {
                        if (modifiedQuestions.includes(q.uniqueId)) {
                            return { ...q };
                        }
                        return q;
                    });
                    this.handleExport(questions);
                },

                // çŠ¶æ€æ›´æ–°
                updatePageState(newState, params = {}) {
                    console.log('[updatePageState] from:', this.pageState, 'to:', newState, 'params:', params);
                    // å¦‚æœæœ‰æœªå¯¼å‡ºçš„ä¿®æ”¹ï¼Œä¸”ä¸æ˜¯åˆšåˆšå¯¼å‡ºçš„ï¼Œä¸”ä¸æ˜¯åœ¨ç¼–è¾‘æ¨¡å¼ä¸­
                    if (this.modifiedCount > 0 && !this.dontShowExportReminder &&
                        (!this.lastExportTimestamp || Date.now() - this.lastExportTimestamp > 1000) &&
                        !this.isEditing) {
                        const hasUnsaved = this.checkModifiedQuestions();
                        if (hasUnsaved) {
                            return;
                        }
                    }

                    if (this.isEditing && this.questionManager.checkUnsavedChanges()) {
                        this.showUnsavedDialog(newState);
                        return;
                    }

                    this.pageState = newState;

                    // å¦‚æœæ˜¯è¿”å›é¢˜åº“è¯¦æƒ…é¡µï¼Œç¡®ä¿ä¼ é€’å½“å‰é¢˜åº“å‚æ•°
                    if (newState === 'setDescription' && this.chosenSet) {
                        const currentFile = this.fileList.find(f => f.name === this.chosenSet.name)?.file;
                        if (currentFile) {
                            params.bank = currentFile;
                        }
                    }

                    // å¦‚æœæ˜¯è¿›å…¥ç­”é¢˜é¡µé¢ï¼Œç¡®ä¿ä¼ é€’å½“å‰é¢˜ç›®åºå·
                    if (newState === 'quiz' && this.practiceManager) {
                        params.qid = params.qid || (this.practiceManager.currentIndex + 1);
                    }

                    // æ›´æ–°URLå‚æ•°
                    this.updateUrlParams(newState, params);

                    if (newState === 'home') {
                        this.questionManager.clearEditHistory();
                        this.showExportButton = false;
                    }
                },

                showUnsavedDialog(action) {
                    const dialog = document.createElement('div');
                    dialog.className = 'modal-overlay';
                    dialog.innerHTML = `
                    <div class="modal-content modal-btn">
                        <h3>æœªä¿å­˜çš„ä¿®æ”¹</h3>
                        <p>å½“å‰é¢˜ç›®æœ‰æœªä¿å­˜çš„ä¿®æ”¹ï¼Œè¯·é€‰æ‹©æ“ä½œï¼š</p>
                        <div class="modal-btn-group">
                            <button class="btn btn-continue-edit" id="continueEdit">ç»§ç»­ç¼–è¾‘</button>
                            <button class="btn btn-save-export" id="saveAndExport">ä¿å­˜å¯¼å‡º</button>
                            <button class="btn btn-discard" id="discardAndContinue">æ”¾å¼ƒä¿®æ”¹</button>
                        </div>
                    </div>
                `;

                    document.body.appendChild(dialog);

                    // ç¡®ä¿å…ƒç´ å·²ç»æ·»åŠ åˆ°DOMåå†æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
                    const continueEditBtn = dialog.querySelector('#continueEdit');
                    const saveAndExportBtn = dialog.querySelector('#saveAndExport');
                    const discardBtn = dialog.querySelector('#discardAndContinue');

                    if (continueEditBtn && saveAndExportBtn && discardBtn) {
                        // ç‚¹å‡»é®ç½©å±‚å…³é—­å¯¹è¯æ¡†ï¼ˆç»§ç»­ç¼–è¾‘ï¼‰
                        dialog.addEventListener('click', (e) => {
                            if (e.target === dialog) {
                                document.body.removeChild(dialog);
                            }
                        });

                        // ç»§ç»­ç¼–è¾‘
                        continueEditBtn.addEventListener('click', () => {
                            document.body.removeChild(dialog);
                        });

                        // ä¿å­˜å¹¶å¯¼å‡º
                        saveAndExportBtn.addEventListener('click', () => {
                            this.questionManager.saveCurrentEdit();
                            this.exportModifiedData();
                            document.body.removeChild(dialog);

                            // æ ¹æ®actionæ‰§è¡Œç›¸åº”æ“ä½œ
                            this.handleActionAfterSave(action);
                        });

                        // æ”¾å¼ƒä¿®æ”¹å¹¶ç»§ç»­
                        discardBtn.addEventListener('click', () => {
                            this.questionManager.cancelEditing();
                            document.body.removeChild(dialog);

                            // æ ¹æ®actionæ‰§è¡Œç›¸åº”æ“ä½œ
                            this.handleActionAfterSave(action);
                        });
                    } else {
                        console.error('Failed to find dialog buttons');
                        document.body.removeChild(dialog);
                    }
                },

                // å¤„ç†ä¿å­˜åçš„æ“ä½œ
                handleActionAfterSave(action) {
                    if (action === 'next') {
                        this.practiceManager.currentIndex++;
                        this.questionManager.startEditing(this.practiceManager.questions[this.practiceManager.currentIndex]);
                    } else if (action === 'prev') {
                        this.practiceManager.currentIndex--;
                        this.questionManager.startEditing(this.practiceManager.questions[this.practiceManager.currentIndex]);
                    } else if (action === 'setDescription') {
                        this.exitEntireEditMode();
                        this.pageState = action;
                    } else if (action === 'home') {
                        this.exitEntireEditMode();
                        this.pageState = action;
                    }

                    // æ›´æ–°URLå‚æ•°
                    if (action === 'next' || action === 'prev') {
                        this.$nextTick(() => {
                            this.updateUrlParams('quiz', {
                                mode: this.getCurrentMode(),
                                qid: this.practiceManager.questions[this.practiceManager.currentIndex].uniqueId
                            });
                        });
                    }
                },

                goBack() {
                    if (this.pageState === 'quiz') {
                        // å¦‚æœæœ‰å®Œæˆçš„é¢˜ç›®ï¼Œæ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
                        if (this.currentSessionCompleted.size > 0) {
                            if (!confirm('ç¡®å®šè¦é€€å‡ºç»ƒä¹ å—ï¼Ÿå½“å‰è¿›åº¦å°†ä¸ä¼šä¿å­˜ã€‚')) {
                                return;
                            }
                        }
                    }

                    // é‡ç½®çŠ¶æ€
                    this.resetAllState();
                    this.updatePageState('home');
                },

                async getBankStats(fileName) {
                    try {
                        // ç¡®ä¿é¢˜åº“å·²åŠ è½½
                        if (!this.jsonLoader.loadedBanks.has(fileName)) {
                            console.log(`[getBankStats] Loading bank first: ${fileName}`);
                            await this.jsonLoader.loadFile(fileName);
                        }

                        const bankData = await this.storageManager.getBankStats(fileName, this.jsonLoader);
                        console.log(`[getBankStats] Stats for ${fileName}:`, bankData);
                        if (!bankData) return null;

                        const stats = {
                            completed: bankData.completed || 0,
                            total: bankData.total || 0,
                            accuracy: bankData.attempts > 0
                                ? Math.round((bankData.correct / bankData.attempts) * 100)
                                : 0
                        };
                        console.log(`[getBankStats] Processed stats for ${fileName}:`, stats);
                        return stats;
                    } catch (e) {
                        console.error('è·å–é¢˜åº“ç»Ÿè®¡å¤±è´¥:', e);
                        return {
                            completed: 0,
                            total: 0,
                            accuracy: 0
                        };
                    }
                },

                renderMarkdown(text) {
                    if (!text) return '';
                    return marked.parse(text);
                },

                renderMarkdownWithLatex(text) {
                    if (!text) return '';

                    // å…ˆå¤„ç†å¤šè¡Œå…¬å¼ï¼Œé¿å…è¢«markdownè§£æå™¨ç ´åæ ¼å¼
                    let content = text;

                    // ä¿å­˜å¤šè¡Œå…¬å¼
                    const formulas = [];
                    content = content.replace(/\$\$([\s\S]+?)\$\$/g, (match, formula) => {
                        // ä¿æŒåŸå§‹æ¢è¡Œï¼Œä¸è¿›è¡Œä»»ä½•æ›¿æ¢
                        formulas.push(formula.trim());
                        return `<div class="katex-display">${katex.renderToString(formula.trim(), {
                            displayMode: true,
                            throwOnError: false,
                            strict: false,
                            trust: true,
                            output: 'html'
                        })}</div>`;
                    });

                    // å¤„ç†Markdown
                    content = marked.parse(content);

                    // å¤„ç†è¡Œå†…å…¬å¼
                    content = content.replace(/\$([^$]+?)\$/g, (match, formula) => {
                        try {
                            return katex.renderToString(formula.trim(), {
                                displayMode: false,
                                throwOnError: false,
                                strict: false
                            });
                        } catch (e) {
                            console.error('LaTeX rendering error:', e);
                            console.error('Formula:', formula);
                            return match;
                        }
                    });

                    return content;
                },

                handleOptionChange(option, isSingleChoice) {
                    console.log('Option change handler:', {
                        option,
                        isSingleChoice,
                        currentValue: isSingleChoice ? this.chosenAnswer : this.chosenAnswers
                    });

                    if (isSingleChoice) {
                        this.chosenAnswer = option;
                    } else {
                        const index = this.chosenAnswers.indexOf(option);
                        if (index === -1) {
                            this.chosenAnswers.push(option);
                        } else {
                            this.chosenAnswers.splice(index, 1);
                        }
                    }

                    console.log('After option change:', {
                        chosenAnswer: this.chosenAnswer,
                        chosenAnswers: this.chosenAnswers
                    });
                },

                isChosenOptionSingle(opt) {
                    console.log('Checking single option selection:', {
                        option: opt,
                        optionType: typeof opt,
                        chosenAnswer: this.chosenAnswer,
                        chosenAnswerType: typeof this.chosenAnswer,
                        isChosen: String(this.chosenAnswer) === String(opt)
                    });
                    return this.chosenAnswer !== null &&
                        this.chosenAnswer !== undefined &&
                        this.chosenAnswer !== '' &&
                        String(this.chosenAnswer) === String(opt);
                },

                isCorrectOptionMulti(opt) {
                    const ans = this.currentQuestion?.correct_answer || [];
                    // ä½¿ç”¨é€‰é¡¹çš„ç´¢å¼•æ¥åˆ¤æ–­æ˜¯å¦æ­£ç¡®
                    const optIndex = this.currentQuestion?.options.indexOf(opt);
                    const isCorrect = optIndex !== -1 && ans.includes(this.currentQuestion.options[optIndex]);
                    console.log('Checking multi option correctness:', {
                        option: opt,
                        correctAnswers: ans,
                        isCorrect: isCorrect
                    });
                    return isCorrect;
                },

                isCorrectOptionSingle(opt) {
                    const ans = this.currentQuestion?.correct_answer || [];
                    const isCorrect = ans.length > 0 && String(ans[0]) === String(opt);
                    console.log('Checking single option correctness:', {
                        option: opt,
                        optionType: typeof opt,
                        correctAnswer: ans[0],
                        correctAnswerType: ans.length > 0 ? typeof ans[0] : 'undefined',
                        isCorrect: isCorrect
                    });
                    return isCorrect;
                },

                // æ£€æŸ¥æ˜¯å¦å·²é€‰æ‹©æˆ–è¾“å…¥ç­”æ¡ˆ
                hasAnswer() {
                    const q = this.currentQuestion;
                    if (!q) return false;

                    switch (q.type) {
                        case 'single-choice':
                            return this.chosenAnswer !== null &&
                                this.chosenAnswer !== undefined &&
                                this.chosenAnswer !== '';
                        case 'multiple-choice':
                            return Array.isArray(this.chosenAnswers) &&
                                this.chosenAnswers.length > 0;
                        case 'fill-in-blank':
                            return Array.isArray(this.fillInAnswers) &&
                                this.fillInAnswers.some(ans => ans && ans.trim() !== '');
                        case 'short-answer':
                            return this.shortAnswerText && this.shortAnswerText.trim() !== '';
                        default:
                            return false;
                    }
                },

                async submitAnswer() {
                    const q = this.currentQuestion;
                    if (!q) return;

                    // æ£€æŸ¥æ˜¯å¦å·²é€‰æ‹©æˆ–è¾“å…¥ç­”æ¡ˆ
                    if (!this.hasAnswer()) {
                        // æ ¹æ®é¢˜ç›®ç±»å‹æ˜¾ç¤ºä¸åŒçš„æç¤º
                        let message;
                        switch (q.type) {
                            case 'single-choice':
                                message = 'è¯·é€‰æ‹©ä¸€ä¸ªé€‰é¡¹';
                                break;
                            case 'multiple-choice':
                                message = 'è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªé€‰é¡¹';
                                break;
                            case 'fill-in-blank':
                                message = 'è¯·å¡«å†™ç­”æ¡ˆ';
                                break;
                            case 'short-answer':
                                message = 'è¯·è¾“å…¥ç­”æ¡ˆ';
                                break;
                            default:
                                message = 'è¯·è¾“å…¥ç­”æ¡ˆ';
                        }
                        // æ˜¾ç¤ºæç¤ºä¿¡æ¯
                        this.showBanner(message, 'warning');
                        return;
                    }

                    let answer;
                    let isCorrect = false;

                    switch (q.type) {
                        case 'single-choice':
                            answer = this.chosenAnswer;
                            isCorrect = q.correct_answer.includes(answer);
                            break;
                        case 'multiple-choice':
                            answer = [...this.chosenAnswers].sort();
                            // For multiple choice, we need to compare the actual option texts
                            const sortedCorrectAnswer = [...q.correct_answer].sort();
                            isCorrect = answer.length === sortedCorrectAnswer.length && 
                                answer.every((ans, idx) => ans === sortedCorrectAnswer[idx]);
                            break;
                        case 'fill-in-blank':
                            answer = this.fillInAnswers;
                            // å¯¹å¡«ç©ºé¢˜ä½¿ç”¨ AI è¯„åˆ†
                            if (this.practiceManager.aiManager) {
                                console.log('[submitAnswer] Using AI scoring for fill-in-blank question');
                                // å…ˆæ˜¾ç¤ºç­”æ¡ˆ
                                this.showAnswer = true;
                                // æ£€æŸ¥æ˜¯å¦å¯ç”¨è‡ªåŠ¨è¯„åˆ†
                                if (this.practiceManager.aiManager.getAutoScoring()) {
                                    // è‡ªåŠ¨è¿›è¡Œ AI è¯„åˆ†
                                    isCorrect = await this.practiceManager.checkAnswerWithAI(answer.join('\n'), q);
                                } else {
                                    // ç­‰å¾…æ‰‹åŠ¨è§¦å‘è¯„åˆ†
                                    isCorrect = false;
                                }
                            } else {
                                console.log('[submitAnswer] AI not available, using basic comparison');
                                isCorrect = this.compareArrays(answer, q.correct_answer);
                            }
                            break;
                        case 'short-answer':
                            answer = this.shortAnswerText;
                            // å¯¹ç®€ç­”é¢˜ä½¿ç”¨ AI è¯„åˆ†
                            if (this.practiceManager.aiManager) {
                                console.log('[submitAnswer] Using AI scoring for short-answer question');
                                // å…ˆæ˜¾ç¤ºç­”æ¡ˆ
                                this.showAnswer = true;
                                // æ£€æŸ¥æ˜¯å¦å¯ç”¨è‡ªåŠ¨è¯„åˆ†
                                if (this.practiceManager.aiManager.getAutoScoring()) {
                                    // è‡ªåŠ¨è¿›è¡Œ AI è¯„åˆ†
                                    isCorrect = await this.practiceManager.checkAnswerWithAI(answer, q);
                                } else {
                                    // ç­‰å¾…æ‰‹åŠ¨è§¦å‘è¯„åˆ†
                                    isCorrect = false;
                                }
                            } else {
                                console.log('[submitAnswer] AI not available, using basic comparison');
                                isCorrect = q.correct_answer.some(ans =>
                                    answer.toLowerCase().includes(ans.toLowerCase())
                                );
                            }
                            break;
                    }

                    // æ›´æ–°è¿æ€çŠ¶æ€
                    if (this.audioManager) {
                        if (q.type === 'fill-in-blank' || q.type === 'short-answer') {
                            return;
                        }
                        if (isCorrect) {
                            this.audioManager.addPoints(1);
                        } else {
                            this.audioManager.subtractPoints(1);
                        }
                    }

                    // è®°å½•å®ŒæˆçŠ¶æ€
                    const questionIndex = this.practiceManager.currentIndex + 1;
                    this.currentSessionCompleted.add(questionIndex);

                    // å¦‚æœä¸æ˜¯ AI è¯„åˆ†çš„é¢˜ç›®ï¼Œæ˜¾ç¤ºç­”æ¡ˆ
                    if (!(this.practiceManager.aiManager && (q.type === 'fill-in-blank' || q.type === 'short-answer'))) {
                        this.showAnswer = true;
                    }

                    // æ›´æ–°é¢˜ç›®å®ŒæˆçŠ¶æ€
                    if (this.chosenSet.isCrossPractice) {
                        // å¯¹äºè·¨é¢˜ç»ƒä¹ ï¼Œæ‰¾åˆ°åŸé¢˜åº“å¹¶æ›´æ–°è®°å½•
                        const originalBank = this.findOriginalBank(q);
                        if (originalBank) {
                            console.log('[submitAnswer] Updating cross practice record:', {
                                bank: originalBank.file,
                                questionIndex,
                                isCorrect
                            });
                            this.storageManager.updateQuestionCompletion(originalBank.file, questionIndex, isCorrect);
                        }
                    } else {
                        // ç¡®ä¿æœ‰é¢˜åº“IDå’Œé¢˜ç›®åºå·
                        const currentQuestion = this.practiceManager.getCurrentQuestion();
                        if (this.chosenSet?.id && currentQuestion) {
                            console.log('[submitAnswer] Updating completion:', {
                                setId: this.chosenSet.id,
                                questionIndex,
                                isCorrect
                            });
                            this.storageManager.updateQuestionCompletion(
                                this.chosenSet.id,
                                questionIndex,
                                isCorrect
                            );
                        } else {
                            console.error('[submitAnswer] Missing setId or currentQuestion:', {
                                setId: this.chosenSet?.id,
                                currentQuestion
                            });
                        }
                    }

                    // æ›´æ–°URLä»¥åæ˜ ç­”æ¡ˆå·²æäº¤
                    this.updateUrlParams('quiz', {
                        mode: this.getCurrentMode(),
                        qid: this.getCurrentQuestionId()
                    });
                },

                // æŸ¥æ‰¾é¢˜ç›®æ‰€å±çš„åŸå§‹é¢˜åº“
                findOriginalBank(question) {
                    for (const bank of this.fileList) {
                        try {
                            const questions = this.jsonLoader.getQuestionsFromBank(bank.file);
                            if (questions.some(q =>
                                q.content === question.content &&
                                q.type === question.type &&
                                this.compareArrays(q.correct_answer, question.correct_answer)
                            )) {
                                return bank;
                            }
                        } catch (error) {
                            console.error(`Error checking bank ${bank.file}:`, error);
                        }
                    }
                    return null;
                },

                // æ¯”è¾ƒä¸¤ä¸ªæ•°ç»„æ˜¯å¦ç›¸ç­‰
                compareArrays(arr1, arr2) {
                    if (!Array.isArray(arr1) || !Array.isArray(arr2)) return false;
                    if (arr1.length !== arr2.length) return false;
                    return arr1.every((item, index) => item === arr2[index]);
                },

                nextQuestion() {
                    if (this.practiceManager && this.practiceManager.currentIndex < this.practiceManager.questions.length - 1) {
                        // å¦‚æœåœ¨ç¼–è¾‘æ¨¡å¼ï¼Œè‡ªåŠ¨ä¿å­˜å½“å‰ç¼–è¾‘å¹¶å¼€å§‹ç¼–è¾‘ä¸‹ä¸€é¢˜
                        if (this.isEditing) {
                            // å¦‚æœå½“å‰æœ‰æœªä¿å­˜çš„å­—æ®µç¼–è¾‘ï¼Œå…ˆä¿å­˜
                            if (this.editingField) {
                                this.exitEditMode();
                            }
                            // å¦‚æœæœ‰æœªä¿å­˜çš„ä¿®æ”¹ï¼Œè‡ªåŠ¨ä¿å­˜
                            if (this.questionManager.checkUnsavedChanges()) {
                                this.questionManager.saveCurrentEdit();
                            }
                            this.practiceManager.currentIndex++;
                            this.questionManager.startEditing(this.practiceManager.questions[this.practiceManager.currentIndex]);
                            this.showAnswer = true;
                        } else {
                            this.practiceManager.currentIndex++;
                            this.showAnswer = false;
                            // é‡ç½®ç­”æ¡ˆçŠ¶æ€
                            this.chosenAnswer = null;
                            this.chosenAnswers = [];
                            this.fillInAnswers = [];
                            this.shortAnswerText = '';
                        }

                        // ç«‹å³æ›´æ–°URLå‚æ•°
                        this.$nextTick(() => {
                            const currentFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                            this.updateUrlParams('quiz', {
                                mode: this.getCurrentMode(),
                                qid: this.practiceManager.currentIndex + 1,
                                bank: currentFile
                            });
                        });
                    } else if (!this.practiceManager.isPreviewMode) {
                        this.updatePageState('result');
                    }
                },

                prevQuestion() {
                    if (this.practiceManager && this.practiceManager.currentIndex > 0) {
                        // å¦‚æœåœ¨ç¼–è¾‘æ¨¡å¼ï¼Œè‡ªåŠ¨ä¿å­˜å½“å‰ç¼–è¾‘å¹¶å¼€å§‹ç¼–è¾‘ä¸Šä¸€é¢˜
                        if (this.isEditing) {
                            // å¦‚æœå½“å‰æœ‰æœªä¿å­˜çš„å­—æ®µç¼–è¾‘ï¼Œå…ˆä¿å­˜
                            if (this.editingField) {
                                this.exitEditMode();
                            }
                            // å¦‚æœæœ‰æœªä¿å­˜çš„ä¿®æ”¹ï¼Œè‡ªåŠ¨ä¿å­˜
                            if (this.questionManager.checkUnsavedChanges()) {
                                this.questionManager.saveCurrentEdit();
                            }
                            this.practiceManager.currentIndex--;
                            this.questionManager.startEditing(this.practiceManager.questions[this.practiceManager.currentIndex]);
                            this.showAnswer = true;
                        } else {
                            this.practiceManager.currentIndex--;
                            this.showAnswer = false;
                            // é‡ç½®ç­”æ¡ˆçŠ¶æ€
                            this.chosenAnswer = null;
                            this.chosenAnswers = [];
                            this.fillInAnswers = [];
                            this.shortAnswerText = '';
                        }

                        // ç«‹å³æ›´æ–°URLå‚æ•°
                        this.$nextTick(() => {
                            const currentFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                            this.updateUrlParams('quiz', {
                                mode: this.getCurrentMode(),
                                qid: this.practiceManager.currentIndex + 1,
                                bank: currentFile
                            });
                        });
                    }
                },

                formatDate(isoDate) {
                    if (!isoDate) return '';
                    const date = new Date(isoDate);
                    const today = new Date();
                    const yesterday = new Date(today);
                    yesterday.setDate(yesterday.getDate() - 1);

                    if (isoDate.startsWith(today.toISOString().split('T')[0])) {
                        return 'ä»Šå¤© ' + date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                    } else if (isoDate.startsWith(yesterday.toISOString().split('T')[0])) {
                        return 'æ˜¨å¤© ' + date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                    } else {
                        return date.toLocaleDateString('zh-CN') + ' ' +
                            date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                    }
                },
                closeUnsavedModal() {
                    this.showUnsavedModal = false;
                },
                truncateText(text, length) {
                    if (!text) return '';
                    text = text.replace(/<[^>]*>/g, ''); // ç§»é™¤HTMLæ ‡ç­¾
                    return text.length > length ? text.slice(0, length) + '...' : text;
                },
                getSetName(setId) {
                    return this.jsonLoader.sets.find(s => s.id === setId)?.name || setId;
                },
                checkModifiedQuestions() {
                    const modifiedQuestions = this.questionManager.getModifiedQuestions();
                    if (modifiedQuestions.length > 0 && !this.dontShowExportReminder) {
                        // åªæ˜¾ç¤ºå½“å‰é¢˜åº“çš„ä¿®æ”¹é¢˜ç›®
                        this.groupedModifiedQuestions = this.jsonLoader.questions
                            .filter(q => modifiedQuestions.includes(q.uniqueId));

                        // æ˜¾ç¤ºæœªå¯¼å‡ºæç¤ºæ¨¡æ€æ¡†
                        this.showUnsavedModal = true;
                        return true;
                    }
                    return false;
                },
                showBanner(content, type = 'info', closeable = true) {
                    // å¦‚æœå·²æœ‰å®šæ—¶å™¨ï¼Œå…ˆæ¸…é™¤
                    if (this.bannerTimer) {
                        clearTimeout(this.bannerTimer);
                        this.bannerTimer = null;
                    }
                    
                    this.banner = {
                        show: true,
                        content,
                        type,
                        closeable
                    };

                    // 3ç§’åè‡ªåŠ¨éšè—
                    this.bannerTimer = setTimeout(() => {
                        this.closeBanner();
                    }, 3000);
                },
                closeBanner() {
                    if (this.bannerTimer) {
                        clearTimeout(this.bannerTimer);
                        this.bannerTimer = null;
                    }
                    this.banner.show = false;
                },
                formatUpdateTime(isoString) {
                    const date = new Date(isoString);
                    return date.toLocaleString('zh-CN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                },
                closeUnsavedModalAndContinue() {
                    this.showUnsavedModal = false;
                    this.questionManager.clearModifiedQuestions();
                    this.modifiedCount = 0;
                    this.showExportButton = false;
                },
                toggleTag(tag) {
                    const index = this.selectedTags.indexOf(tag);
                    if (index === -1) {
                        this.selectedTags.push(tag);
                    } else {
                        this.selectedTags.splice(index, 1);
                    }
                },
                clearTags() {
                    this.selectedTags = [];
                },
                async loadBankStats(fileName) {
                    console.log('[loadBankStats] Loading stats for:', fileName);
                    try {
                        // è·å–ç»Ÿè®¡ä¿¡æ¯
                        const stats = this.storageManager.getBankStats(fileName, this.jsonLoader);
                        console.log('[loadBankStats] Retrieved stats:', stats);
                        this.bankStats[fileName] = stats;

                        // å¼ºåˆ¶æ›´æ–°è®¡ç®—å±æ€§
                        this.$forceUpdate();
                        console.log('[loadBankStats] Stats updated and view forced to update');

                        // å¦‚æœåœ¨é¢˜åº“è¯¦æƒ…é¡µé¢ï¼Œç¡®ä¿setStatsè¢«é‡æ–°è®¡ç®—
                        if (this.pageState === 'setDescription') {
                            console.log('[loadBankStats] Recalculating setStats for description page');
                            // Vueä¼šè‡ªåŠ¨é‡æ–°è®¡ç®—setStatsï¼Œå› ä¸ºä¾èµ–çš„æ•°æ®å·²ç»æ›´æ–°
                            const currentStats = this.setStats;
                            console.log('[loadBankStats] Current setStats:', currentStats);
                        }
                    } catch (error) {
                        console.error('[loadBankStats] Error loading bank stats:', error);
                    }
                },
                focusPrevButton(event) {
                    console.log('focusPrevButton triggered', {
                        eventTarget: event.target,
                        eventType: event.type,
                        currentActiveElement: document.activeElement
                    });

                    const buttons = Array.from(document.querySelectorAll('.mode-btn'));
                    console.log('Found mode buttons:', {
                        totalButtons: buttons.length,
                        buttonTexts: buttons.map(btn => btn.textContent.trim())
                    });

                    const currentIndex = buttons.indexOf(event.target);
                    console.log('Current button index:', currentIndex);

                    const prevIndex = (currentIndex - 1 + buttons.length) % buttons.length;
                    console.log('Will focus on button index:', prevIndex);

                    buttons[prevIndex].focus();
                    console.log('Focus set to:', {
                        buttonText: buttons[prevIndex].textContent.trim(),
                        newActiveElement: document.activeElement
                    });
                },
                focusNextButton(event) {
                    console.log('focusNextButton triggered', {
                        eventTarget: event.target,
                        eventType: event.type,
                        currentActiveElement: document.activeElement
                    });

                    const buttons = Array.from(document.querySelectorAll('.mode-btn'));
                    console.log('Found mode buttons:', {
                        totalButtons: buttons.length,
                        buttonTexts: buttons.map(btn => btn.textContent.trim())
                    });

                    const currentIndex = buttons.indexOf(event.target);
                    console.log('Current button index:', currentIndex);

                    const nextIndex = (currentIndex + 1) % buttons.length;
                    console.log('Will focus on button index:', nextIndex);

                    buttons[nextIndex].focus();
                    console.log('Focus set to:', {
                        buttonText: buttons[nextIndex].textContent.trim(),
                        newActiveElement: document.activeElement
                    });
                },
                focusUpButton(event) {
                    console.log('focusUpButton triggered', {
                        eventTarget: event.target,
                        eventType: event.type,
                        currentActiveElement: document.activeElement
                    });

                    const buttons = Array.from(document.querySelectorAll('.mode-btn'));
                    console.log('Found mode buttons:', {
                        totalButtons: buttons.length,
                        buttonTexts: buttons.map(btn => btn.textContent.trim())
                    });

                    const currentIndex = buttons.indexOf(event.target);
                    console.log('Current button index:', currentIndex);

                    const COLS = window.innerWidth <= 600 ? 1 : 2;
                    console.log('Grid layout:', {
                        columns: COLS,
                        windowWidth: window.innerWidth
                    });

                    const prevIndex = currentIndex - COLS;
                    console.log('Calculated previous index:', prevIndex);

                    if (prevIndex >= 0) {
                        console.log('Moving up to index:', prevIndex);
                        buttons[prevIndex].focus();
                    } else {
                        // å¦‚æœåˆ°è¾¾é¡¶éƒ¨ï¼Œè·³è½¬åˆ°æœ€åä¸€è¡Œçš„ç›¸åŒåˆ—
                        const sameColBottom = currentIndex % COLS + Math.floor((buttons.length - 1) / COLS) * COLS;
                        console.log('Wrapping to bottom, calculated index:', {
                            currentCol: currentIndex % COLS,
                            lastRowStart: Math.floor((buttons.length - 1) / COLS) * COLS,
                            targetIndex: sameColBottom
                        });

                        if (sameColBottom < buttons.length) {
                            buttons[sameColBottom].focus();
                        } else {
                            buttons[buttons.length - 1].focus();
                        }
                    }

                    console.log('Focus set to:', {
                        buttonText: document.activeElement.textContent.trim(),
                        newActiveElement: document.activeElement
                    });
                },
                focusDownButton(event) {
                    console.log('focusDownButton triggered', {
                        eventTarget: event.target,
                        eventType: event.type,
                        currentActiveElement: document.activeElement
                    });

                    const buttons = Array.from(document.querySelectorAll('.mode-btn'));
                    console.log('Found mode buttons:', {
                        totalButtons: buttons.length,
                        buttonTexts: buttons.map(btn => btn.textContent.trim())
                    });

                    const currentIndex = buttons.indexOf(event.target);
                    console.log('Current button index:', currentIndex);

                    const COLS = window.innerWidth <= 600 ? 1 : 2;
                    console.log('Grid layout:', {
                        columns: COLS,
                        windowWidth: window.innerWidth
                    });

                    const nextIndex = currentIndex + COLS;
                    console.log('Calculated next index:', nextIndex);

                    if (nextIndex < buttons.length) {
                        console.log('Moving down to index:', nextIndex);
                        buttons[nextIndex].focus();
                    } else {
                        // å¦‚æœåˆ°è¾¾åº•éƒ¨ï¼Œè·³è½¬åˆ°ç¬¬ä¸€è¡Œçš„ç›¸åŒåˆ—
                        const sameColTop = currentIndex % COLS;
                        console.log('Wrapping to top, calculated index:', {
                            currentCol: currentIndex % COLS,
                            targetIndex: sameColTop
                        });
                        buttons[sameColTop].focus();
                    }

                    console.log('Focus set to:', {
                        buttonText: document.activeElement.textContent.trim(),
                        newActiveElement: document.activeElement
                    });
                },

                getFocusableElements() {
                    // è·å–å½“å‰é¡µé¢ä¸­æ‰€æœ‰å¯èšç„¦çš„å…ƒç´ 
                    if (this.pageState === 'setDescription') {
                        // åœ¨é¢˜åº“è¯¦æƒ…é¡µä¸­ï¼Œåªè·å–æ¨¡å¼æŒ‰é’®
                        return Array.from(document.querySelectorAll('.mode-btn'))
                            .filter(el => {
                                const style = window.getComputedStyle(el);
                                return style.display !== 'none' && style.visibility !== 'hidden';
                            });
                    }

                    const selector = 'button, [tabindex="0"], a[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled])';
                    return Array.from(this.$el.querySelectorAll(selector))
                        .filter(el => {
                            // ç¡®ä¿å…ƒç´ æ˜¯å¯è§çš„
                            const style = window.getComputedStyle(el);
                            return style.display !== 'none' && style.visibility !== 'hidden';
                        });
                },
                initModeButtonsFocus() {
                    // ç¡®ä¿ç¬¬ä¸€ä¸ªæŒ‰é’®è·å¾—ç„¦ç‚¹
                    if (this.pageState === 'setDescription') {
                        this.$nextTick(() => {
                            const firstBtn = this.$refs.firstModeBtn;
                            if (firstBtn) {
                                firstBtn.focus();
                            }
                        });
                    }
                },
                // URLå‚æ•°å¤„ç†
                async handleUrlParams() {
                    const urlParams = new URLSearchParams(window.location.search);
                    const bankParam = urlParams.get('bank');
                    const stateParam = urlParams.get('state');
                    const modeParam = urlParams.get('mode');
                    const qidParam = urlParams.get('qid');

                    console.log('[handleUrlParams] Processing URL parameters:', {
                        bank: bankParam,
                        state: stateParam,
                        mode: modeParam,
                        qid: qidParam
                    });

                    if (!bankParam) {
                        console.log('[handleUrlParams] No bank parameter, staying on home page');
                        return;
                    }

                    // ç¡®ä¿é¢˜åº“åˆ—è¡¨å·²åŠ è½½
                    if (this.fileList.length === 0) {
                        console.log('[handleUrlParams] File list not loaded yet, waiting...');
                        await this.loadBankList();
                    }

                    // éªŒè¯é¢˜åº“æ˜¯å¦å­˜åœ¨
                    const bankExists = this.fileList.some(f => f.file === bankParam);
                    if (!bankExists) {
                        console.error('[handleUrlParams] Bank not found:', bankParam);
                        alert('æ‰¾ä¸åˆ°æŒ‡å®šçš„é¢˜åº“');
                        this.resetAllState();
                        return;
                    }

                    try {
                        this.isLoading = true;
                        // åŠ è½½é¢˜åº“æ•°æ®
                        console.log('[handleUrlParams] Loading bank data:', bankParam);
                        const data = await this.jsonLoader.loadFile(bankParam);
                        console.log('[handleUrlParams] Bank data loaded:', {
                            setName: data.sets[0]?.name,
                            questionCount: data.questions?.length
                        });

                        // Set chosenSet with proper id
                        this.chosenSet = {
                            ...data.sets[0],
                            id: bankParam.replace('.json', '') // Ensure id matches the file name without extension
                        };

                        // æ›´æ–°ç»Ÿè®¡æ•°æ®
                        console.log('[handleUrlParams] Updating bank stats');
                        const stats = await this.storageManager.getBankStats(bankParam, this.jsonLoader);
                        this.bankStats[bankParam] = stats;

                        // æ ¹æ®stateå‚æ•°è®¾ç½®é¡µé¢çŠ¶æ€
                        if (stateParam === 'quiz' && modeParam) {
                            console.log('[handleUrlParams] Setting up quiz mode:', modeParam);
                            await this.setupQuizMode(modeParam, qidParam);
                        } else {
                            console.log('[handleUrlParams] Setting page state to:', stateParam || 'setDescription');
                            this.pageState = stateParam || 'setDescription';
                        }
                    } catch (error) {
                        console.error('[handleUrlParams] Failed to process URL parameters:', error);
                        alert('åŠ è½½é¢˜åº“å¤±è´¥: ' + error.message);
                        this.resetAllState();
                    } finally {
                        this.isLoading = false;
                    }
                },

                // è®¾ç½®ç»ƒä¹ æ¨¡å¼ï¼Œæ”¯æŒqidè·³è½¬
                async setupQuizMode(mode, qid = null) {
                    console.log('[setupQuizMode] Setting up quiz mode:', mode, {
                        currentQuestions: this.jsonLoader.questions?.length,
                        qid
                    });
                    try {
                        // ç¡®ä¿æˆ‘ä»¬ä½¿ç”¨çš„æ˜¯å½“å‰åŠ è½½çš„é¢˜åº“æ•°æ®
                        const questions = this.jsonLoader.questions;
                        if (!questions || questions.length === 0) {
                            throw new Error('No questions available for quiz mode');
                        }

                        switch (mode) {
                            case 'all':
                                this.practiceManager.initPractice(questions, 'sequence');
                                this.practiceManager.togglePreviewMode(false);
                                break;
                            case 'wrong':
                                this.practiceManager.initPractice(questions, 'error-rate');
                                this.practiceManager.togglePreviewMode(false);
                                break;
                            case 'random':
                                this.practiceManager.initPractice(questions, 'random');
                                this.practiceManager.togglePreviewMode(false);
                                break;
                            case 'preview':
                                this.practiceManager.initPractice(questions, 'sequence');
                                this.practiceManager.togglePreviewMode(true);
                                this.showAnswer = true;
                                break;
                        }

                        // è·³è½¬åˆ°æŒ‡å®šé¢˜ç›®
                        if (qid) {
                            // å°è¯•é€šè¿‡åºå·å®šä½ï¼ˆåºå·ä»1å¼€å§‹ï¼‰
                            const num = parseInt(qid);
                            if (!isNaN(num) && num >= 1 && num <= this.practiceManager.questions.length) {
                                this.practiceManager.currentIndex = num - 1;
                            }
                        }

                        console.log('[setupQuizMode] Practice manager initialized with questions:', questions.length);
                        this.resetQuizState();
                        this.pageState = 'quiz';

                        // æ›´æ–°URLå‚æ•°ï¼Œç¡®ä¿åŒ…å«å½“å‰é¢˜ç›®åºå·
                        const currentFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                        this.updateUrlParams('quiz', {
                            mode: mode,
                            qid: this.practiceManager.currentIndex + 1,
                            bank: currentFile
                        });

                        console.log('[setupQuizMode] Quiz mode setup completed');
                    } catch (error) {
                        console.error('[setupQuizMode] Failed to setup quiz mode:', error);
                        this.resetAllState();
                    }
                },

                // å¤„ç†æµè§ˆå™¨å‰è¿›/åé€€
                async handlePopState(event) {
                    console.log('[handlePopState] Processing popstate event:', event);
                    const urlParams = new URLSearchParams(window.location.search);
                    const bankParam = urlParams.get('bank');
                    const stateParam = urlParams.get('state');
                    const modeParam = urlParams.get('mode');
                    const practiceModeParam = urlParams.get('practiceMode');
                    const countParam = urlParams.get('count');

                    console.log('[handlePopState] URL parameters:', {
                        bank: bankParam,
                        state: stateParam,
                        mode: modeParam,
                        practiceMode: practiceModeParam,
                        count: countParam
                    });

                    if (!bankParam && modeParam !== 'cross') {
                        console.log('[handlePopState] No bank parameter and not cross mode, resetting state');
                        this.resetAllState();
                        return;
                    }

                    try {
                        if (modeParam === 'cross') {
                            // è·¨å·ç»ƒä¹ æ¨¡å¼
                            if (this.chosenSet?.isCrossPractice) {
                                // å·²ç»åœ¨è·¨å·ç»ƒä¹ ä¸­ï¼Œä¿æŒçŠ¶æ€
                                console.log('[handlePopState] Already in cross practice mode');
                                return;
                            }
                            // å¦åˆ™é‡ç½®åˆ°é¦–é¡µ
                            console.log('[handlePopState] Invalid cross practice state, resetting');
                            this.resetAllState();
                            return;
                        }

                        // æ™®é€šé¢˜åº“æ¨¡å¼
                        const currentFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                        console.log('[handlePopState] Checking bank change:', {
                            current: currentFile,
                            new: bankParam
                        });

                        if (bankParam !== currentFile) {
                            console.log('[handlePopState] Loading new bank data');
                            const data = await this.jsonLoader.loadFile(bankParam);
                            // Set chosenSet with proper id
                            this.chosenSet = {
                                ...data.sets[0],
                                id: bankParam.replace('.json', '') // Ensure id matches the file name without extension
                            };
                            // æ›´æ–°ç»Ÿè®¡æ•°æ®
                            await this.loadBankStats(bankParam);
                        }

                        // æ ¹æ®stateå‚æ•°åˆ‡æ¢çŠ¶æ€
                        if (stateParam) {
                            console.log('[handlePopState] Processing state:', stateParam);
                            switch (stateParam) {
                                case 'quiz':
                                    if (modeParam) {
                                        console.log('[handlePopState] Setting up quiz mode:', modeParam);
                                        this.setupQuizMode(modeParam);
                                    }
                                    break;
                                case 'setDescription':
                                    console.log('[handlePopState] Switching to setDescription');
                                    this.pageState = 'setDescription';
                                    break;
                                default:
                                    console.log('[handlePopState] Invalid state, resetting');
                                    this.resetAllState();
                            }
                        } else {
                            console.log('[handlePopState] No state parameter, defaulting to setDescription');
                            this.pageState = 'setDescription';
                        }
                    } catch (error) {
                        console.error('[handlePopState] Failed to handle popstate:', error);
                        this.resetAllState();
                    }
                },

                // å¤„ç† URL å˜åŒ–
                async handleUrlChange(event) {
                    // é¿å…é‡å¤å¤„ç† popstate äº‹ä»¶
                    if (event.type === 'popstate') {
                        return;
                    }

                    console.log('[handleUrlChange] URL changed:', {
                        oldURL: event.oldURL,
                        newURL: event.newURL || window.location.href
                    });

                    await this.handleUrlParams();
                },

                // æ›´æ–°URLå‚æ•°
                updateUrlParams(state, params = {}) {
                    console.log('[updateUrlParams] Updating URL parameters:', {
                        state,
                        params,
                        isCrossPractice: this.chosenSet?.isCrossPractice
                    });

                    const url = new URL(window.location.href);
                    const newParams = new URLSearchParams();

                    // è®¾ç½®é¡µé¢çŠ¶æ€
                    newParams.set('state', state);

                    if (state === 'quiz') {
                        if (this.chosenSet?.isCrossPractice) {
                            // è·¨é¢˜ç»ƒä¹ æ¨¡å¼
                            newParams.set('mode', 'cross');
                            newParams.set('practiceMode', this.crossPracticeMode);
                            newParams.set('count', this.crossPracticeCount);

                            // å¦‚æœæœ‰å½“å‰é¢˜ç›®ï¼Œæ·»åŠ åŸé¢˜åº“ä¿¡æ¯
                            const currentQuestion = this.practiceManager?.getCurrentQuestion();
                            if (currentQuestion) {
                                const originalBank = this.findOriginalBank(currentQuestion);
                                if (originalBank) {
                                    newParams.set('sourceBank', originalBank.file);
                                }
                            }
                        } else {
                            // æ™®é€šç»ƒä¹ æ¨¡å¼
                            newParams.set('mode', params.mode || this.getCurrentMode());
                            if (params.qid) {
                                newParams.set('qid', params.qid);
                            }
                            if (params.bank) {
                                newParams.set('bank', params.bank);
                            }
                        }
                    } else if (state === 'setDescription' && params.bank) {
                        newParams.set('bank', params.bank);
                    }

                    // æ›´æ–°URLï¼Œä¸åˆ·æ–°é¡µé¢
                    url.search = newParams.toString();
                    window.history.pushState({
                        state,
                        params: Object.fromEntries(newParams.entries())
                    }, '', url);

                    console.log('[updateUrlParams] URL updated:', url.toString());
                },

                // é‡ç½®æ‰€æœ‰çŠ¶æ€
                resetAllState() {
                    this.pageState = 'home';
                    this.chosenSet = null;
                    this.practiceManager?.reset();
                    this.resetQuizState();
                    this.showExportButton = false;
                    this.isEditing = false;
                    this.editingField = null;
                    this.editingContent = '';
                },

                // é‡ç½®ç­”é¢˜çŠ¶æ€
                resetQuizState() {
                    this.chosenAnswer = '';
                    this.chosenAnswers = [];
                    this.shortAnswerText = '';
                    this.fillInAnswers = [];
                    this.currentSessionCompleted.clear();
                    this.showAnswer = false;
                },

                // å…¨å±€Alt+Hè¿”å›ä¸Šä¸€çº§å¿«æ·é”®
                handleGlobalBackShortcut(e) {
                    const tag = document.activeElement && document.activeElement.tagName;
                    if (tag === 'INPUT' || tag === 'TEXTAREA') return;

                    if (e.altKey && (e.key === 'h' || e.key === 'H')) {
                        console.log('[handleGlobalBackShortcut] Alt+H detected, pageState:', this.pageState);
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();

                        switch (this.pageState) {
                            case 'quiz':
                            case 'orderQuiz':
                            case 'randomQuiz':
                                if (!this.isEditing) {
                                    console.log('[handleGlobalBackShortcut] Calling goBack() from quiz mode');
                                    this.goBack();
                                }
                                break;
                            case 'setDescription':
                                this.updatePageState('home');
                                break;
                            case 'home':
                                // åœ¨é¦–é¡µä¸åšä»»ä½•æ“ä½œ
                                break;
                        }
                        return false;
                    }
                },

                // è¿”å›ä¸Šä¸€é¡µ
                goBack() {
                    if (this.pageState === 'quiz') {
                        // å¦‚æœæœ‰å®Œæˆçš„é¢˜ç›®ï¼Œæ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
                        if (this.currentSessionCompleted.size > 0) {
                            if (!confirm('ç¡®å®šè¦é€€å‡ºç»ƒä¹ å—ï¼Ÿå½“å‰è¿›åº¦å°†ä¸ä¼šä¿å­˜ã€‚')) {
                                return;
                            }
                        }
                    }

                    // é‡ç½®çŠ¶æ€
                    this.resetAllState();
                    this.updatePageState('home');
                },

                // è·å–é¢˜ç›®æ‰€å±çš„é¢˜åº“
                getBankByQuestion(question) {
                    return this.filteredBankDistribution.find(
                        bank => bank.questions.some(q => q.uniqueId === question.uniqueId)
                    );
                },

                // å¼€å§‹è·¨å·ç»ƒä¹ 
                async startCrossPractice() {
                    if (!this.canStartCrossPractice) return;

                    try {
                        this.isLoading = true;

                        // å…ˆåŠ è½½æ‰€æœ‰éœ€è¦çš„é¢˜åº“
                        const banksToLoad = this.filteredBankDistribution
                            .filter(bank => !this.jsonLoader.loadedBanks.has(bank.file))
                            .map(bank => bank.file);

                        if (banksToLoad.length > 0) {
                            await this.jsonLoader.loadMultipleBanks(banksToLoad);
                        }

                        // æ”¶é›†æ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„é¢˜ç›®
                        let allQuestions = [];
                        this.filteredBankDistribution.forEach(bank => {
                            const bankQuestions = this.jsonLoader.getQuestionsFromBank(bank.file)
                                .filter(q => this.selectedQuestionTypes.includes(q.type));
                            allQuestions = allQuestions.concat(bankQuestions);
                        });

                        if (allQuestions.length === 0) {
                            throw new Error('æ²¡æœ‰æ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„é¢˜ç›®');
                        }

                        if (this.crossPracticeCount > allQuestions.length) {
                            this.crossPracticeCount = allQuestions.length;
                        }

                        // æ ¹æ®æ¨¡å¼æ’åºé¢˜ç›®
                        if (this.crossPracticeMode === 'error-rate') {
                            allQuestions.sort((a, b) => {
                                const statsA = this.storageManager.getQuestionStats(this.getBankByQuestion(a).file, a.uniqueId);
                                const statsB = this.storageManager.getQuestionStats(this.getBankByQuestion(b).file, b.uniqueId);
                                const errorRateA = statsA ? 1 - (statsA.correct / statsA.attempts) : 1;
                                const errorRateB = statsB ? 1 - (statsB.correct / statsB.attempts) : 1;
                                return errorRateB - errorRateA;
                            });
                        } else {
                            // éšæœºæ¨¡å¼
                            allQuestions = this.shuffleArray(allQuestions);
                        }

                        // é€‰æ‹©æŒ‡å®šæ•°é‡çš„é¢˜ç›®
                        const selectedQuestions = allQuestions.slice(0, this.crossPracticeCount);

                        // ä¸ºæ¯ä¸ªé¢˜ç›®æ·»åŠ æ¥æºé¢˜åº“ä¿¡æ¯å¹¶æ‰“ä¹±é€‰é¡¹
                        const questionsWithSource = selectedQuestions.map(q => {
                            const questionCopy = { ...q };
                            // å¦‚æœæ˜¯å•é€‰æˆ–å¤šé€‰é¢˜ï¼Œæ‰“ä¹±é€‰é¡¹
                            if ((questionCopy.type === 'single-choice' || questionCopy.type === 'multiple-choice') && Array.isArray(questionCopy.options)) {
                                const originalOptions = [...questionCopy.options];
                                const originalCorrectAnswer = [...questionCopy.correct_answer];
                                const shuffledOptions = this.shuffleArray([...originalOptions]);

                                // æ›´æ–°æ­£ç¡®ç­”æ¡ˆ
                                if (questionCopy.type === 'single-choice') {
                                    const oldCorrectAnswer = originalCorrectAnswer[0];
                                    const newIndex = shuffledOptions.indexOf(oldCorrectAnswer);
                                    if (newIndex !== -1) {
                                        questionCopy.correct_answer = [shuffledOptions[newIndex]];
                                    }
                                } else {
                                    questionCopy.correct_answer = originalCorrectAnswer.map(ans => {
                                        const newAns = shuffledOptions[originalOptions.indexOf(ans)];
                                        return newAns;
                                    });
                                }
                                questionCopy.options = shuffledOptions;
                            }
                            return {
                                ...questionCopy,
                                sourceBank: this.getBankByQuestion(q).name || 'æœªçŸ¥é¢˜åº“'
                            };
                        });

                        // åˆ›å»ºè™šæ‹Ÿé¢˜åº“é›†åˆ
                        const virtualSet = {
                            id: 'cross-practice-' + Date.now(),
                            name: 'è·¨å·ç»ƒä¹ ',
                            description: `ä»${this.filteredBankDistribution.length}ä¸ªé¢˜åº“ä¸­é€‰æ‹©çš„${this.crossPracticeCount}é“é¢˜ç›®\n\nåŒ…å«é¢˜åº“ï¼š\n${this.filteredBankDistribution.map(bank => `- ${bank.name} (${bank.questionCount}é¢˜)`).join('\n')}`,
                            isCrossPractice: true
                        };

                        // åˆå§‹åŒ–ç»ƒä¹ 
                        this.chosenSet = virtualSet;
                        this.practiceManager.initPractice(questionsWithSource, this.crossPracticeMode);
                        this.showCrossPracticeModal = false;
                        this.updatePageState('quiz', {
                            mode: 'cross',
                            practiceMode: this.crossPracticeMode,
                            count: this.crossPracticeCount
                        });
                    } catch (error) {
                        console.error('Failed to start cross practice:', error);
                        alert(error.message || 'å¯åŠ¨è·¨å·ç»ƒä¹ å¤±è´¥');
                    } finally {
                        this.isLoading = false;
                    }
                },

                // æ•°ç»„éšæœºæ‰“ä¹±
                shuffleArray(array) {
                    for (let i = array.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [array[i], array[j]] = [array[j], array[i]];
                    }
                    return array;
                },

                // éªŒè¯é¢˜ç›®æ•°é‡
                handleQuestionInput(event) {
                    const rawValue = event.target.value;
                    console.log('[handleQuestionInput] Input event:', {
                        type: event.type,
                        rawValue: rawValue,
                        maxQuestionCount: this.maxQuestionCount
                    });

                    let value = parseInt(rawValue);

                    // å…è®¸è¾“å…¥æ¡†æš‚æ—¶ä¸ºç©º
                    if (rawValue === '') {
                        this.crossPracticeCount = '';
                        return;
                    }

                    // ç¡®ä¿è¾“å…¥çš„æ˜¯æ•°å­—
                    if (!isNaN(value)) {
                        // ä¸åœ¨è¿™é‡Œé™åˆ¶æœ€å¤§å€¼ï¼Œè®©ç”¨æˆ·å¯ä»¥è¾“å…¥ä»»ä½•æ•°å­—
                        this.crossPracticeCount = value;
                        // æ›´æ–°åˆ†å¸ƒä½†ä¸é™åˆ¶è¾“å…¥å€¼
                        this.updateBankDistribution();
                    }
                },

                // åœ¨å¤±å»ç„¦ç‚¹æ—¶éªŒè¯å’Œæ›´æ–°å€¼
                handleQuestionBlur() {
                    console.log('[handleQuestionBlur] Validating value:', {
                        currentCount: this.crossPracticeCount,
                        maxCount: this.maxQuestionCount
                    });

                    let value = parseInt(this.crossPracticeCount);

                    // å¤„ç†æ— æ•ˆè¾“å…¥
                    if (isNaN(value) || value < 1) {
                        value = 1;
                    }

                    // åœ¨å¤±å»ç„¦ç‚¹æ—¶æ‰é™åˆ¶æœ€å¤§å€¼
                    if (value > this.maxQuestionCount) {
                        value = this.maxQuestionCount;
                    }

                    this.crossPracticeCount = value;
                    this.updateBankDistribution();
                },

                // æ›´æ–°é¢˜åº“åˆ†å¸ƒ
                updateBankDistribution() {
                    console.log('[updateBankDistribution] Updating with count:', {
                        requestedCount: this.crossPracticeCount,
                        maxAvailable: this.maxQuestionCount
                    });

                    // ç¡®ä¿ crossPracticeCount æ˜¯æœ‰æ•ˆçš„æ•°å­—
                    let totalRequestedQuestions = Math.max(1, parseInt(this.crossPracticeCount) || 0);

                    // ä¸åœ¨è¿™é‡Œé™åˆ¶æœ€å¤§å€¼ï¼Œè®©åˆ†é…é€»è¾‘å¤„ç†è¶…å‡ºçš„æƒ…å†µ
                    let remainingQuestions = totalRequestedQuestions;

                    // è·å–æœ‰å¯ç”¨é¢˜ç›®çš„é¢˜åº“
                    const availableBanks = this.filteredBankDistribution.filter(bank => bank.availableQuestions > 0);
                    if (availableBanks.length === 0) {
                        console.log('[updateBankDistribution] No available banks found');
                        return;
                    }

                    // è®¡ç®—æ€»å¯ç”¨é¢˜ç›®æ•°
                    const totalAvailable = availableBanks.reduce((sum, bank) => sum + bank.availableQuestions, 0);

                    // æŒ‰æ¯”ä¾‹åˆ†é…é¢˜ç›®
                    availableBanks.forEach(bank => {
                        const proportion = bank.availableQuestions / totalAvailable;
                        bank.questionCount = Math.min(
                            Math.floor(remainingQuestions * proportion),
                            bank.availableQuestions
                        );
                        remainingQuestions -= bank.questionCount;
                    });

                    // åˆ†é…å‰©ä½™çš„é¢˜ç›®
                    while (remainingQuestions > 0) {
                        let distributed = false;
                        for (const bank of availableBanks) {
                            if (bank.questionCount < bank.availableQuestions) {
                                bank.questionCount++;
                                remainingQuestions--;
                                distributed = true;
                                if (remainingQuestions === 0) break;
                            }
                        }
                        if (!distributed) break;
                    }

                    console.log('[updateBankDistribution] Final distribution:',
                        this.filteredBankDistribution.map(bank => ({
                            name: bank.name,
                            available: bank.availableQuestions,
                            assigned: bank.questionCount,
                            percentage: this.calculateBankPercentage(bank)
                        }))
                    );
                },
                backToHome() {
                    if (this.showAnswer || confirm('ç¡®å®šè¦é€€å‡ºç»ƒä¹ å—ï¼Ÿå½“å‰è¿›åº¦å°†ä¸ä¼šä¿å­˜ã€‚')) {
                        this.updatePageState('home');
                    }
                },

                // å¤åˆ¶å½“å‰é¢˜ç›®é“¾æ¥
                async copyCurrentLink() {
                    try {
                        const url = new URL(window.location.href);
                        const params = new URLSearchParams(url.search);

                        // è·å–å½“å‰é¢˜ç›®
                        const currentQuestion = this.practiceManager.getCurrentQuestion();
                        if (!currentQuestion) return;

                        let bankFile, questionSequenceNumber;

                        if (this.chosenSet.isCrossPractice) {
                            // å¯¹äºè·¨é¢˜ç»ƒä¹ ï¼Œæ‰¾åˆ°åŸé¢˜åº“
                            const originalBank = this.findOriginalBank(currentQuestion);
                            if (originalBank) {
                                bankFile = originalBank.file;
                                // åœ¨åŸé¢˜åº“ä¸­æŸ¥æ‰¾é¢˜ç›®åºå·
                                const originalQuestions = this.jsonLoader.getQuestionsFromBank(bankFile);
                                questionSequenceNumber = originalQuestions.findIndex(q =>
                                    q.uniqueId === currentQuestion.uniqueId
                                ) + 1;
                            }
                        } else {
                            // æ™®é€šç»ƒä¹ æ¨¡å¼
                            bankFile = this.fileList.find(f => f.name === this.chosenSet?.name)?.file;
                            questionSequenceNumber = this.practiceManager.currentIndex + 1;
                        }

                        if (bankFile && questionSequenceNumber > 0) {
                            // æ›´æ–°URLå‚æ•°
                            this.updateUrlParams('quiz', {
                                mode: 'all', // ä½¿ç”¨æ™®é€šç»ƒä¹ æ¨¡å¼çš„é“¾æ¥
                                qid: questionSequenceNumber,
                                bank: bankFile
                            });

                            // è·å–æ›´æ–°åçš„URL
                            const finalUrl = window.location.href;
                            await navigator.clipboard.writeText(finalUrl);

                            // æ˜¾ç¤ºæˆåŠŸæç¤º
                            this.showToast('é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                        } else {
                            throw new Error('æ— æ³•æ‰¾åˆ°åŸé¢˜ç›®ä½ç½®');
                        }
                    } catch (error) {
                        console.error('Failed to copy link:', error);
                        this.showToast('å¤åˆ¶é“¾æ¥å¤±è´¥', 'error');
                    }
                },
                saveCurrentEdit() {
                    this.questionManager.saveCurrentEdit();
                    // æ›´æ–°ä¿®æ”¹è®¡æ•°
                    this.modifiedCount = this.questionManager.getModifiedQuestions().length;
                    // å¯¼å‡ºä¿®æ”¹åçš„JSON
                    this.exportModifiedData();
                },
                // è·å–å½“å‰ç»ƒä¹ æ¨¡å¼
                getCurrentMode() {
                    if (!this.practiceManager) return 'all';
                    if (this.isEditing) return 'preview';
                    if (this.practiceManager.mode === 'random') return 'random';
                    if (this.practiceManager.mode === 'error-rate') return 'wrong';
                    return 'all';
                },
                // è·å–å½“å‰é¢˜ç›®ID
                getCurrentQuestionId() {
                    if (!this.practiceManager || !this.practiceManager.questions) return null;

                    const currentQuestion = this.practiceManager.getCurrentQuestion();
                    if (!currentQuestion) return null;

                    if (this.chosenSet.isCrossPractice) {
                        // å¯¹äºè·¨é¢˜ç»ƒä¹ ï¼Œè¿”å›åŸé¢˜åº“ä¸­çš„åºå·
                        const originalBank = this.findOriginalBank(currentQuestion);
                        if (originalBank) {
                            const originalQuestions = this.jsonLoader.getQuestionsFromBank(originalBank.file);
                            const index = originalQuestions.findIndex(q => q.uniqueId === currentQuestion.uniqueId);
                            return index >= 0 ? index + 1 : null;
                        }
                        return null;
                    }

                    // æ™®é€šç»ƒä¹ æ¨¡å¼
                    return this.practiceManager.currentIndex + 1;
                },

                // ç”ŸæˆAIè§£æ
                async generateAIAnalysis() {
                    if (!this.practiceManager || !this.currentQuestion || this.isGeneratingAnalysis) return;

                    try {
                        this.isGeneratingAnalysis = true;
                        this.aiAnalysisExplanation = 'æ­£åœ¨ç”Ÿæˆè§£æ...\n';
                        console.log('[generateAIAnalysis] Starting AI analysis');

                        // è·å–å½“å‰ç­”æ¡ˆ
                        let answer;
                        switch (this.currentQuestion.type) {
                            case 'single-choice':
                                answer = this.chosenAnswer;
                                break;
                            case 'multiple-choice':
                                answer = this.chosenAnswers;
                                break;
                            case 'fill-in-blank':
                                answer = this.fillInAnswers;
                                break;
                            case 'short-answer':
                                answer = this.shortAnswerText;
                                break;
                        }

                        // è°ƒç”¨AIè§£æ
                        const response = await this.practiceManager.getAIAnalysis(answer, this.currentQuestion);
                        
                        let fullContent = '';
                        let partialContent = '';
                        let result = null;
                        let isReasoningPhase = false;

                        for await (const chunk of response) {
                            console.log('[generateAIAnalysis] Received chunk:', chunk);
                            
                            switch (chunk.type) {
                                case 'reasoning': {
                                    isReasoningPhase = true;
                                    this.aiAnalysisExplanation = 'æ­£åœ¨ç”Ÿæˆè§£æ...\n' + chunk.content;
                                    break;
                                }
                                case 'answer': {
                                    fullContent += chunk.content;
                                    
                                    try {
                                        // å°è¯•è§£æå®Œæ•´çš„ JSON
                                        const parsed = JSON.parse(fullContent);
                                        if (parsed.analysis) {
                                            result = parsed;
                                            this.aiAnalysis = result.analysis;
                                            this.aiAnalysisExplanation = result.analysis;
                                        }
                                    } catch (error) {
                                        // JSON è¿˜ä¸å®Œæ•´ï¼Œç»§ç»­ç´¯ç§¯å†…å®¹
                                        if (!isReasoningPhase) {
                                            partialContent += chunk.content;
                                            
                                            // å°è¯•ä»éƒ¨åˆ†å†…å®¹ä¸­æå–æœ‰æ„ä¹‰çš„æ–‡æœ¬
                                            let cleanContent = partialContent
                                                .replace(/^{?\s*"analysis":\s*"?/, '')
                                                .replace(/\\"/, '"')
                                                .replace(/"}$/, '')
                                                .replace(/,$/, '')
                                                .trim();
                                            
                                            if (cleanContent) {
                                                this.aiAnalysisExplanation = 'æ­£åœ¨ç”Ÿæˆè§£æ...\n' + cleanContent;
                                            }
                                        }
                                    }
                                    break;
                                }
                            }
                        }

                        // æœ€åä¸€æ¬¡å°è¯•è§£æ
                        if (!result && fullContent) {
                            try {
                                const parsed = JSON.parse(fullContent);
                                if (parsed.analysis) {
                                    this.aiAnalysis = parsed.analysis;
                                    this.aiAnalysisExplanation = parsed.analysis;
                                }
                            } catch (error) {
                                console.error('[generateAIAnalysis] Failed to parse final content:', error);
                            }
                        }

                    } catch (error) {
                        console.error('[generateAIAnalysis] Failed to generate AI analysis:', error);
                        this.showToast('ç”ŸæˆAIè§£æå¤±è´¥ï¼Œç‚¹å‡»å³ä¸Šè§’é²¸é±¼å›¾æ ‡æ£€æŸ¥é…ç½®ï¼Œæˆ–ç¨åé‡è¯•', 'error');
                    } finally {
                        this.isGeneratingAnalysis = false;
                        this.aiAnalysisExplanation = '';
                    }
                },

                // æ¸²æŸ“AIè§£æ
                renderedAIAnalysis() {
                    try {
                        if (!this.aiAnalysis) return '';
                        
                        // å°è¯•è§£æå†…å®¹
                        let content = '';
                        if (typeof this.aiAnalysis === 'object') {
                            content = this.aiAnalysis.analysis || '';
                        } else if (typeof this.aiAnalysis === 'string') {
                            try {
                                const parsed = JSON.parse(this.aiAnalysis);
                                content = parsed.analysis || this.aiAnalysis;
                            } catch (e) {
                                content = this.aiAnalysis;
                            }
                        }
                        
                        // å¦‚æœå†…å®¹æ˜¯ç©ºå­—ç¬¦ä¸²ï¼Œè¿”å›ç©º
                        if (!content || !content.trim()) return '';
                        
                        // æ¸²æŸ“ Markdown å’Œ LaTeX
                        return this.renderMarkdownWithLatex(content);
                    } catch (error) {
                        console.error('[renderedAIAnalysis] Error rendering analysis:', error, {
                            aiAnalysis: this.aiAnalysis,
                            type: typeof this.aiAnalysis
                        });
                        return '';
                    }
                },

                // AI ç›¸å…³æ–¹æ³•
                initAIConfig() {
                    try {
                        console.log('[initAIConfig] Starting AI configuration initialization');
                        
                        // ç¡®ä¿ aiManager å·²ç»è¢«æ­£ç¡®å¯¼å…¥
                        if (!aiManager) {
                            throw new Error('AIManager instance not available');
                        }
                        
                        this.presets = aiManager.getPresets();
                        this.aiApiKey = aiManager.getApiKey();

                        console.log('[initAIConfig] Current configuration', {
                            presets: this.presets,
                            selectedPresetId: this.selectedPresetId,
                            hasApiKey: !!this.aiApiKey
                        });

                        // è®¾ç½®é»˜è®¤é¢„è®¾
                        if (this.presets[this.selectedPresetId]) {
                            aiManager.setSelectedPreset(this.selectedPresetId);
                            console.log('[initAIConfig] Set default preset:', this.selectedPresetId);
                        }

                        // ç¡®ä¿å°† aiManager å®ä¾‹ä¼ é€’ç»™ practiceManager
                        if (this.practiceManager) {
                            this.practiceManager.setAIManager(aiManager);
                            console.log('[initAIConfig] AIManager instance set to PracticeManager');
                        }

                        // åˆå§‹åŒ–è‡ªåŠ¨è¯„åˆ†è®¾ç½®
                        this.autoScoring = aiManager.getAutoScoring();
                        console.log('[initAIConfig] Auto scoring initialized:', this.autoScoring);
                    } catch (error) {
                        console.error('[initAIConfig] Failed to initialize AI config:', error);
                    }
                },

                updateApiKey() {
                    if (this.currentProvider) {
                        console.log('[updateApiKey] Updating API key for provider:', this.currentProvider);
                        const key = this.providerApiKeys[this.currentProvider];
                        aiManager.setApiKey(this.currentProvider, key);
                        console.log('[updateApiKey] API key updated successfully');
                    }
                },

                calculateBankPercentage(bank) {
                    if (!bank || typeof bank.questionCount !== 'number' || typeof bank.availableQuestions !== 'number' || bank.availableQuestions === 0) {
                        return 0;
                    }
                    return Math.round((bank.questionCount / bank.availableQuestions) * 100) || 0;
                },
                showToast(message, type = 'success') {
                    const toast = document.createElement('div');
                    toast.textContent = message;
                    toast.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: ${type === 'success' ? 'rgba(0, 0, 0, 0.8)' : 'rgba(255, 0, 0, 0.8)'};
                    color: white;
                    padding: 8px 16px;
                    border-radius: 4px;
                    z-index: 1000;
                `;
                    document.body.appendChild(toast);
                    setTimeout(() => toast.remove(), 2000);
                },

                // éŸ³æ•ˆé…ç½®ç›¸å…³æ–¹æ³•
                initSoundConfig() {
                    import('./js/modules/ComboAudioManager.js').then(module => {
                        const ComboAudioManager = module.default;
                        
                        // ä»æœ¬åœ°å­˜å‚¨åŠ è½½é…ç½®
                        const savedConfig = JSON.parse(localStorage.getItem('SOUND_CONFIG') || '{}');
                        this.audioEnabled = savedConfig.audioEnabled ?? true;
                        this.volumeValue = savedConfig.volumeValue ?? 100;
                        this.comboWindowMs = savedConfig.comboWindowMs ?? 3000;
                        this.resetTimeoutMs = savedConfig.resetTimeoutMs ?? 5000;

                        // åˆ›å»ºéŸ³é¢‘ç®¡ç†å™¨å¹¶åº”ç”¨é…ç½®
                        this.audioManager = new ComboAudioManager({
                            comboWindowMs: this.comboWindowMs,
                            comboResetTimeoutMs: this.resetTimeoutMs,
                            minScoreForSound: 1
                        });

                        // åº”ç”¨éŸ³é‡å’Œé™éŸ³è®¾ç½®
                        const volume = this.volumeValue / 100;
                        this.audioManager.positiveAudios.forEach(audio => {
                            audio.volume = volume;
                            audio.muted = !this.audioEnabled;
                        });
                        this.audioManager.negativeAudios.forEach(audio => {
                            audio.volume = volume;
                            audio.muted = !this.audioEnabled;
                        });

                        console.log('[initSoundConfig] Loaded sound config:', {
                            audioEnabled: this.audioEnabled,
                            volumeValue: this.volumeValue,
                            comboWindowMs: this.comboWindowMs,
                            resetTimeoutMs: this.resetTimeoutMs
                        });
                    });
                },

                updateAudioConfig() {
                    if (!this.audioManager) return;

                    // æ›´æ–°éŸ³é¢‘ç®¡ç†å™¨é…ç½®
                    Object.assign(this.audioManager, {
                        comboWindowMs: this.comboWindowMs,
                        comboResetTimeoutMs: this.resetTimeoutMs,
                        minScoreForSound: 1
                    });

                    // åº”ç”¨éŸ³é‡å’Œé™éŸ³è®¾ç½®
                    const volume = this.volumeValue / 100;
                    this.audioManager.positiveAudios.forEach(audio => {
                        audio.volume = volume;
                        audio.muted = !this.audioEnabled;
                    });
                    this.audioManager.negativeAudios.forEach(audio => {
                        audio.volume = volume;
                        audio.muted = !this.audioEnabled;
                    });

                    // ä¿å­˜é…ç½®åˆ°æœ¬åœ°å­˜å‚¨
                    const config = {
                        audioEnabled: this.audioEnabled,
                        volumeValue: this.volumeValue,
                        comboWindowMs: this.comboWindowMs,
                        resetTimeoutMs: this.resetTimeoutMs
                    };
                    localStorage.setItem('SOUND_CONFIG', JSON.stringify(config));
                    console.log('[updateAudioConfig] Saved sound config:', config);
                },

                testSound(type, level) {
                    if (!this.audioManager) return;
                    
                    if (type === 'positive') {
                        this.audioManager.addPoints(level);
                    } else {
                        this.audioManager.subtractPoints(level);
                    }
                },

                closeSoundModal() {
                    this.showSoundModal = false;
                    this.updateAudioConfig();
                    this.stopTimer();
                },

                // è®¡åˆ†å’Œè®¡æ—¶ç›¸å…³æ–¹æ³•
                startTimer() {
                    if (this.timerInterval) {
                        clearInterval(this.timerInterval);
                    }
                    this.timerInterval = setInterval(() => {
                        if (!this.audioManager) return;
                        
                        const now = Date.now();
                        const comboEndTime = this.audioManager.comboEndTime;
                        
                        if (comboEndTime > now) {
                            this.timeLeft = (comboEndTime - now) / 1000;
                            this.timerProgress = (this.timeLeft / (this.comboWindowMs / 1000)) * 100;
                        } else {
                            this.timeLeft = 0;
                            this.timerProgress = 0;
                        }
                    }, 100);
                },

                stopTimer() {
                    if (this.timerInterval) {
                        clearInterval(this.timerInterval);
                        this.timerInterval = null;
                    }
                },

                addScore() {
                    if (!this.audioManager) return;
                    this.audioManager.addPoints(1);
                    this.currentScore = this.audioManager.getScore();
                    this.startTimer();
                },

                subtractScore() {
                    if (!this.audioManager) return;
                    this.audioManager.subtractPoints(1);
                    this.currentScore = this.audioManager.getScore();
                    this.startTimer();
                },

                resetScore() {
                    if (!this.audioManager) return;
                    this.audioManager.reset();
                    this.currentScore = 0;
                    this.timeLeft = 0;
                    this.timerProgress = 0;
                    this.stopTimer();
                },
                // æ·»åŠ  goHome æ–¹æ³•
                goHome(event) {
                    event.preventDefault();
                    if (this.pageState === 'quiz') {
                        // å¦‚æœæœ‰å®Œæˆçš„é¢˜ç›®ï¼Œæ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
                        if (this.currentSessionCompleted.size > 0) {
                            if (!confirm('ç¡®å®šè¦é€€å‡ºç»ƒä¹ å—ï¼Ÿå½“å‰è¿›åº¦å°†ä¸ä¼šä¿å­˜ã€‚')) {
                                return;
                            }
                        }
                    }

                    // é‡ç½®çŠ¶æ€
                    this.resetAllState();
                    this.updatePageState('home');
                },
                // AI ç›¸å…³æ–¹æ³•
                closeAIModal() {
                    this.showAIModal = false;
                },

                updateAutoScoring() {
                    // å¦‚æœè¦å¯ç”¨è‡ªåŠ¨è¯„åˆ†ï¼Œå…ˆæ£€æŸ¥æ˜¯å¦æœ‰ API key
                    if (this.autoScoring && !aiManager.hasApiKey()) {
                        this.showBanner('è¯·å…ˆé…ç½® API Key å†å¯ç”¨è‡ªåŠ¨è¯„åˆ†', 'warning');
                        this.autoScoring = false;
                        return;
                    }
                    aiManager.setAutoScoring(this.autoScoring);
                },

                deleteProviderApiKey() {
                    if (this.currentProvider) {
                        // æ¸…é™¤è¾“å…¥æ¡†ä¸­çš„å€¼
                        this.providerApiKeys[this.currentProvider] = '';
                        // ä» localStorage ä¸­åˆ é™¤
                        aiManager.deleteApiKey(this.currentProvider);
                        // æ˜¾ç¤ºæç¤º
                        this.showBanner(`å·²åˆ é™¤ ${this.currentPreset.name} çš„ API Key`, 'info');
                    }
                },

                handlePresetChange() {
                    try {
                        aiManager.setSelectedPreset(this.selectedPresetId);
                        this.log('info', `åˆ‡æ¢åˆ°æ¨¡å‹: ${this.presets[this.selectedPresetId].name}`);
                    } catch (error) {
                        console.error('åˆ‡æ¢æ¨¡å‹å¤±è´¥:', error);
                        this.log('error', `åˆ‡æ¢æ¨¡å‹å¤±è´¥: ${error.message}`);
                    }
                },

                getModelDescription(presetId) {
                    const preset = this.presets[presetId];
                    if (!preset) return '';
                    return `${preset.name} (${preset.model})`;
                },

                formatTime(timestamp) {
                    const date = new Date(timestamp);
                    return date.toLocaleTimeString();
                },

                updateLogLevel(event) {
                    const newLevel = event.target.value;
                    this.logLevel = newLevel;
                    aiManager.setLogLevel(newLevel);
                    localStorage.setItem('AI_LOG_LEVEL', newLevel);
                },

                clearLogs() {
                    aiManager.clearLogs();
                    this.logs = [];
                },
                log(level, message) {
                    aiManager.log(level, message);
                },

                // åˆå§‹åŒ–é”®ç›˜äº‹ä»¶ç›‘å¬
                initKeyboardEvents() {
                    this.$nextTick(() => {
                        if (this.pageState === 'setDescription') {
                            console.log('Page mounted in setDescription state');
                            const buttons = document.querySelectorAll('.mode-btn');
                            console.log('Initial mode buttons state:', {
                                totalButtons: buttons.length,
                                buttonElements: Array.from(buttons).map(btn => ({
                                    text: btn.textContent.trim(),
                                    tabIndex: btn.tabIndex,
                                    hasClickHandler: btn.onclick !== null,
                                    hasKeydownHandler: btn.onkeydown !== null
                                }))
                            });
                        }
                    });

                    // æ·»åŠ æµè§ˆå™¨å‰è¿›/åé€€æŒ‰é’®æ”¯æŒ
                    window.addEventListener('popstate', this.handlePopState);

                    // æ·»åŠ  URL å˜åŒ–ç›‘å¬
                    window.addEventListener('hashchange', this.handleUrlChange);
                    window.addEventListener('popstate', this.handleUrlChange);

                    // æ·»åŠ å…¨å±€Alt+Hè¿”å›å¿«æ·é”®
                    window.addEventListener('keydown', this.handleGlobalBackShortcut);
                },

                // AI æµå¼æ¸²æŸ“æµ‹è¯•
                async testStreaming() {
                    if (!this.checkApiKey()) return;
                    
                    this.isTestingStream = true;
                    this.testStreamContent = 'æ­£åœ¨è¿æ¥...';
                    
                    try {
                        const systemPrompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„é¢˜ç›®è§£æç³»ç»Ÿã€‚ä½ éœ€è¦è§£é‡Šä¸ºä»€ä¹ˆç»™å®šçš„ç­”æ¡ˆæ˜¯æ­£ç¡®çš„ã€‚
ä½ å¿…é¡»ä»¥JSONæ ¼å¼è¿”å›ç»“æœï¼ŒåŒ…å«ä»¥ä¸‹å­—æ®µï¼š
{
    "analysis": "è§£æå†…å®¹ï¼Œéœ€è¦ï¼š
    1. èšç„¦ç­”æ¡ˆè·¯å¾„ï¼Œè¯´æ˜å¦‚ä½•æœ€ç›´æ¥åˆ¤æ–­å‡ºæ­£ç¡®ç­”æ¡ˆ
    2. è§£é‡Šé¢˜ç›®ä¸­å¸¦ã€Œã€çš„æ¦‚å¿µ
    3. ä½¿ç”¨ç®€çŸ­æœ‰åŠ›çš„è¯­å¥
    4. è¯­è¨€æœ´å®æ˜“æ‡‚
    5. æ§åˆ¶ç¯‡å¹…"
}`;

                        const response = await this.aiManager.streamChat([
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: this.testPrompt }
                        ], {
                            response_format: { type: 'json_object' }
                        });

                        let fullContent = '';
                        let partialContent = '';
                        let isReasoningPhase = false;

                        for await (const chunk of response) {
                            switch (chunk.type) {
                                case 'reasoning': {
                                    isReasoningPhase = true;
                                    this.testStreamContent = 'æ­£åœ¨æ€è€ƒä¸­...\n' + chunk.content;
                                    break;
                                }
                                case 'answer': {
                                    fullContent += chunk.content;
                                    try {
                                        // å°è¯•è§£æå®Œæ•´çš„ JSON
                                        const parsed = JSON.parse(fullContent);
                                        if (parsed.analysis) {
                                            this.testStreamContent = parsed.analysis;
                                        }
                                    } catch (error) {
                                        // JSON è¿˜ä¸å®Œæ•´ï¼Œå°è¯•æå–éƒ¨åˆ†å†…å®¹è¿›è¡Œæ¸²æŸ“
                                        if (!isReasoningPhase) {
                                            partialContent += chunk.content;
                                            
                                            // å°è¯•ä»éƒ¨åˆ†å†…å®¹ä¸­æå–æœ‰æ„ä¹‰çš„æ–‡æœ¬
                                            let cleanContent = partialContent
                                                .replace(/^{?\s*"analysis":\s*"?/, '')
                                                .replace(/\\n/g, '\n')
                                                .replace(/\\"/, '"');
                                                    
                                            // å¦‚æœå†…å®¹çœ‹èµ·æ¥æ˜¯å®Œæ•´çš„JSONç»“å°¾ï¼Œç§»é™¤å®ƒ
                                            if (cleanContent.endsWith('"}')) {
                                                cleanContent = cleanContent.slice(0, -2);
                                            }
                                            
                                            this.testStreamContent = cleanContent;
                                        }
                                    }
                                    break;
                                }
                                case 'finish': {
                                    console.log('[testStreaming] Stream finished:', chunk.reason);
                                    break;
                                }
                                case 'tool_calls': {
                                    console.log('[testStreaming] Tool calls received:', chunk.content);
                                    break;
                                }
                            }
                        }
                    } catch (error) {
                        console.error('[testStreaming] Error:', error);
                        if (error.message === 'API Key not set') {
                            this.showToast('å…ˆé…ç½® API Key å†æµ‹è¯•', 'info');
                        } else {
                            this.showToast('æµ‹è¯•å¤±è´¥: ' + error.message, 'error');
                        }
                        this.testStreamContent = 'æµ‹è¯•å¤±è´¥: ' + error.message;
                    } finally {
                        this.isTestingStream = false;
                    }
                },

                // æ¸²æŸ“æµ‹è¯•å†…å®¹
                renderedTestContent() {
                    if (!this.testStreamContent) return '';
                    return this.renderMarkdownWithLatex(this.testStreamContent);
                },

                // æ·»åŠ æ‰‹åŠ¨è§¦å‘AIè¯„åˆ†çš„æ–¹æ³•
                async triggerAIScoring() {
                    if (!this.checkApiKey()) return;
                    
                    try {
                        const q = this.currentQuestion;
                        let answer;
                        let isCorrect;
                        
                        if (q.type === 'fill-in-blank') {
                            answer = this.fillInAnswers.join('\n');
                        } else if (q.type === 'short-answer') {
                            answer = this.shortAnswerText;
                        } else {
                            return;
                        }
                        
                        isCorrect = await this.practiceManager.checkAnswerWithAI(answer, q);
                        
                        // æ›´æ–°é¢˜ç›®çŠ¶æ€
                        if (isCorrect !== null) {
                            await this.practiceManager.updateQuestionStatus(q.id, isCorrect);
                            this.updateLocalStats(isCorrect);
                        }
                    } catch (error) {
                        if (error.message === 'API Key not set') {
                            this.showToast('è¯·ç‚¹å‡»å³ä¸Šè§’çš„é²¸é±¼å›¾æ ‡è®¾ç½® API Key', 'info');
                        } else {
                            this.showToast('AI è¯„åˆ†å¤±è´¥: ' + error.message, 'error');
                        }
                    }
                },

                // Show a toast notification
                showToast(message, type = 'info', duration = 3000) {
                    const toast = {
                        id: Date.now(),
                        message,
                        type
                    };
                    this.toasts.push(toast);

                    // Remove the toast after duration
                    setTimeout(() => {
                        const index = this.toasts.findIndex(t => t.id === toast.id);
                        if (index > -1) {
                            const toastElement = document.querySelector(`[data-toast-id="${toast.id}"]`);
                            if (toastElement) {
                                toastElement.style.animation = 'fadeOut 0.3s ease-out';
                                setTimeout(() => {
                                    this.toasts.splice(index, 1);
                                }, 300);
                            } else {
                                this.toasts.splice(index, 1);
                            }
                        }
                    }, duration);
                },

                // Check if API key is set before AI operations
                checkApiKey() {
                    if (!this.aiManager?.hasApiKey()) {
                        this.showToast('è¯·ç‚¹å‡»å³ä¸Šè§’çš„é²¸é±¼å›¾æ ‡è®¾ç½® API Key', 'info');
                        return false;
                    }
                    return true;
                },
            }
        };

        // åˆ›å»º Vue åº”ç”¨
        const app = Vue.createApp(appConfig);
        app.mount('#app');
    </script>

</body>

</html>